# 第五章。 网络故障排除

在[第三章](03.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 3. Troubleshooting a Web Application")、*Web 应用故障排除*中，我们深入探讨了 Web 应用故障排除; 在讨论一个复杂的应用程序错误时，我们完全跳过了 web 应用程序的网络方面。 在本章中，我们将研究一个报告的问题，它将带领我们了解诸如 DNS、路由，当然还有 RHEL 系统的网络配置等概念。

网络是任何 Linux 系统管理员的基本技能。 引用一位过去的老师的话:

> 没有网络的服务器对每个人都是无用的。

作为系统管理员，您所管理的每个服务器或桌面都将有某种类型的网络连接。 无论该网络连接是在隔离的公司网络中，还是直接连接到 Internet，都涉及到网络。

由于网络是一个如此关键的话题，本章将涵盖网络和网络连接的许多方面; 但是，它不包括防火墙。 防火墙故障诊断和配置实际上将在[第 6 章](06.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 6. Diagnosing and Correcting Firewall Issues")、*诊断和纠正防火墙问题*中介绍。

# 数据库连接问题

在[第 3 章](03.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 3. Troubleshooting a Web Application")、*故障处理 Web 应用程序*中，我们正在故障处理公司博客的一个问题。 在本章中，我们将再次解决这个博客的问题; 然而，今天的问题有点不同。

当天到达后，我们收到一个开发人员打来的电话:*WordPress 博客返回一个错误，它无法连接到数据库*。

# 数据收集

根据我们一直遵循的故障排除流程，下一步是围绕该问题收集尽可能多的数据。 最好的信息来源之一是报告问题的人; 针对这种情况，我们会问两个基本问题:

*   我如何复制问题并看到错误?
*   WordPress 应用程序最近有什么变化吗?

当被问及这个问题时，开发人员表示，我们只需在浏览器中访问博客就可以看到这个错误。 关于第二个问题，开发人员告诉我们，数据库服务最近从 web 服务器转移到了一个新的专用数据库服务器上。 他还提到，迁移发生在几天前，该应用程序直到今天都在工作。

由于数据库服务是几天前移动的，并且应用程序一直工作到今天早上，所以不太可能是这个更改导致了问题。 然而，我们不应忽视这种可能性。

## 重复这个问题

正如前面的章节所讨论的，一个关键的数据收集任务是复制问题。 我们这样做不仅是为了验证正在报告的问题就是正在发生的问题，而且还为了发现任何可能没有报告的额外错误。

因为开发人员说我们可以通过直接访问博客来复制这一点，所以我们将在浏览器中这样做。

![Duplicating the issue](../images/00004.jpeg)

似乎我们可以很容易地复制这个问题。 根据这个错误，应用程序似乎是简单地说它在建立数据库连接时遇到了问题。 虽然这本身并不意味着这个问题与网络有关，但它可能是。 这个问题也可能仅仅是数据库服务本身的问题。

要确定问题是网络问题还是数据库服务问题，我们首先需要找到将应用程序配置为连接到哪个服务器。

## 查找数据库服务器

与前面的章节一样，我们将通过查看应用程序配置文件来确定应用程序使用的服务器。 从我们之前在[第三章](03.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 3. Troubleshooting a Web Application")，*Web 应用程序故障排除*中的故障排除，我们知道 WordPress 应用程序是托管在`blog.example.com`上的。 首先，我们将登陆博客的 web 服务器，查看 WordPress 的配置文件。

```sh
$ ssh blog.example.com -l vagrant
vagrant@blog.example.com's password:
Last login: Sat Feb 28 18:49:40 2015 from 10.0.2.2
[blog]$

```

### 提示

由于我们将针对多个系统执行命令，本章中的示例将在命令行提示符中包含一个主机名，比如`blog`或`db`。

我们在[第三章](03.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 3. Troubleshooting a Web Application")，*Web 应用程序故障诊断*中了解到 WordPress 数据库配置存储在`/var/www/html/wp-config.php`文件中。 要快速搜索该文件以获取数据库信息，可以使用`grep`命令搜索字符串`DB`，因为在前面的事件中，这个字符串用于数据库配置。

```sh
[blog]$ grep DB wp-config.php
define('DB_NAME', 'wordpress');
define('DB_USER', 'wordpress');
define('DB_PASSWORD', 'password');
define('DB_HOST', 'db.example.com');
define('DB_CHARSET', 'utf8');
define('DB_COLLATE', '');

```

通过上面的代码，我们可以看到应用程序当前被配置为连接到`db.example.com`。 第一个简单的故障排除步骤是尝试手动连接数据库。 手动测试数据库连接的一种简单方法是使用`telnet`命令。

## 测试连接

`telnet`命令是一个非常有用的网络和网络服务故障诊断工具，因为它的设计目的是简单地建立到指定主机和端口的基于 tcp 的网络连接。 对于我们的示例，我们将尝试连接端口`3306`上的主机`db.example.com`。

MySQL 和 MariaDB 的默认端口是`3306`; 在前一章中，我们已经确定了这个 web 应用程序需要这两种数据库服务之一。 由于我们没有在`wp-config.php`文件的配置中看到列出的特定端口，我们将假设数据库服务运行在这个默认端口上。

### Telnet from blog.example.com

首先，我们将从博客服务器本身执行`telnet`命令。 我们在应用程序运行的同一台服务器上进行测试，这一点很重要，因为这允许我们在应用程序接收错误时在相同的网络条件下进行测试。

要使用 telnet 连接到数据库服务器，我们将执行`telnet`命令，然后执行我们希望连接到的主机名(`db.example.com`)和端口(`3306`)。

```sh
[blog]$ telnet db.example.com 3306
Trying 192.168.33.12...
telnet: connect to address 192.168.33.12: No route to host

```

提示telnet 连接失败。 有趣的是所提供的错误; **没有到主机的路由**错误似乎清楚地表明一个潜在的网络问题。

### 从我们的笔记本电脑 Telnet

由于来自博客服务器的连接尝试失败，错误提示存在与网络相关的问题，所以我们可以从笔记本电脑尝试相同的连接，以确定问题是在博客服务器端还是`db`服务器端。

要从我们的笔记本电脑测试这个连接，我们可以再次使用`telnet`命令。 即使我们的笔记本电脑不一定运行 Linux 操作系统，我们也可以使用这个命令。 原因是`telnet`命令是一个跨平台实用程序; 在本章中，我们将使用几个跨平台的命令。 虽然这些命令可能不多，但通常有几个命令可以在大多数操作系统上工作，包括那些传统上没有广泛的命令行功能的命令。

虽然一些操作系统已经从默认安装中删除了`telnet`客户端，但仍然可以安装该软件。 对于我们的示例，膝上电脑运行 OS X，它目前部署了`telnet`客户机。

```sh
[laptop]$ telnet db.example.com 3306
Trying 10.0.0.50...
Connected to 10.0.0.50.
Escape character is '^]'.
Connection closed by foreign host.

```

看来我们的笔记本电脑也无法连接到数据库服务; 然而，这次的错误是不同的。 这一次似乎提示连接尝试被远程服务关闭了。 我们也没有看到来自远程服务的消息，这将表明连接从未完全建立。

使用`telnet`命令建立端口可用性的一个警告是，`telnet`命令将显示一个连接为**Connected**; 然而，连接不一定在这一点上建立。 使用 telnet 时的一般规则是，在收到远程服务的消息之前不要假设连接成功。 在我们的示例中，我们没有收到来自远程服务的消息。

## 平

由于的`telnet`和我们的笔记本电脑都失败了，我们应该检查这个问题是仅仅局限于数据库服务还是连接到整个服务器。 测试服务器到服务器连接性的一个工具是`ping`命令，与`telnet`命令一样，它也是一个跨平台实用程序。

要用`ping`命令测试连接性，我们可以简单地执行命令，后面跟着我们希望`ping`的主机。

```sh
[blog]$ ping db.example.com
PING db.example.com (192.168.33.12) 56(84) bytes of data.
From blog.example.com (192.168.33.11) icmp_seq=1 Destination Host Unreachable
From blog.example.com (192.168.33.11) icmp_seq=2 Destination Host Unreachable
From blog.example.com (192.168.33.11) icmp_seq=3 Destination Host Unreachable
From blog.example.com (192.168.33.11) icmp_seq=4 Destination Host Unreachable
^C
--- db.example.com ping statistics ---
6 packets transmitted, 0 received, +4 errors, 100% packet loss, time 5008ms

```

来自`ping`命令的错误似乎与来自`telnet`命令的错误非常相似。 为了更好地理解这个错误，让我们首先更好地理解`ping`命令是如何工作的。

首先，在执行任何其他操作之前，`ping`命令将尝试解析提供的主机名。 这意味着，在执行任何其他操作之前，我们的 ping 执行尝试识别`db.example.com`的 IP 地址。

```sh
PING db.example.com (192.168.33.12) 56(84) bytes of data.

```

从结果中可以看到，`ping`命令将该主机识别为解析到`192.168.33.12`。 一旦 ping 有了 IP 地址，它将发送一个`ICMP`回显请求网络包到该 IP。 在本例中，这意味着它正在向`192.168.33.12`发送一个`ICMP`echo 请求。

ICMP 是一种用作控制系统的网络协议。 当远端主机，例如`192.168.33.12`接收到一个`ICMP`回显请求网络包时，它应该向请求主机发送一个`ICMP`回显应答网络包。 该活动允许两台主机通过执行简单的*乒乓*网络版本来验证网络连接。

```sh
From blog.example.com (192.168.33.11) icmp_seq=1 Destination Host Unreachable

```

如果我们的`ICMP`回显请求包从未到达`192.168.33.12`服务器，那么`ping`命令就不会有输出。 然而，我们收到了一个错误; 这意味着另一端的系统启动了，但两台主机之间的连接出现了错误，阻止了完全的双向讨论。

关于这个问题，产生的一个问题是，对于来自博客服务器的所有网络连接，错误是正确的，还是仅针对`blog`和`db`服务器之间的通信。 我们可以通过对另一个通用地址执行`ping`请求来测试这一点。 由于我们的系统连接到 Internet，我们可以简单地使用一个公共 Internet 域。

```sh
# ping google.com
PING google.com (216.58.216.46) 56(84) bytes of data.
64 bytes from lax02s22-in-f14.1e100.net (216.58.216.46): icmp_seq=1 ttl=63 time=23.5 ms
64 bytes from lax02s22-in-f14.1e100.net (216.58.216.46): icmp_seq=2 ttl=63 time=102 ms
64 bytes from lax02s22-in-f14.1e100.net (216.58.216.46): icmp_seq=3 ttl=63 time=26.9 ms
64 bytes from lax02s22-in-f14.1e100.net (216.58.216.46): icmp_seq=4 ttl=63 time=25.6 ms
64 bytes from lax02s22-in-f14.1e100.net (216.58.216.46): icmp_seq=5 ttl=63 time=25.6 ms
^C
--- google.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4106ms
rtt min/avg/max/mdev = 23.598/40.799/102.156/30.697 ms

```

前面的示例是一个正在工作的`ping`请求和应答的示例。 在这里，我们不仅可以看到[Google.com](http://Google.com)解析到的 IP，还可以看到返回的`ping`请求。 这意味着，当我们的博客服务器发送`ICMP echo request`时，远程服务器`216.58.216.46`将发送`ICMP echo reply`。

## DNS 故障处理

有趣的是，`ping`和`telnet`命令告诉我们除了之外的网络连接是`db.example.com`主机名的 IP 地址。 然而，在笔记本电脑上执行这些操作与在博客服务器上执行这些操作时，结果似乎是不同的。

从博客服务器，我们的`telnet`试图连接到`192.168.33.12`，与我们的`ping`命令的地址相同。

```sh
[blog]$ telnet db.example.com 3306
Trying 192.168.33.12...
However, from the laptop, our telnet tried to connect to 10.0.0.50, a completely different IP address.
[laptop]$ telnet db.example.com 3306
Trying 10.0.0.50...

```

原因很简单; 似乎我们的笔记本电脑得到了不同的 DNS结果作为我们的博客服务器。 然而，如果是这样的话，这可能意味着我们的问题可能仅仅与 DNS 问题有关。

### 使用 dig 检查 DNS

DNS 是现代网络的一个重要方面。 我们目前的问题就是它重要性的一个很好的例子。 在 WordPress 配置文件中，我们的数据库服务器被设置为`db.example.com`。 这意味着在应用服务器建立数据库连接之前，它必须首先查找 IP 地址。

在许多情况下，可以相当安全地假设`ping`识别的 IP 地址很可能是 DNS 提供的 IP 地址。 然而，这种情况并不总是如此，我们可能很快就会发现我们的具体问题。

`dig`命令是一个非常有用的 DNS 故障诊断命令; 它非常灵活，可以用于执行许多不同类型的 DNS 请求。 要验证`db.example.com`的 DNS，我们可以简单地执行`dig`命令，后面跟着要查询的主机名:`db.example.com`。

```sh
[blog]$ dig db.example.com

; <<>> DiG 9.9.4-RedHat-9.9.4-14.el7_0.1 <<>> db.example.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 15857
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;db.example.com.      IN  A

;; ANSWER SECTION:
db.example.com.    15  IN  A  10.0.0.50

;; Query time: 39 msec
;; SERVER: 10.0.2.3#53(10.0.2.3)
;; WHEN: Sun Mar 01 20:51:22 UTC 2015
;; MSG SIZE  rcvd: 59

```

如果我们查看从`dig`返回的数据，可以看到 DNS 名称`db.example.com`并没有解析为`192.168.33.12`，而是解析为`10.0.0.50`。 我们可以在`dig`命令的输出`ANSWER SECTION`中看到这一点。

```sh
;; ANSWER SECTION:
db.example.com.    15  IN  A  10.0.0.50

```

`dig`的一个非常有用的选项是指定要查询的服务器。 在之前的`dig`执行中，我们可以看到服务器`10.0.2.3`是提供`10.0.0.50`地址的服务器。

```sh
;; Query time: 39 msec
;; SERVER: 10.0.2.3#53(10.0.2.3)

```

由于我们不熟悉这个 DNS 服务器，我们可以通过查询谷歌的公共 DNS 服务器进一步验证返回的结果。 我们可以通过添加`@`和我们想要使用的 DNS 服务器 IP 或主机名来实现这一点。 在下面的例子中，我们正在请求`8.8.8.8`一个 DNS 服务器，它是谷歌的公共 DNS 基础设施的一部分。

```sh
[blog]$ dig @8.8.8.8 db.example.com

; <<>> DiG 9.9.4-RedHat-9.9.4-14.el7_0.1 <<>> @8.8.8.8 example.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42743
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;db.example.com.      IN  A

;; ANSWER SECTION:
db.example.com.    18639  IN  A  10.0.0.50

;; Query time: 39 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Sun Mar 01 22:14:53 UTC 2015
;; MSG SIZE  rcvd: 56
It seems that Google's public DNS has the same results as 10.0.2.3.

```

### 使用 nslookup 查找 DNS

另一个用于故障诊断 DNS 的好工具是`nslookup`。 `nslookup`命令是一个已经存在了很长时间的命令。 事实上，它是存在于几乎所有主要操作系统上的另一个跨平台命令。

要使用`nslookup`执行简单的 DNS 查找，我们可以简单地运行后跟 DNS 名称的命令进行查询，类似于`dig`。

```sh
[blog]$ nslookup db.example.com
Server:    10.0.2.3
Address:  10.0.2.3#53

Non-authoritative answer:
Name:  db.example.com
Address: 10.0.0.50

```

与`dig`一样，`nslookup`命令也可以用于查询特定的 DNS 服务器。 这可以通过两种方法来实现。 第一种方法是在命令的末尾添加服务器地址。

```sh
[blog]$ nslookup db.example.com 8.8.8.8
Server:    8.8.8.8
Address:  8.8.8.8#53

Non-authoritative answer:
Name:  db.example.com
Address: 10.0.0.50

```

第二种方法是在交互模式下使用`nslookup`。 要进入交互模式，只需执行`nslookup`，没有其他选项。

```sh
# nslookup
>

```

进入交互模式后，通过输入`server <dns server>`指定要使用的服务器。

```sh
# nslookup
> server 8.8.8.8
Default server: 8.8.8.8
Address: 8.8.8.8#53
>

```

最后，要查找 DNS 名称，只需输入要查询的域。

```sh
# nslookup
> server 8.8.8.8
Default server: 8.8.8.8
Address: 8.8.8.8#53
> db.example.com
Server:    8.8.8.8
Address:  8.8.8.8#53

Non-authoritative answer:
Name:  db.example.com
Address: 10.0.0.50
>
To leave the interactive mode, simply type exit.
> exit

```

那么为什么使用`nslookup`而不是`dig`呢? 虽然`dig`命令非常有用，但它不是一个跨平台命令，传统上只在 Unix 和 Linux 系统上存在。 另一方面，`nslookup`命令是跨平台的，可以在`dig`命令不可用的大多数环境中找到。 作为系统管理员，熟悉许多命令是很重要的，能够使用任何可用的命令执行任务是非常有用的。

### dig 和 nslookup 告诉我们什么?

现在我们已经使用了`dig`和`nslookup`来查询 DNS 名称`db.example.com`，下面让我们回顾一下所发现的内容。

*   域`db.example.com`实际上解析为`10.0.0.50`
*   `ping`命令为域`db.example.com`返回`192.168.33.12`

`ping`命令如何返回一个地址，而 DNS 返回另一个地址? 一种可能是在`/etc/hosts`文件中配置。 我们可以通过一个简单的`grep`命令非常快速地验证这一点。

```sh
[blog]$ grep example.com /etc/hosts
192.168.33.11 blog.example.com
192.168.33.12 db.example.com

```

#### 关于/etc/hosts 的一些信息

在创建**Bind**等 DNS 服务器之前，使用本地`hosts`文件管理域到 ip 的映射。 该文件包含系统需要连接到的每个域地址的列表。 然而，随着时间的推移，这种方法变得复杂，因为网络从少数主机发展到成千上万的主机。

在 Linux 和大多数 Unix 发行版上，`hosts`文件位于`/etc/hosts`。 默认情况下，`/etc/hosts`文件中的任何条目将取代 DNS 请求。 这意味着，在默认情况下，如果`/etc/hosts`文件中存在域到 ip 的映射，那么将使用该映射，系统不会从另一个 DNS 系统获取相同的域。

这是 Linux 的默认行为; 但是，我们可以通过读取`/etc/nsswitch.conf`文件来检查这个服务器是否使用了这个默认配置。

```sh
[blog]$ grep hosts /etc/nsswitch.conf
hosts:      files dns

```

`nsswitch.conf`文件是一个配置，它允许管理员配置使用哪个后端系统来查找用户、组、网络组、主机名和服务等项。 例如，如果我们想配置一个系统来使用`ldap`来查找用户组，我们可以通过更改`/etc/nsswitch.conf`文件中的值来实现。

```sh
[blog]$ grep group /etc/nsswitch.conf
group:      files sss

```

根据上述`grep`命令的输出结果，配置 blog 系统使用本地组文件，然后使用 SSSD 服务查找用户组。 要将`ldap`添加到这个配置中，只需按照所需的顺序(即`ldap files sss`)将其添加到列表中。

对于由`hosts`配置指定的 DNS，我们的服务器被配置为首先根据文件查找主机，然后再根据 DNS 查找主机。 这意味着我们的系统在通过 DNS 查找域之前会先解析`/etc/hosts`文件。

### DNS 概述

现在我们已经确认了DNS 和`/etc/hosts`文件，我们知道有人已经将此应用服务器配置为`db.example.com`解析为`192.168.33.12`。 这是一个错误或这是一种方式连接到数据库服务器不使用 DNS?

现在下结论还为时过早，但是我们知道主机`192.168.33.12`没有从博客服务器向我们的`ICMP echo request`发送`ICMP echo reply`。

## 来自其他位置的 ping

在处理网络问题时，最好从多个位置或服务器尝试连接。 对于数据收集器类型的故障诊断人员来说，这似乎是显而易见的，但是受过教育的猜测型故障诊断人员可能会忽略这个非常有用的步骤。

对于我们的示例，我们将运行从笔记本电脑到`192.168.33.12`的测试`ping`。

```sh
[laptop]$ ping 192.168.33.12
PING 192.168.33.12 (192.168.33.12): 56 data bytes
64 bytes from 192.168.33.12: icmp_seq=0 ttl=64 time=0.573 ms
64 bytes from 192.168.33.12: icmp_seq=1 ttl=64 time=0.425 ms
64 bytes from 192.168.33.12: icmp_seq=2 ttl=64 time=0.461 ms
^C
--- 192.168.33.12 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.425/0.486/0.573/0.063 ms

```

从`ping`请求的结果来看，我们的笔记本电脑似乎能够毫无问题地连接到`192.168.33.12`。

这个告诉我们什么? 事实上，相当多! 它告诉我们有问题的服务器已经启动; 它还确认存在连接问题，特别是在`blog.example.com`和`db.example.com`之间。 如果问题是由于`db.example.com`服务器关闭或配置错误导致的，那么我们的笔记本电脑也会受到影响。

然而，事实并非如此。 实际上恰恰相反; 看起来从我们的笔记本电脑到服务器的连接工作正常。

## 使用 cURL 测试端口连通性

早些时候，当用`telnet`测试笔记本电脑的 MariaDB 端口时，`telnet`命令正在测试服务器`10.0.0.50`。 但是，根据`/etc/hosts`配置，似乎需要的数据库服务器是`192.168.33.12`。

为了验证数据库服务实际上已经启动，我们应该使用`192.168.33.12`地址执行相同的`telnet`测试。 但是，这一次我们将使用`curl`来执行这个测试，而不是使用`telnet`。

我见过许多环境(尤其是最近)禁止安装`telnet`客户端，或者默认情况下不执行安装。 对于这样的环境，有一些可以测试端口连接的工具是很重要的。 如果 telnet 不可用，可以使用`curl`命令作为替代。

在第三章、*Web 应用程序故障排除*中，我们使用`curl`命令请求一个 Web 页面。 `curl`命令实际上可以用于许多不同的协议; 在本例中，我们感兴趣的协议是 Telnet 协议。

下面是使用笔记本电脑中的`curl`通过端口`3306`建立到`db.example.com`服务器的连接的示例。

```sh
[laptop]$  curl -v telnet://192.168.33.12:3306
* Rebuilt URL to: telnet://192.168.33.12:3306/
* Hostname was NOT found in DNS cache
*   Trying 192.168.33.12...
* Connected to 192.168.33.12 (192.168.33.12) port 3306 (#0)
* RCVD IAC 106
^C

```

从示例中可以看出，不仅膝上型计算机能够连接到端口`3306`上的服务器，`curl`命令还能够从`RCVD IAC 106`服务接收一条消息。

当对Telnet 测试使用`curl`时，必须使用`–v`(详细)标志将 curl 设置为详细模式。 如果没有详细标志，`curl`只会隐藏连接细节，而连接细节正是我们所寻找的。

在前面的例子中，我们可以看到来自笔记本电脑的连接是成功的; 为了进行比较，我们可以使用相同的命令来测试博客服务器的连通性。

```sh
[blog]$ curl -v telnet://192.168.33.12:3306
* About to connect() to 192.168.33.12 port 3306 (#0)
*   Trying 192.168.33.12...
* No route to host
* Failed connect to 192.168.33.12:3306; No route to host
* Closing connection 0
curl: (7) Failed connect to 192.168.33.12:3306; No route to host

```

如所料，连接请求失败。

通过以上使用`curl`的测试，我们可以确定数据库服务器正在监听并接受端口`3306`上的连接; 但是，博客服务器无法连接到数据库服务器。 我们不知道的是问题是在博客服务器端还是在数据库服务器端。 要确定连接的哪一边有问题，我们需要查看网络连接的详细信息。 为此，我们将使用两个命令，第一个是`netstat`，第二个是`tcpdump`。

## 用 netstat 显示当前的网络连接

`netstat`命令是一个非常广泛的工具，可用于对网络问题的许多方面进行故障排除。 在本例中，我们将使用两个基本标志来打印现有的网络连接。

```sh
[blog]# netstat -na
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address State 
tcp        0      0 127.0.0.1:25            0.0.0.0:* LISTEN 
tcp        0      0 0.0.0.0:52903           0.0.0.0:* LISTEN 
tcp        0      0 0.0.0.0:3306            0.0.0.0:* LISTEN 
tcp        0      0 0.0.0.0:111             0.0.0.0:* LISTEN 
tcp        0      0 0.0.0.0:22              0.0.0.0:* LISTEN 
tcp        0      0 10.0.2.16:22            10.0.2.2:50322 ESTABLISHED
tcp        0      0 192.168.33.11:22        192.168.33.1:53359 ESTABLISHED
tcp6       0      0 ::1:25                  :::* LISTEN 
tcp6       0      0 :::57504                :::* LISTEN 
tcp6       0      0 :::111                  :::* LISTEN 
tcp6       0      0 :::80                   :::* LISTEN 
tcp6       0      0 :::22                   :::* LISTEN 
udp        0      0 0.0.0.0:5353            0.0.0.0:*
udp        0      0 0.0.0.0:68              0.0.0.0:*
udp        0      0 0.0.0.0:111             0.0.0.0:*
udp        0      0 0.0.0.0:52594           0.0.0.0:*
udp        0      0 127.0.0.1:904           0.0.0.0:*
udp        0      0 0.0.0.0:49853           0.0.0.0:*
udp        0      0 0.0.0.0:53449           0.0.0.0:*
udp        0      0 0.0.0.0:719             0.0.0.0:*
udp6       0      0 :::54762                :::*
udp6       0      0 :::58674                :::*
udp6       0      0 :::111                  :::*
udp6       0      0 :::719                  :::*
raw6       0      0 :::58                   :::*

```

在前面的例子中,我们执行与`–n``netstat`命令(dns)国旗,这告诉`netstat`不查找 IPs 的 dns 主机名或端口号翻译服务名称,和`–a`(全部)标志告诉`netstat`打印倾听和 non-listening 套接字。

这些标志具有`netstat`的效果，显示应用程序绑定的所有网络连接和端口。

示例`netstat`命令显示了相当多的信息。 为了更好地理解这个信息，让我们更好地检查一下输出。

```sh
Proto Recv-Q Send-Q Local Address         Foreign Address      State
tcp       0     0 127.0.0.1:25            0.0.0.0:*            LISTEN

```

`netstat`的输出分为 6 列，第 1 列是**Proto**，显示套接字协议。 在上面的代码片段中，套接字使用 TCP 协议。

第二列**Recv-Q**是应用程序通过使用此套接字所接收但未复制的字节计数。 这基本上是内核从网络接收数据到应用程序接受数据之间等待的字节数。

第三列**Send-Q**是发送但未被远程主机确认的字节数。 基本上，数据已经发送到远程主机，但本地主机还没有收到远程主机对该数据的接受。

第四列是**本地地址**，这是用于套接字的本地服务器地址。 我们的代码片段显示本地主机地址为`127.0.0.1`，端口为`25`。

第五栏是**国外地址**或远端地址。 本专栏列出了远程服务器的 IP 和端口。 由于我们前面使用的示例类型，它被列出为 IP`0.0.0.0`和端口`*`，这是一个通配符，表示任何内容。

第六列，也就是最后一列，是状态**套接字。 对于 TCP 连接，状态将告诉我们 TCP 连接的当前状态。 在前面的例子中，状态被列出为`LISTEN`; 这告诉我们，列出的套接字用于接受 TCP 连接。**

 **如果我们将所有列放在一起，这一行告诉我们，我们的服务器正在通过 IP`127.0.0.1`监听端口`25`上的新连接，并且它是基于 tcp 的连接。

### 使用 netstat 来监视新连接

现在我们对的输出有了进一步的了解，我们可以使用它来查找从应用服务器到数据库服务器的新连接。 为了使用`netstat`来观察新的连接，我们将使用一个经常被忽略的特性`netstat`。

与`vmstat`命令类似，可以将`netstat`置于连续模式中，这将每隔几秒打印相同的输出。 要做到这一点，只需将间隔放在命令的末尾。

在下面的例子中，我们将使用相同的`netstat`标志，间隔为`5`s; 然而，我们还将管道输出到`grep`，并使用`grep`过滤端口`3306`。

```sh
[blog]# netstat -na 5 | grep 3306
tcp        0      1 192.168.33.11:59492     192.168.33.12:3306 SYN_SENT 
tcp        0      1 192.168.33.11:59493     192.168.33.12:3306 SYN_SENT 
tcp        0      1 192.168.33.11:59494     192.168.33.12:3306 SYN_SENT

```

除了运行`netstat`命令之外，我们还可以在浏览器中导航到`blog.example.com`地址。 我们可以这样做来强制 web 应用程序尝试连接到数据库。

通常，web应用程序有两种类型的到数据库的连接，一种是持久连接(它们总是与数据库保持连接)，另一种是非持久连接(它们只在需要时建立)。 因为我们不知道这个 WordPress 安装使用的是哪种类型，所以这种类型的故障排除假设是非持久的会更安全。 这意味着，为了触发数据库连接，必须有到 WordPress 应用程序的流量。

从`netstat`的输出中，我们可以看到对数据库的连接尝试，而且不仅仅是对任何数据库的连接尝试，而是对`192.168.33.12`上的数据库服务的连接尝试。 此信息确认，当 web 应用程序试图建立连接时，它使用的是来自`hosts`文件的 IP，而不是来自 DNS。 在此之前，我们怀疑这是基于`telnet`和`ping`的情况，但没有来自应用程序的证明。

然而，一个有趣的事实是，`netstat`输出显示 TCP 连接处于`SYN_SENT`状态。 这个`SYN_SENT`状态是第一次建立网络连接时使用的状态。 `netstat`命令可以打印多种不同的连接状态; 每一个都告诉我们连接在流程中的哪个位置。 此信息对于确定网络连接问题的根本原因非常关键。

### netstat 状态分解

在深入讨论之前，我们应该快速看一下不同的`netstat`状态及其含义。 以下是`netstat`使用的状态的完整列表:

*   `ESTABLISHED`:连接已建立，可用于数据传输
*   `SYN_SENT`:TCP 套接字正在尝试建立到远程主机的连接
*   `SYN_RECV`:从远端主机收到TCP 连接请求
*   `FIN_WAIT1`:TCP 连接正在关闭
*   `FIN_WAIT2`:TCP正在等待远端主机关闭连接
*   `TIME_WAIT`:套接字在关闭后等待任何未完成的网络数据包
*   `CLOSE`:插座不再使用
*   `CLOSE_WAIT`:对端已关闭连接，本地套接字正在关闭
*   `LAST_ACK`:远端已启动关闭连接，本地系统正在等待最终确认
*   `LISTEN`:套接字正在被用来监听传入的连接
*   `CLOSING`:本端和远端套接字都关闭，但并不是所有的数据都已发送
*   `UNKNOWN`:用于未知状态的插座

从上面的列表中，我们可以确定应用程序到数据库的连接不会成为`ESTABLISHED`。 这意味着应用服务器以`SYN_SENT`状态启动连接，但它永远不会转换到下一个状态。

## 使用 tcpdump 抓取网络流量

为了更好地理解网络流量，我们将使用第二个命令，它允许我们查看网络流量的详细信息——`tcpdump`。 这里，`netstat`命令用来打印 socket 的状态; `tcpdump`命令用于创建“`dumps`”或“`traces`”的网络流量。 这些转储允许用户查看捕获的网络流量的所有方面。

使用`tcpdump`，可以查看完整的 TCP 信息包细节，从信息包头到正在传输的实际数据。 它不仅可以捕获该数据，而且`tcpdump`还可以将捕获的数据写入文件。 将数据写入文件后，可以保存或移动数据，然后使用`tcpdump`命令或其他网络数据包分析工具(如`wireshark`)读取数据。

下面是运行`tcpdump`来捕获网络流量的简单示例。

```sh
[blog]# tcpdump -nvvv
tcpdump: listening on enp0s3, link-type EN10MB (Ethernet), capture size 65535 bytes
16:18:04.125881 IP (tos 0x10, ttl 64, id 20361, offset 0, flags [DF], proto TCP (6), length 156)
 10.0.2.16.ssh > 10.0.2.2.52618: Flags [P.], cksum 0x189f (incorrect -> 0x62a4), seq 3643405490:3643405606, ack 245510335, win 26280, length 116
16:18:04.126203 IP (tos 0x0, ttl 64, id 9942, offset 0, flags [none], proto TCP (6), length 40)
 10.0.2.2.52618 > 10.0.2.16.ssh: Flags [.], cksum 0xbc71 (correct), seq 1, ack 116, win 65535, length 0
16:18:05.128497 IP (tos 0x10, ttl 64, id 20362, offset 0, flags [DF], proto TCP (6), length 332)
 10.0.2.16.ssh > 10.0.2.2.52618: Flags [P.], cksum 0x194f (incorrect -> 0xecc9), seq 116:408, ack 1, win 26280, length 292
16:18:05.128784 IP (tos 0x0, ttl 64, id 9943, offset 0, flags [none], proto TCP (6), length 40)
 10.0.2.2.52618 > 10.0.2.16.ssh: Flags [.], cksum 0xbb4d (correct), seq 1, ack 408, win 65535, length 0
16:18:06.129934 IP (tos 0x10, ttl 64, id 20363, offset 0, flags [DF], proto TCP (6), length 156)
 10.0.2.16.ssh > 10.0.2.2.52618: Flags [P.], cksum 0x189f (incorrect -> 0x41d5), seq 408:524, ack 1, win 26280, length 116
16:18:06.130441 IP (tos 0x0, ttl 64, id 9944, offset 0, flags [none], proto TCP (6), length 40)
 10.0.2.2.52618 > 10.0.2.16.ssh: Flags [.], cksum 0xbad9 (correct), seq 1, ack 524, win 65535, length 0
16:18:07.131131 IP (tos 0x10, ttl 64, id 20364, offset 0, flags [DF], proto TCP (6), length 140)

```

在前面的示例中，我为`tcpdump`命令提供了几个标志。 第一个标志`–n`(没有 dns)告诉`tcpdump`不要查找它找到的任何 ip 的主机名。 其余的标志`–vvv`(详细)告诉`tcpdump`要非常“非常”详细。 `tcpdump`命令有三个冗长的级别; 添加到命令行中的每一个`–v`都会增加所使用的冗长级别。 在前面的示例中，`tcpdump`处于最冗长的模式。

前面的示例是运行`tcpdump`的最简单方法之一; 然而，它并没有捕获我们所需要的流量。

### 查看服务器的网络接口

当在具有多个网络接口的系统上执行`tcpdump`时，除非定义了一个接口，否则命令将选择编号最低的接口来连接。 在上例中，选择的接口为`enp0s3`; 但是，这可能不是用于数据库连接的接口。

在使用`tcpdump`来调查我们的网络连接问题之前，我们首先需要确定用于此连接的网络接口; 为此，我们将使用`ip`命令。

```sh
[blog]# ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
 link/ether 08:00:27:7f:fd:54 brd ff:ff:ff:ff:ff:ff

```

在高层，`ip`命令允许用户打印、修改和添加网络配置。 在上面的示例中，我们告诉`ip`命令使用`show links`参数“显示”所有可用的“链接”。 所显示的链接实际上是为该服务器定义的网络接口。

#### 什么是网络接口?

当谈论物理服务器时，网络接口通常是物理以太网端口的表示。 如果我们假设前面示例中使用的机器是一台物理机器，我们可以假设`enp0s3`和`enp0s8`链路是物理设备。 然而，在现实中，上述机器是一个虚拟机。 这意味着这些设备在逻辑上连接到这个虚拟机; 然而，这台机器的内核不知道，甚至不需要知道区别。

例如，在本书中，除了“`lo`”或环回接口外，大多数接口都直接与物理(或虚拟物理)网络设备相关。 但是，也可以创建虚拟接口，这允许您创建多个接口，这些接口连接回单个物理接口。 通常，这些接口使用“`:`”或“`.`”作为与原始设备名称的分隔符。 如果我们要为`enp0s8`创建一个虚拟接口，它将与`enp0s8:1`类似。

#### 查看设备配置

从`ip`命令的输出中，我们可以看到定义了三个网络接口。 在知道数据库连接使用哪个接口之前，我们首先需要更好地理解这些接口。

```sh
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT

```

`lo`或 loopback 接口是列表中的第一个接口。 任何长期在 Linux 或 Unix 上工作的人都会非常熟悉环回接口。 环回接口被设计为给系统的用户一个本地网络地址，该地址只能用于连接回本地系统。

这个特殊的接口允许位于同一服务器上的应用程序通过 TCP/IP 进行交互，而不必向更广泛的网络公开它们的外部连接。 它还允许这些应用程序在没有网络数据包离开本地服务器的情况下进行交互，从而使其成为一个非常快速的网络连接。

传统上，loopback 接口 IP 称为`127.0.0.1`。 然而，就像本书中的其他内容一样，我们将首先验证这些信息，然后再假设它是真实的。 我们可以使用`ip`命令来显示 loopback 接口定义的地址。

```sh
[blog]# ip addr show lo
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 inet 127.0.0.1/8 scope host lo
 valid_lft forever preferred_lft forever
 inet6 ::1/128 scope host
 valid_lft forever preferred_lft forever

```

在前面显示可用接口的示例中，使用了“`link show`”选项; 为了显示 IP 地址，可以使用“`addr show`”选项。 用于打印项的`ip`命令的语法始终遵循相同的模式。

前面的例子还指定了我们感兴趣的设备的名称; 这将限制输出到指定的设备。 如果我们在前面的命令中省略设备名，它将简单地打印所有设备的 IP 地址。

那么，关于 lo 接口，上面告诉了我们什么? 它告诉我们的一件事是`lo`接口正在监听 IPv4 地址 127.0.0.1; 我们可以在下面一行看到。

```sh
 inet 127.0.0.1/8 scope host lo

```

这意味着，如果我们想通过环回接口连接到这个主机，我们可以通过目标`127.0.0.1`来实现。 然而，`ip`命令还显示了在该接口上定义的第二个 IP。

```sh
 inet6 ::1/128 scope host

```

这说明`::1`的 IPv6 地址也绑定到了 lo 接口上。 该地址与`127.0.0.1`的目的相同，但它是为`IPv6`通信而设计的。

根据以上来自`ip`命令的信息，我们可以看到`lo`或环回接口是按照预期定义的。

该服务器上定义的第二个接口是`enp0s3`; 与 lo 不同的是，这个设备要么是一个物理设备，要么是一个虚拟的物理接口。 前面执行的`ip`link show 命令已经告诉了我们关于这个接口的很多信息。

```sh
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff

```

从前面的代码片段中，我们可以确定以下内容:

*   设备处于**up**状态:`state UP`
*   MTU 大小为**1500**:`mtu 1500`
*   MAC 地址为**08:00:27:20:5d:4b**:`link/ether 08:00:27:20:5d:4b`

从这些信息中，我们知道接口已经启动并能够被利用。 我们还知道 MTU 大小被设置为默认值 1500，我们可以很容易地识别 MAC 地址。 虽然 MTU 大小和 MAC 地址可能与这个问题不是特别相关，但它们在其他情况下可能非常有用。

但是，对于当前标识用于数据库连接的接口的任务，我们需要标识哪些 ip 绑定到该接口。

```sh
[blog]# ip addr show enp0s3
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
 inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3
 valid_lft 49655sec preferred_lft 49655sec
 inet6 fe80::a00:27ff:fe20:5d4b/64 scope link
 valid_lft forever preferred_lft forever

```

从上面的输出可以看出，`enp0s3`接口既在收听`10.0.2.15`(`inet 10.0.2.15/24`)的 IPv4 IP，也在收听`f380::a00:27ff:fe20:5d4b`(`inet6 fe80::a00:27ff:fe20:5d4b/64`)的 IPv6 IP。 这是否告诉我们到`192.168.33.12`的连接要经过这个接口? 不，但这也不意味着他们不知道。

这告诉我们的是，`enp0s3`接口用于连接到`10.0.2.15/24`网络。 该网络可能无法路由到`192.168.33.12`的地址; 在做出这个决定之前，我们应该首先检查下一个接口的配置。

本系统的第三个接口是`enp0s8`; 它也是一个物理的或虚拟的网络设备，从`ip`link show 命令提供的信息可以看出，它具有与`enp0s3`相似的配置。

```sh
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
 link/ether 08:00:27:7f:fd:54 brd ff:ff:ff:ff:ff:ff

```

从这个输出中，我们可以看到`enp0s8`接口也处于“`UP`”状态，并且默认 MTU 为 1500。 我们还可以确定这个接口的 MAC 地址，这在此时不是特别需要; 然而，它以后可能会变得有用。

但是，如果我们看一下在这个服务器上定义的 ip，就会发现它与`enp0s3`设备上定义的 ip 有很大的不同。

```sh
[blog]# ip addr show enp0s8
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:7f:fd:54 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.11/24 brd 192.168.33.255 scope global enp0s8
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:fe7f:fd54/64 scope link
 valid_lft forever preferred_lft forever

```

可以看到`enp0s8`接口正在监听`192.168.33.11`(`inet 192.168.33.11/24`)的 IPv4 地址和`fe80::a00:27ff:fe7f:fd54`(`inet6 fe80::a00:27ff:fe7f:fd54/64`)的 IPv6 地址。

这是否意味着`enp0s8`接口用于连接`192.168.33.12`? 嗯，事实上，可能是这样。

`enp0s8`定义的子网为`192.168.33.11/24`，即该接口连接到 IP 范围为`192.168.33.0`到`192.168.33.255`的设备网络。 由于数据库服务器的`IP 192.168.33.12`在这个范围内，因此很有可能通过`enp0s8`接口与此地址通信。

此时，我们可以“怀疑”`enp0s8`的接口用于与数据库服务器的通信。 虽然可以将此接口配置为与包含`192.168.33.12`的子网通信，但完全可以通过使用定义的路由强制通过另一个接口进行通信。

为了检查是否定义了路由并强制通过另一个接口进行通信，我们将再次使用`ip`命令。 然而，对于这个任务，我们将为`ip`命令使用“`route get`”选项。

```sh
[blog]# ip route get 192.168.33.12
192.168.33.12 dev enp0s8  src 192.168.33.11
 cache

```

当使用“`route get`”参数执行时，`ip`命令将具体输出用于路由到指定 IP 的接口。

从前面的输出，我们可以看到，`blog.example.com`服务器实际上是使用`enp0s8`接口路由到 192.168.33.12 地址，即`db.example.com`的 IP。

此时，我们不仅使用了`ip`命令来确定此服务器上存在哪些网络接口，而且还使用了它来确定网络包将使用哪个接口来到达目标主机。

`ip`命令是一个非常有用的工具，最近已被指定用来取代`ifconfig`和`route`等较旧的命令。 如果您通常熟悉使用`ifconfig`之类的命令，但不熟悉`ip`命令，那么最好检查一下上面介绍的用法，因为最终`ifconfig`命令将被弃用。

### 指定 tcpdump 的接口

现在我们已经确定了用于与`db.example.com`通信的接口，我们可以使用`tcpdump`开始我们的网络跟踪。 如前所述，我们将使用-`nvvv`标志将`tcpdump`设置为非常“非常”详细模式，而不进行主机名解析。 然而，这一次我们将指定`tcpdump`从`enp0s8`接口捕获网络流量; 我们可以使用`-i`(interface)标志来实现这一点。 我们还将使用`-w`(write)标志将捕获的数据写入文件。

```sh
[blog]# tcpdump -nvvv -i enp0s8 -w /var/tmp/chapter5.pcap
tcpdump: listening on enp0s8, link-type EN10MB (Ethernet), capture size 65535 bytes
48 packets captured

```

当我们第一次执行`tcpdump`命令时，我们在屏幕上收到了相当多的输出。 当被告知将其输出保存到一个文件时，`tcpdump`将不会将捕获的数据输出到屏幕上，而是连续显示一个捕获数据包的计数器。

一旦我们将`tcpdump`捕获的数据保存到文件中，我们需要复制该问题以尝试生成数据库流量。 我们将使用与使用`netstat`命令相同的方法:在 web 浏览器中简单地导航到`blog.example.com`。

当我们导航到 WordPress 站点时，我们应该看到`packets captured`计数器增加; 这表示`tcpdump`已经看到流量并捕获了它。 一旦计数器达到一个合理的数字，我们可以停止`tcpdump`捕获。 为此，只需在命令行上按下*Ctrl*+*C*; 一旦停止，我们应该会看到类似如下的消息:

```sh
^C48 packets captured
48 packets received by filter
0 packets dropped by kernel

```

### 读取捕获数据

现在我们已经将捕获`network trace`保存到一个文件中，我们可以使用这个文件来调查数据库流量。 将这些数据保存在文件中的好处是，我们可以多次读取这些数据，并通过过滤器迭代来减少输出。 此外，当针对实时网络流运行`tcpdump`时，我们可能只捕获一次流量，但不会再次捕获。

为了读取保存的数据，可以运行带有`–r`(read)标志的`tcpdump`，后面跟着要读取的文件名。

我们可以使用以下命令来打印我们捕获的所有`48`数据包的包头信息。

```sh
[blog]# tcpdump -nvvv -r /var/tmp/chapter5.pcap

```

然而，这个命令的输出可能相当庞大; 为了抓住问题的核心，我们需要缩小`tcpdump`的输出范围。 为此，我们将使用 tcpdump 的能力来对捕获的数据应用过滤器。 特别地，我们将使用“`host`”过滤器将输出过滤到特定的 IP 地址。

```sh
[blog]# tcpdump -nvvv -r /var/tmp/chapter5.pcap host 192.168.33.12
reading from file /var/tmp/chapter5.pcap, link-type EN10MB (Ethernet)
03:33:05.569739 IP (tos 0x0, ttl 64, id 26591, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x3543), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53696341 ecr 0,nop,wscale 6], length 0
03:33:06.573145 IP (tos 0x0, ttl 64, id 26592, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x3157), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53697345 ecr 0,nop,wscale 6], length 0
03:33:08.580122 IP (tos 0x0, ttl 64, id 26593, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x2980), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53699352 ecr 0,nop,wscale 6], length 0

```

通过在`tcpdump`命令后面加上`host 192.168.33.12`，过滤出的流量只与主机 192.168.33.12 相关。 这是通过`host`过滤器实现的。 `tcpdump`命令有许多可用的过滤器; 然而，在本章中，我们将主要使用主机过滤器。 我强烈建议定期对网络问题进行故障排除的人熟悉`tcpdump`过滤器。

当运行`tcpdump`(以相同的方式)时，必须知道每一行都是通过指定接口发送或接收的数据包。 下面的示例是一条完整的`tcpdump`线，它本质上是通过`enp0s8`接口的一个包。

```sh
03:33:05.569739 IP (tos 0x0, ttl 64, id 26591, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x3543), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53696341 ecr 0,nop,wscale 6], length 0

```

如果我们看一下前面的行，我们可以看到这个包正在从`192.168.33.11`发送到`192.168.33.12`。 我们可以从以下部分看到这一点:

```sh
192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S]

```

事实上，在整行之外，上面的代码片段中的细节是我们开始理解这个问题所需要的一切。 我们可以从前面的片段中识别出这个特定的数据包是从`192.168.33.11`发送到`192.168.33.12`的。 我们可以通过这个代码片段中的第一个和第二个 ip 来识别它。 因为`192.168.33.11`是第一个 IP，所以它是数据包的来源，然后第二个 IP(`192.168.33.12`)就是目的地。

```sh
192.168.33.11.37785 > 192.168.33.12.mysql

```

我们还可以从这个片段中看到，`192.168.33.11`的连接是从本地端口`37785`到远程端口`3306`。 我们可以推断这是因为源地址中的第五个点是`37785`，而“`mysql`”在目标地址中。 `tcpdump`打印“`mysql`”的原因是，默认情况下，它将公共服务端口映射到它们的公共名称。 在本例中，它将端口`3306`映射到`mysql`并简单地打印`mysql`。 可以在命令行中通过使用`tcpdump`命令的两个`–n`标志(即`-nn`)来关闭此功能。

本节告诉我们的第三项重要内容是正在发送的包是一个`SYN`包。 我们可以通过代码片段的`Flags [S]`部分来识别这一点。 `tcpdump`输出中的每一行都有一个`flags`段。 当在报文上设置的标志仅为`S`时，这意味着该报文是初始的`SYN`报文。

这个包是一个`SYN`包这一事实实际上告诉了我们很多关于这个包的信息。

### TCP 快速入门

**传输控制协议**(**TCP**)是最常用的基于 internet 的通信协议之一。 它是我们每天依赖的许多服务所选择的协议。 从用于加载网页的 HTTP 协议到所有 Linux 系统管理员最喜欢的`SSH`，这些协议都是在 TCP 协议之上实现的。

虽然 TCP 被广泛使用，但它也是一个相当高级的主题，每个系统管理员至少应该对这个主题有一个基本的了解。 在本节中，我们将快速介绍一些 TCP 基础知识; 这决不是一个广泛的指南，但只是足够了解我们的问题的根源。

要理解我们的问题，我们必须首先了解 TCP 连接是如何建立的。 对于 TCP 通信，通常有两个重要的方面，即客户机和服务器。 客户端是连接的发起者，将发送一个`SYN`包作为建立 TCP 连接的第一步。

当服务器接收到一个`SYN`报文并愿意接受连接时，它将发送一个**Synchronize Acknowledgement**(**SYN-ACK**)报文返回给客户端。 这是为了让服务器确认它已经收到了原始的`SYN`数据包。

当客户端接收到这个`SYN-ACK`报文时，它就用`ACK`(有时也称为`SYN-ACK-ACK`)响应服务器。 这个包背后的思想是让客户机确认它已经收到了服务器的确认。

这个过程被称为*三次握手*，是 TCP 的基础。 这种方法的好处在于，由于每个系统都承认它接收到的数据包，因此不存在客户机和服务器是否能够来回通信的问题。 一旦执行了三次握手，连接将移动到建立状态。 这是可以使用其他类型的包的地方，例如**Push**(**PSH**)包，用于将信息从客户机传输到服务器，反之亦然。

#### TCP 报文类型

谈到额外的类型的信息包，重要的是要知道，定义一个信息包是`SYN`信息包还是`ACK`信息包的组件只是在信息包头中设置的一个标志。

在我们捕获数据的第一个包上，只有`SYN`标志被设置; 这就是为什么我们会看到像`Flags [S]`这样的输出。 这是一个发送的第一个包的例子，该包只设置了`SYN`标志。

`SYN-ACK`报文是设置了`SYN`和`ACK`标志的报文。 这通常被看作是`tcpdump`中的`[S.]`。

下表是在使用`tcpdump`进行故障排除活动期间常见的包标志。 这绝不是一个完整的列表，但它确实给出了常见包类型的一般概念。

*   `SYN- [S]`:同步报文，客户端发送给服务器的第一个报文。
*   `SYN-ACK- [S.]`:同步确认报文; 这些包标志用于指示服务器接收到客户端的`SYN`请求。
*   `ACK- [.]`:服务器和客户端都使用确认报文来确认收到的报文。 在初始的`SYN`报文发送后，所有后续的报文都应该设置确认标志。
*   `PSH- [P]`:这是推送报文。 将缓冲后的网络数据推送到接收端。 这是实际传输数据的数据包类型。
*   `PSH-ACK- [P.]`:推送确认报文用于确认之前的报文，同时向接收方发送数据。
*   `FIN- [F]`:`FIN`或 Finish 数据包用来告诉服务器没有更多的数据，可以关闭已建立的连接。
*   `FIN-ACK- [F.]`:完成确认报文用于确认上一个完成报文已经收到。
*   `RST- [R]`:当源系统希望复位连接时，使用Reset 报文。 通常，这是由于错误或目标端口实际上没有处于侦听状态。
*   `RST-ACK -[R.]`:复位确认报文用于确认收到上一个复位报文。

现在我们已经研究了不同类型的包，让我们将它们结合在一起，快速回顾一下前面捕获的数据。

```sh
[blog]# tcpdump -nvvv -r /var/tmp/chapter5.pcap host 192.168.33.12
reading from file /var/tmp/chapter5.pcap, link-type EN10MB (Ethernet)
03:33:05.569739 IP (tos 0x0, ttl 64, id 26591, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x3543), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53696341 ecr 0,nop,wscale 6], length 0
03:33:06.573145 IP (tos 0x0, ttl 64, id 26592, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x3157), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53697345 ecr 0,nop,wscale 6], length 0
03:33:08.580122 IP (tos 0x0, ttl 64, id 26593, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S], cksum 0xc396 (incorrect -> 0x2980), seq 3937874058, win 14600, options [mss 1460,sackOK,TS val 53699352 ecr 0,nop,wscale 6], length 0
If we look at just the IP addresses and the flags from the captured data, from each line, it becomes very clear what the issue is.
192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S],
192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S],
192.168.33.11.37785 > 192.168.33.12.mysql: Flags [S],

```

如果我们分解这三个数据包，可以看到这三个数据包都来自`37785`的源端口，目标端口是 3306。 我们也可以看到这些数据包是`SYN`数据包。 这意味着我们的系统发送了 3 个`SYN`数据包，但从未从目的地(本例中为`192.168.33.12`)接收到一个`SYN-ACK`数据包。

关于到主机`192.168.33.12`的网络连接，这告诉我们什么? 它告诉我们，要么远程服务器`192.168.33.12`从未接收到我们的数据包，要么它正在接收数据包，而我们永远无法接收`SYN-ACK`的回复。 如果问题是由于数据库服务器不接受我们的数据包造成的，我们将期望看到一个`RST`或`Reset`数据包。

## 收集数据的评审

在这一点上，这是一个很好的时机来盘点我们已经收集的信息和我们目前所知道的信息。

我们确定的第一个关键信息是博客服务器(`blog.example.com`)无法连接到数据库服务器(`db.example.com`)。 我们识别的第二个关键信息是 DNS 名称`db.example.com`解析为`10.0.0.50`。 然而，在`blog.example.com`服务器上还有一个覆盖 DNS 的`/etc/hosts`文件条目。 由于 hosts 文件的原因，当 web 应用程序试图连接`db.example.com`时，它正在连接`192.168.33.12`。

我们还发现主机`192.168.33.11`(`blog.example.com`)在访问 WordPress 应用程序时向`192.168.33.12`发送初始的`SYN`数据包。 但是，服务器`192.168.33.12`要么没有接收，要么没有应答这些数据包。

在整个调查过程中，我们检查了博客服务器的网络配置，并确定其设置正确。 我们可以通过简单地使用 ping 命令向每个网络接口的子网内的一个 IP 发送 ICMP 回显来执行额外的验证。

```sh
[blog]# ip addr show enp0s3
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
 inet 10.0.2.16/24 brd 10.0.2.255 scope global dynamic enp0s3
 valid_lft 62208sec preferred_lft 62208sec
 inet6 fe80::a00:27ff:fe20:5d4b/64 scope link
 valid_lft forever preferred_lft forever

```

对于`enp0s3`接口，可以看到绑定的 IP 地址为`10.0.2.16`，子网为`/24`或`255.255.255.0`。 通过这个设置，我们应该能够与这个子网中的另一个 IP 进行通信。 下面是使用 ping 命令测试到`10.0.2.2`的连通性的结果。

```sh
[blog]# ping 10.0.2.2
PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.
64 bytes from 10.0.2.2: icmp_seq=1 ttl=63 time=0.250 ms
64 bytes from 10.0.2.2: icmp_seq=2 ttl=63 time=0.196 ms
64 bytes from 10.0.2.2: icmp_seq=3 ttl=63 time=0.197 ms
^C
--- 10.0.2.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 0.196/0.214/0.250/0.027 ms

```

这表明`enp0s3`接口至少可以连接到其子网内的其他 ip。 使用`enp0s8`，我们可以在另一个 IP 上执行相同的测试。

```sh
[blog]# ip addr show enp0s8
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:7f:fd:54 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.11/24 brd 192.168.33.255 scope global enp0s8
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:fe7f:fd54/64 scope link
 valid_lft forever preferred_lft forever

```

从前面的命令中，我们可以看到`enp0s8`将 IP`192.168.33.11`与一个子网`/24`或`255.255.255.0`绑定在一起。 如果我们可以使用 ping 命令与`192.168.33.11/24`子网中的任何其他 IP 通信，那么我们就可以验证这个接口是否也配置正确。

```sh
# ping 192.168.33.1
PING 192.168.33.1 (192.168.33.1) 56(84) bytes of data.
64 bytes from 192.168.33.1: icmp_seq=1 ttl=64 time=0.287 ms
64 bytes from 192.168.33.1: icmp_seq=2 ttl=64 time=0.249 ms
64 bytes from 192.168.33.1: icmp_seq=3 ttl=64 time=0.260 ms
64 bytes from 192.168.33.1: icmp_seq=4 ttl=64 time=0.192 ms
^C
--- 192.168.33.1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3028ms
rtt min/avg/max/mdev = 0.192/0.247/0.287/0.034 ms

```

从结果中，我们可以看到到 IP`192.168.33.1`的连接正按预期工作。 因此，这意味着，至少在基本方式上，`enp0s8`接口配置正确。

有了所有这些信息，我们可以假设`blog.example.com`服务器配置正确，可以连接到为其配置的网络。 从这一点开始，如果我们想要关于我们的问题的更多信息，我们将需要从`db.example.com`(`192.168.33.12`)服务器获取它。

## 看看另一边

虽然这不总是可能的，但在处理网络问题时，最好从对话双方进行故障排除。 在前面的示例中，我们使用两个系统组成网络对话，即客户机和服务器。 到目前为止，我们从客户的角度来看一切; 在本节中，我们将从服务器的角度看一下这个对话的另一面。

### 识别网络配置

在上一节中，我们在查看博客服务器的网络配置之前经历了几个步骤。 在数据库服务器的情况下，我们已经知道问题与网络有关，特别是与`192.168.33.12`的 IP 有关。 因为我们已经知道问题与哪个 IP 相关，所以我们应该做的第一件事是确定这个 IP 绑定到哪个接口。

同样，我们将使用带有`addr show`选项的`ip`命令来完成此操作。

```sh
[db]# ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 inet 127.0.0.1/8 scope host lo
 valid_lft forever preferred_lft forever
 inet6 ::1/128 scope host
 valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
 inet 10.0.2.16/24 brd 10.0.2.255 scope global dynamic enp0s3
 valid_lft 86304sec preferred_lft 86304sec
 inet6 fe80::a00:27ff:fe20:5d4b/64 scope link
 valid_lft forever preferred_lft forever
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:c9:d3:65 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.12/24 brd 192.168.33.255 scope global enp0s8
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:fec9:d365/64 scope link
 valid_lft forever preferred_lft forever

```

在前面的示例中，我们使用了`addr show`选项来显示与单个接口关联的 ip。 但是，这一次通过省略接口名称，`ip`命令显示所有的 ip 和这些 ip 绑定的接口。 这是显示与此服务器相关的 IP 地址和接口的一种快速而简单的方法。

我们可以从前面的命令中看到，数据库服务器具有与应用服务器类似的配置，因为它有三个接口。 在深入讨论之前，让我们更好地了解服务器的接口，并看看可以从中识别哪些信息。

```sh
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 inet 127.0.0.1/8 scope host lo
 valid_lft forever preferred_lft forever
 inet6 ::1/128 scope host
 valid_lft forever preferred_lft forever

```

该服务器上的第一个接口是环回接口`lo`。 如前所述，这个接口对每个服务器都是通用的，并且只用于本地网络流量。 这个接口不太可能与我们的问题相关。

```sh
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
 inet 10.0.2.16/24 brd 10.0.2.255 scope global dynamic enp0s3
 valid_lft 86304sec preferred_lft 86304sec
 inet6 fe80::a00:27ff:fe20:5d4b/64 scope link
 valid_lft forever preferred_lft forever

```

似乎对于第二个接口`enp0s3`，数据库服务器的配置与博客服务器的配置非常相似。 在 web 应用服务器上，我们也有一个名为`enp0s3`的接口，这个接口也在`10.0.2.0/24`网络上。

自博客和数据库服务器之间的连接似乎是针对 IP`192.168.33.12`,`enp0s3`似乎不是一个接口关注`enp0s3`界面`10.0.2.16`IP 绑定。

```sh
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:c9:d3:65 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.12/24 brd 192.168.33.255 scope global enp0s8
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:fec9:d365/64 scope link
 valid_lft forever preferred_lft forever

```

另一方面，第三个网络设备`enp0s8`确实绑定了 IP`192.168.33.12`。 `enp0s8`设备的设置也类似于博客服务器上的`enp0s8`设备，因为这两个设备似乎都在`192.168.33.0/24`网络上。

从前面的故障排除中，我们知道我们的 web 应用程序的目标 IP 是 IP 192.168.33.12。 通过`ip`命令，我们已经确认 192.168.33.12 通过`enp0s8`接口绑定到此服务器。

### 测试 db.example.com 的连通性

现在我们知道了数据库服务器具有预期的网络配置，我们需要确定该服务器是否正确地连接到`192.168.33.0/24`网络。 最简单的方法是执行我们之前在博客服务器上执行的任务; 使用`ping`连接到该子网上的另一个 IP。

```sh
[db]# ping 192.168.33.1
PING 192.168.33.1 (192.168.33.1) 56(84) bytes of data.
64 bytes from 192.168.33.1: icmp_seq=1 ttl=64 time=0.438 ms
64 bytes from 192.168.33.1: icmp_seq=2 ttl=64 time=0.208 ms
64 bytes from 192.168.33.1: icmp_seq=3 ttl=64 time=0.209 ms
^C
--- 192.168.33.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 0.208/0.285/0.438/0.108 ms

```

通过上面的输出，我们可以看到数据库服务器能够联系`192.168.33.0/24`子网上的另一个 IP。 在前面进行故障排除时，我们试图从博客服务器连接到数据库服务器，但测试失败。 一个有趣的测试是，当数据库服务器发起到博客服务器的连接时，验证反过来的连接失败。

```sh
[db]# ping 192.168.33.11
PING 192.168.33.11 (192.168.33.11) 56(84) bytes of data.
From 10.0.2.16 icmp_seq=1 Destination Host Unreachable
From 10.0.2.16 icmp_seq=2 Destination Host Unreachable
From 10.0.2.16 icmp_seq=3 Destination Host Unreachable
From 10.0.2.16 icmp_seq=4 Destination Host Unreachable
^C
--- 192.168.33.11 ping statistics ---
6 packets transmitted, 0 received, +4 errors, 100% packet loss, time 5005ms

```

当运行从数据库服务器到博客服务器的 IP(`192.168.33.11`)的`ping`命令时，我们可以看到 ping 的应答为**Destination Host Unreachable**。 这与我们在尝试从博客服务器连接时看到的错误相同。

正如前面提到的，除了网络连接问题之外，还有许多原因导致 ping 失败; 为了确保存在连接问题，我们还应该使用`telnet`测试连接。 我们知道博客服务器正在接受到 web 服务器的连接，所以一个到 web 服务器端口的简单`telnet`就可以明确地告诉我们是否有数据库服务器到 web 服务器的连接。

在运行`telnet`时，需要指定要连接的端口。 我们知道 web 服务器正在运行，当我们导航到`http://blog.example.com`时，我们会得到一个 web 页面。 根据这些信息，我们可以确定使用了默认 HTTP 端口并正在侦听。 有了这些信息，我们还知道可以简单地使用 telnet 连接到端口`80`，即`HTTP`通信的默认端口。

```sh
[db]# telnet 192.168.33.11 80
-bash: telnet: command not found

```

但是，在这个服务器上，没有安装`telnet`。 这是，因为我们可以像在前面的例子中那样使用`curl`命令。

```sh
[db]# curl telnet://192.168.33.11:80 -v
* About to connect() to 192.168.33.11 port 80 (#0)
*   Trying 192.168.33.11...
* No route to host
* Failed connect to 192.168.33.11:80; No route to host
* Closing connection 0
curl: (7) Failed connect to 192.168.33.11:80; No route to host

```

从`curl`命令的输出中，我们可以看到，无论是博客还是数据库服务器发起连接，通信问题都存在。

### 正在寻找与 netstat 的连接

在上一节中，当从博客服务器进行故障排除时，我们使用`netstat`查看到数据库服务器的打开的 TCP 连接。 现在我们已经登录到数据库服务器，我们可以使用相同的命令从数据库服务器的角度查看连接的状态。 为此，我们将运行指定间隔的`netstat`; 这将导致`netstat`每隔 5 秒打印一次网络连接统计信息，类似于`vmstat`或`top`命令。

在运行`netstat`命令时，我们只需刷新浏览器，使 WordPress 应用程序再次尝试数据库连接。

```sh
[db]# netstat -na 5 | grep 192.168.33.11

```

在我称之为`continuous mode`的地方运行`netstat`并使用`grep`过滤博客服务器的 IP(192.168.33.11)之后，我们没有看到任何 TCP 连接或连接尝试。

在许多情况下，这似乎表明数据库服务器从未收到来自博客服务器的 TCP 数据包。 我们可以通过使用`tcpdump`命令来捕获`enp0s8`接口上的所有网络流量来确认是否存在这种情况。

### 使用 tcpdump 跟踪网络连接

在前面学习关于`tcpdump`的时候，我们了解到它默认使用最小数量的接口。 这意味着，为了捕获连接尝试，我们必须使用`-i`(接口)标志来跟踪正确的接口`enp0s8`。 除了告诉`tcpdump`监视`enp0s8`接口之外，我们还将让`tcpdump`将其输出写入一个文件。 我们将这样做，以便能够捕获尽可能多的数据，然后使用`tcpdump`命令尽可能多地分析数据。

```sh
[db]# tcpdump -i enp0s8 -w /var/tmp/db-capture.pcap
tcpdump: listening on enp0s8, link-type EN10MB (Ethernet), capture size 65535 bytes

```

现在`tcpdump`正在运行，我们只需要再次刷新浏览器。

```sh
^C110 packets captured
110 packets received by filter
0 packets dropped by kernel

```

刷新浏览器后，看到`packets captured`计数器增加，可以通过按键盘上的*Ctrl*+*C*停止`tcpdump`。

一旦`tcpdump`停止，我们就可以使用`–r`(read)标志读取捕获的数据; 然而，这将打印`tcpdump`捕获的所有数据包。 在某些环境中，这可能是相当多的数据。 因此，为了精简输出，只输出有用的数据，我们将使用`port`过滤器告诉`tcpdump`只输出从端口 3306(默认的 MySQL 端口)发起或目标端口 3306 发起的捕获流量。

我们可以通过将`port 3306`添加到`tcpdump`命令的末尾来实现这一点。

```sh
[db]# tcpdump -nnvvv -r /var/tmp/db-capture.pcap port 3306
reading from file /var/tmp/db-capture.pcap, link-type EN10MB (Ethernet)
03:11:03.697543 IP (tos 0x10, ttl 64, id 43196, offset 0, flags [DF], proto TCP (6), length 64)
 192.168.33.1.59510 > 192.168.33.12.3306: Flags [S], cksum 0xc125 (correct), seq 2335155468, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 1314733695 ecr 0,sackOK,eol], length 0
03:11:03.697576 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.12.3306 > 192.168.33.1.59510: Flags [S.], cksum 0xc38c (incorrect -> 0x5d87), seq 2658328059, ack 2335155469, win 14480, options [mss 1460,sackOK,TS val 1884022 ecr 1314733695,nop,wscale 6], length 0
03:11:03.697712 IP (tos 0x10, ttl 64, id 61120, offset 0, flags [DF], proto TCP (6), length 52)
 192.168.33.1.59510 > 192.168.33.12.3306: Flags [.], cksum 0xb4cd (correct), seq 1, ack 1, win 4117, options [nop,nop,TS val 1314733695 ecr 1884022], length 0
03:11:03.712018 IP (tos 0x8, ttl 64, id 25226, offset 0, flags [DF], proto TCP (6), length 127)

```

然而，在使用前面的过滤器时，这个数据库服务器似乎不仅仅被 WordPress 应用程序使用。 从`tcpdump`输出中，我们可以看到`3306`端口上的流量比博客服务器还要多。

为了进一步清理这个输出，我们可以将主机过滤器添加到`tcpdump`命令中，只过滤我们感兴趣的流量:来自主机`192.168.33.11`的流量。

```sh
[db]# tcpdump -nnvvv -r /var/tmp/db-capture.pcap port 3306 and host 192.168.33.11
reading from file /var/tmp/db-capture.pcap, link-type EN10MB (Ethernet)
04:04:09.167121 IP (tos 0x0, ttl 64, id 60173, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x4111 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9320053 ecr 0,nop,wscale 6], length 0
04:04:10.171104 IP (tos 0x0, ttl 64, id 60174, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x3d26 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9321056 ecr 0,nop,wscale 6], length 0
04:04:12.175107 IP (tos 0x0, ttl 64, id 60175, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x3552 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9323060 ecr 0,nop,wscale 6], length 0
04:04:16.187731 IP (tos 0x0, ttl 64, id 60176, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x25a5 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9327073 ecr 0,nop,wscale 6], length 0

```

在这里，我们使用“`and`”操作符告诉`tcpdump`只打印到/从端口`3306`和到/从主机`192.168.33.11`的流量。

`tcpdump`命令有许多可能的过滤器和操作符; 但是，在所有这些方法中，我建议熟悉基于端口和主机的过滤，因为这些方法在大多数情况下已经足够了。

如果我们分解前面捕获的网络跟踪，我们可以看到一些有趣的信息; 为了让它更容易被发现，让我们将输出缩小，只显示所使用的 ip 和标志。

```sh
04:04:09.167121 IP
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S],
04:04:10.171104 IP
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S],
04:04:12.175107 IP
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S],
04:04:16.187731 IP
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S],

```

从这个信息中，我们可以看到从`blog.example.com`(`192.168.33.11`)发送的`SYN`包在`db.example.com`(`192.168.33.12`)到达。 然而，我们没有看到的是返回的`SYN-ACKS`。

这告诉我们，我们至少找到了网络问题的根源; 服务器`db.example.com`没有正确地回复从博客服务器收到的数据包。

现在的问题是:什么会导致这种类型的问题? 发生这个问题的原因有很多; 然而，这种问题通常是由于网络配置设置中的错误配置造成的。 根据我们收集到的信息，我们可以假设数据库服务器只是配置错误。

然而，有几种方法会导致这种配置错误的问题。 为了识别可能的错误配置，我们可以使用`tcpdump`命令来捕获该服务器上的所有网络流量。

在前面的`tcpdump`示例中，我们总是指定一个要监视的接口。 在大多数情况下，这对于问题是合适的，因为它减少了`tcpdump`所捕获的数据量。 在非常活跃的服务器上，几分钟的`tcpdump`数据可能非常大，所以最好将数据减少到只需要的程度。

然而，在某些情况下，比如这个问题，让`tcpdump`从所有接口捕获网络流量是有用的。 为此，我们只需指定`any`作为要监视的接口。

```sh
[db]# tcpdump -i any -w /var/tmp/alltraffic.pcap
tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes

```

现在我们有了`tcpdump`捕获并保存所有接口上的所有流量，我们将需要再次刷新浏览器，以迫使 WordPress 应用程序尝试数据库连接。

```sh
^C440 packets captured
443 packets received by filter
0 packets dropped by kernel

```

经过几次尝试后，我们可以通过按*Ctrl*+*C*再次停止`tcpdump`。 将捕获的网络数据保存到一个文件后，我们可以开始研究这些连接尝试发生了什么。

由于`tcpdump`捕获了大量的数据包，我们将再次使用`host`过滤器来限制`192.168.33.11`进出的网络流量的结果。

```sh
[db]# tcpdump -nnvvv -r /var/tmp/alltraffic.pcap host 192.168.33.11
reading from file /var/tmp/alltraffic.pcap, link-type LINUX_SLL (Linux cooked)
15:37:51.616621 IP (tos 0x0, ttl 64, id 8389, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S], cksum 0x34dd (correct), seq 4225047048, win 14600, options [mss 1460,sackOK,TS val 3357389 ecr 0,nop,wscale 6], length 0
15:37:51.616665 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.], cksum 0xc396 (incorrect -> 0x3609), seq 1637731271, ack 4225047049, win 14480, options [mss 1460,sackOK,TS val 3330467 ecr 3357389,nop,wscale 6], length 0
15:37:51.616891 IP (tos 0x0, ttl 255, id 2947, offset 0, flags [none], proto TCP (6), length 40)
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [R], cksum 0x10c4 (correct), seq 4225047049, win 0, length 0
15:37:52.619386 IP (tos 0x0, ttl 64, id 8390, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S], cksum 0x30f2 (correct), seq 4225047048, win 14600, options [mss 1460,sackOK,TS val 3358392 ecr 0,nop,wscale 6], length 0
15:37:52.619428 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.], cksum 0xc396 (incorrect -> 0x1987), seq 1653399428, ack 4225047049, win 14480, options [mss 1460,sackOK,TS val 3331470 ecr 3358392,nop,wscale 6], length 0
15:37:52.619600 IP (tos 0x0, ttl 255, id 2948, offset 0, flags [none], proto TCP (6), length 40)
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [R], cksum 0x10c4 (correct), seq 4225047049, win 0, length 0

```

通过捕获的数据，我们似乎找到了预期的`SYN-ACK`。 为了以更清晰的方式显示这一点，让我们将输出缩减为只使用 ip 和标志。

```sh
15:37:51.616621 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S],
15:37:51.616665 IP
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.],
15:37:51.616891 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [R],
15:37:52.619386 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S],
15:37:52.619428 IP
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.],
15:37:52.619600 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [R],

```

有了更清晰的图像，我们可以看到正在传输的一系列有趣的网络数据包。

```sh
15:37:51.616621 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S],

```

第一个包是端口`3306`上从`192.168.33.11`到`192.168.33.12`的`SYN`包。 这与我们在前面的`tcpdump`执行中捕获的数据包类型相同。

```sh
15:37:51.616665 IP
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.],

```

然而，我们之前没有见过第二个包。 在第二个包中，我们看到它是一个`SYN-ACK`(由`Flags [S.]`标识)。 `SYN-ACK`正在从端口`3306`上的`192.168.33.12`发送到端口`47339`上的`192.168.33.11`(发送原始`SYN`报文的端口)。

乍一看，这似乎是正常的`SYN`和`SYN-ACK`握手。

```sh
15:37:51.616891 IP
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [R],

```

然而，第三个包很有趣，因为它清楚地表明存在问题。 第三个包是博客服务器`192.168.33.11`发送的`RESET`包(用`Flags [R]`标识)。 有趣的是，在博客服务器上执行`tcpdump`时，我们从未捕获`RESET`数据包。 如果我们在博客服务器上再次执行`tcpdump`，我们可以再次看到这一点。

```sh
[blog]# tcpdump -i any port 3306
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes
15:24:25.646731 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2551514 ecr 0,nop,wscale 6], length 0
15:24:26.648706 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2552516 ecr 0,nop,wscale 6], length 0
15:24:28.652763 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2554520 ecr 0,nop,wscale 6], length 0
15:24:32.660123 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2558528 ecr 0,nop,wscale 6], length 0
15:24:40.676112 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2566544 ecr 0,nop,wscale 6], length 0
15:24:56.724102 IP blog.example.com.47336 > db.example.com.mysql: Flags [S], seq 3286710391, win 14600, options [mss 1460,sackOK,TS val 2582592 ecr 0,nop,wscale 6], length 0

```

从前面的`tcpdump`输出中，我们看不到博客服务器上的`SYN-ACK`或`RESET`数据包。 这意味着`RESET`正在由另一个系统发送，或者`SYN-ACK`包在`tcpdump`捕获之前被博客服务器的内核拒绝。

当`tcpdump`命令捕获网络流量时，它将在内核处理完这些网络流量后执行。 这意味着，如果由于任何原因，内核拒绝了数据包，它将不会通过`tcpdump`命令被看到。 因此，可能是博客服务器的内核在`tcpdump`能够捕获来自数据库服务器的返回数据包之前拒绝了它们。

在数据库上执行`tcpdump`的另一个有趣的地方是，如果我们查看在`enp0s8`上执行的`tcpdump`，我们不会看到`SYN-ACK`包。 然而，如果我们让`tcpdump`查看我们使用的所有接口，`tcpdump`也会显示出`SYN-ACK`数据包来自`192.168.33.12`。 这表明`SYN-ACK`正在从另一个接口发送。

为了确认这一点，我们可以再次运行`tcpdump`，将捕获限制为遍历`enp0s8`接口的数据包。

```sh
[db]# tcpdump -nnvvv -i enp0s8 port 3306 and host 192.168.33.11
04:04:09.167121 IP (tos 0x0, ttl 64, id 60173, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x4111 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9320053 ecr 0,nop,wscale 6], length 0
04:04:10.171104 IP (tos 0x0, ttl 64, id 60174, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.51149 > 192.168.33.12.3306: Flags [S], cksum 0x3d26 (correct), seq 558685560, win 14600, options [mss 1460,sackOK,TS val 9321056 ecr 0,nop,wscale 6], length 0

```

通过执行`tcpdump`，我们仍然只能看到来自博客服务器的`SYN`数据包。 但是，如果我们对所有接口运行相同的`tcpdump`，我们不仅会看到`SYN`包，还会看到`SYN-ACK`包。

```sh
[db]# tcpdump -nnvvv -i any port 3306 and host 192.168.33.11
15:37:51.616621 IP (tos 0x0, ttl 64, id 8389, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.47339 > 192.168.33.12.3306: Flags [S], cksum 0x34dd (correct), seq 4225047048, win 14600, options [mss 1460,sackOK,TS val 3357389 ecr 0,nop,wscale 6], length 0
15:37:51.616665 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.12.3306 > 192.168.33.11.47339: Flags [S.], cksum 0xc396 (incorrect -> 0x3609), seq 1637731271, ack 4225047049, win 14480, options [mss 1460,sackOK,TS val 3330467 ecr 3357389,nop,wscale 6], length 0

```

返回到`192.168.33.11`的`SYN-ACK`包来自`192.168.33.12`。 前面，我们确定这个 IP 绑定到网络设备`enp0s8`。 然而，当我们使用`tcpdump`来查看所有正在发送的数据包时，`SYN-ACK`并没有从`enp0s8`被捕获。 这意味着`SYN-ACK`包是从不同的接口发送的。

## 路由

一个`SYN`数据包如何到达一个接口，而另一个`SYN-ACK`返回? 一个可能的答案是，这是由于数据库服务器上的路由定义配置错误。

每个支持网络的操作系统都维护一个称为**路由表**的东西。 这个路由表是一个包应该接受的定义好的网络路由的集合。 为了给这个概念提供一些背景信息，让我们使用两个接口`enp0s3`和`enp0s8`作为示例。

```sh
# ip addr show enp0s8
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:c9:d3:65 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.12/24 brd 192.168.33.255 scope global enp0s8
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:fec9:d365/64 scope link
 valid_lft forever preferred_lft forever
# ip addr show enp0s3
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
 link/ether 08:00:27:20:5d:4b brd ff:ff:ff:ff:ff:ff
 inet 10.0.2.16/24 brd 10.0.2.255 scope global dynamic enp0s3
 valid_lft 65115sec preferred_lft 65115sec
 inet6 fe80::a00:27ff:fe20:5d4b/64 scope link
 valid_lft forever preferred_lft forever

```

如果我们查看这两个接口，我们知道`enp0s8`接口连接到`192.168.33.0/24`(`inet 192.168.33.12/24`)网络，而`enp0s3`接口连接到`10.0.2.0/24`(`inet 10.0.2.16/24`)网络。

如果我们连接到 IP 10.0.2.19，数据包不应该出`enp0s8`接口，因为这些数据包的最佳路由将通过`enp0s3`接口。 这是最优路由的原因是`enp0s3`接口已经是包含 IP`10.0.2.19`的`10.0.2.0/24`网络的一部分。

`enp0s8`接口是不同网络(`192.168.33.0/24`)的一部分，因此不是最优路由。 事实上，`enp0s8`接口甚至不能路由到`10.0.2.0/24`网络。

尽管`enp0s8`可能不是最优路由，但是如果路由表中没有相应的条目，内核也不会知道这一点。 为了深入研究我们的问题，我们需要查看这个数据库服务器上的路由表。

### 查看路由表

在 Linux 中，有一些方法可以查看当前的路由表; 在本节中，我将介绍两个。 第一种方法将使用`netstat`命令。

如果要使用`netstat`命令查看路由表，只需使用`–r`(路由)或`--route`标志运行该命令。 在下面的示例中，我们还将使用`-n`标志来阻止`netstat`执行 DNS 查找。

```sh
[db]# netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window irtt Iface
0.0.0.0         10.0.2.2        0.0.0.0         UG        0 0 0 enp0s3
10.0.2.0        0.0.0.0         255.255.255.0   U         0 0 0 enp0s3
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0 0 enp0s8
192.168.33.0    0.0.0.0         255.255.255.0   U         0 0 0 enp0s8
192.168.33.11   10.0.2.1        255.255.255.255 UGH       0 0 0 enp0s3

```

虽然`netstat`可能不是打印路由表的最佳 Linux 命令，但是在本例中使用它有一个非常特殊的原因。 正如我在本章和本书前面提到的，`netstat`命令是一个通用工具，几乎存在于每一个现代服务器、路由器或桌面。 通过了解如何使用`netstat`查看路由表，您可以在安装了`netstat`的任何操作系统上执行基本的网络故障排除。

一般来说，可以肯定的是，`netstat`命令是可用的，并且至少可以为您提供系统网络状态和配置的基本细节。

与其他实用程序(如`ip`命令)相比，`netstat`的格式可能有点神秘。 然而，前面的路由表向我们展示了相当多的信息。 为了更好地理解，让我们逐个分析输出路径。

```sh
Destination     Gateway         Genmask         Flags   MSS Window irtt Iface
0.0.0.0         10.0.2.2        0.0.0.0         UG        0 0 0 enp0s3

```

可以看到，`netstat`命令的输出有多个列，准确地说是 8 个。 第一列是`Destination`列。 这用于定义路由范围内的目的地址。 在前面的示例中，目的地是`0.0.0.0`，它本质上是一个通配符值，意味着任何东西都应该通过这个表项路由。

第二列是`Gateway`。 网关地址是使用这条路由的网络数据包应该发送到的下一跳。 本例中设置下一跳或网关地址为`10.0.2.2`; 这意味着通过这个表项路由的任何包都将被发送到`10.0.2.2`，然后`10.0.2.2`将这些包路由到下一个系统，直到它们到达目的地。

第三列是`Genmask`，本质上是表示路线的“`generality`”。 这个专栏的另一种思考方式是`netmask`; 在前面的示例中，“`genmask`”被设置为`0.0.0.0`，这是一个开放范围。 这意味着到任何地方的数据包都应该从这个路由表项路由出去。

第四列是`Flag`列，用于提供该路由的具体信息。 本例中的`U`值表示该路由所使用的接口状态为 up。 `G`值表示该路由使用了网关地址。 在前面的例子中，我们可以看到我们的路由利用了一个网关地址; 然而，并不是这个系统的所有路由都是这样。

第五、第六和第七列在 Linux 服务器上并不常用。 `MSS`列用于显示为该路由指定的**最大段大小**。 值为 0 意味着该值被设置为默认值，并且不会更改。

`Window`列是 TCP 窗口大小，它表示在一次突发中将接受的最大数据量。 同样，当该值设置为 0 时，将使用默认大小。

第七列是`irtt`，用于指定该路线的**初始往返时间**。 内核将通过设置初始往返时间来重新发送从未响应的数据包; 您可以增加或减少内核认为包丢失的时间。 与前两列的情况一样，0 的值意味着将对使用这条路由的包使用默认值。

第八列，也就是最后一列，即`IFace`列，是使用这条路由的数据包应该使用的网络接口。 本例中为`enp0s3`接口。

#### 默认路由

我们例子中的第一条路径实际上是我们系统的一条非常特殊的路径。

```sh
Destination     Gateway         Genmask         Flags   MSS Window irtt Iface
0.0.0.0         10.0.2.2        0.0.0.0         UG        0 0 0 enp0s3

```

如果我们查看这个路由的细节和每个列的定义，我们可以确定这个路由是服务器的默认路由。 缺省路由是一种特殊的路由，当没有其他路由取代它时，它被“默认地”使用。 简单地说，如果我们有数据包要发送到一个地址，比如`172.0.0.10`，这些数据包将通过默认路由。

这是因为在我们的数据库服务器的路由表中没有其他路由指定 IP`172.0.0.10`。 因此，系统只是通过缺省路由(一个全局路由)将数据包发送到这个 IP 地址。

我们可以确定第一个路由是服务器的默认路由，因为目的地址是`0.0.0.0`，这实际上意味着任何东西。 第二个指示是`0.0.0.0`中的`Genmask`，与目的地址一起表示任意 IPv4 地址。

使用网关地址也是缺省路由的典型情况，因此网关设置了`destination`和`genmask`通配符这一事实清楚地表明上述路由是缺省路由。

非默认路由通常如下所示:

```sh
10.0.2.0        0.0.0.0         255.255.255.0   U         0 0 0 enp0s3

```

上述路径的目的地为 10.0.2.0，而`genmask`为 255.255.255.0; 这实际上是说 10.0.2.0/24 网络中的任何东西都将匹配这个路由。

由于这条路由的范围是`10.0.2.0/24`，很可能是通过`enp0s3`接口配置添加的。 我们可以根据`enp0s3`接口配置来确定这一点，因为它连接到`10.0.2.0/24`网络，而`10.0.2.0/24`网络是这条路由的目标。 默认情况下，Linux 将根据网络接口的配置自动添加路由。

```sh
10.0.2.0        0.0.0.0         255.255.255.0   U         0 0 0 enp0s3

```

这条路由是内核确保`10.0.2.0/24`网络通信从`enp0s3`接口出去的一种方式，因为这条路由将取代默认路由。 对于网络路由，将总是使用最具体的路由。 由于默认路由是一个通配符，并且该路由是特定于`10.0.2.0/24`网络的，因此该路由将用于网络中的任何内容。

### 利用 IP 显示路由表

另一个用于检查路由表的工具是`ip`命令。 `ip`命令，正如我们在本章中所看到的，是一个非常广泛的实用程序，可以在现代 Linux 系统中用于几乎所有与网络相关的事情。

`ip`命令的一个用途是添加、删除或显示网络路由配置。 要显示当前的路由表，只需执行带`route show`选项的`ip`命令。

```sh
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
169.254.0.0/16 dev enp0s8  scope link  metric 1003
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12
192.168.33.11 via 10.0.2.1 dev enp0s3  proto static  metric 1

```

虽然学习使用`netstat`命令对于非 Linux 操作系统很重要，但是`ip`命令对于任何 Linux 网络故障诊断或配置都是一个必要的工具。

由于我们使用`ip`命令对路由进行故障排除，我们甚至会发现它比`netstat`命令更容易。 一个例子是寻找默认路由。 当`ip`命令显示缺省路由时，它使用单词 default 作为目的地，而不是 0.0.0.0，这种方法更容易理解，特别是对于新系统管理员。

它也更容易阅读其他路线。 例如，在前面查看通过`netstat`的路由时，我们的示例路由如下所示:

```sh
10.0.2.0        0.0.0.0         255.255.255.0   U         0 0 0 enp0s3

```

使用`ip`命令，相同的路由显示格式如下:

```sh
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16

```

在我看来，`ip`路由显示的格式比`netstat -rn`命令的格式简单得多。

### 寻找路由错误配置

现在我们知道了如何查看服务器上的路由表，我们可以使用`ip`命令来查找可能导致数据库连接问题的任何路由。

```sh
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
169.254.0.0/16 dev enp0s8  scope link  metric 1003
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12
192.168.33.11 via 10.0.2.1 dev enp0s3  proto static  metric 1

```

这里，我们可以看到系统中定义的 5 条路径。 让我们分解这些路径，以便更好地理解它们。

```sh
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16

```

前两条路线我们已经讨论过了，不再回顾。

```sh
169.254.0.0/16 dev enp0s8  scope link  metric 1003

```

第三条路由定义从`169.254.0.0/16`(`169.254.0.0`到`169.254.255.255`)的所有流量都通过`enp0s8`设备发送。 这是一个非常宽泛的路由，但很可能不会影响到 IP`192.168.33.11`的路由。

```sh
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12
192.168.33.11 via 10.0.2.1 dev enp0s3  proto static  metric 1

```

然而，第四个和第五个路由将改变到 192.168.33.11 的网络数据包的路由方式。

```sh
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12

```

第四个路由定义到`192.168.33.0/24`(`192.168.33.0`到`192.168.33.255`)网络的所有流量都从`enp0s8`接口路由，并来自`192.168.33.12`。 `enp0s8`接口的配置也会自动添加这条路由; 这与之前`enp0s3`添加的路线相似。

由于`enp0s8`设备被定义为`192.168.33.0/24`网络的一部分，因此只有将该网络的流量路由出该接口才有意义。

```sh
192.168.33.11 via 10.0.2.1 dev enp0s3  proto static  metric 1

```

然而，第 5 条路由定义到特定 IP`192.168.33.11`(博客服务器的 IP)的所有流量都通过`enp0s3`设备发送到`10.0.2.1`网关。 这很有趣，因为第 5 条路由和第 4 条路由的配置非常冲突，因为它们都定义了如何处理`192.168.33.0/24`网络中的 ip。

#### 更具体的路线获胜

正如前面提到的，路由网络数据包的黄金规则*是，更具体的路由总是获胜。 如果我们看一下路由配置，我们有一条路由，它说`192.168.33.0/24`子网中的所有流量都应该输出`enp0s8`设备。 还有第二条路线，明确地说`192.168.33.11`应该通过`enp0s3`设备。 IP`192.168.33.11`同时适用于这两种规则，但是系统应该通过哪条路由发送数据包?*

 *答案总是更具体的路线。

由于第二条路由明确定义了所有到`192.168.33.11`的流量都从`enp0s3`接口出去，内核将通过`enp0s3`接口路由所有返回的数据包。 无论为`192.168.33.0/24`定义的路由是什么，甚至是缺省路由都是如此。

我们可以通过使用`ip`命令和`route get`选项来查看所有这些操作。

```sh
[db]# ip route get 192.168.33.11
192.168.33.11 via 10.0.2.1 dev enp0s3  src 10.0.2.16
 cache

```

带有`route get`选项的`ip`命令将接受所提供的 IP，并输出数据包将接受的路由。

当我们对`192.168.33.11`使用这个命令时，我们可以看到`ip`明确表示路由将通过`enp0s3`设备。 如果我们对其他 ip 使用相同的命令，我们可以看到缺省路由和`192.168.33.0/24`路由是如何使用的。

```sh
[db]# ip route get 192.168.33.15
192.168.33.15 dev enp0s8  src 192.168.33.12
 cache
[db]# ip route get 4.4.4.4
4.4.4.4 via 10.0.2.2 dev enp0s3  src 10.0.2.16
 cache
[db]# ip route get 192.168.33.200
192.168.33.200 dev enp0s8  src 192.168.33.12
 cache
[db]# ip route get 169.254.3.5
169.254.3.5 dev enp0s8  src 192.168.33.12
 cache

```

我们可以在这里看到，当一个 IP 地址在一个子网内，并且定义了一个特定的路由时，这个特定的路由就会被获取。 但是，当一个 IP 没有被特定的路由定义时，将使用缺省路由。

# 假设

既然我们了解了包到`192.168.33.11`的路由方式，那么我们应该调整之前的假设，以反映出`192.168.33.11`到`enp0s3`的路由是不正确的，并导致了我们的问题。

本质上，发生的情况(我们通过`tcpdump`看到)是，当数据库服务器(`192.168.33.12`)从博客服务器(`192.168.33.11`)接收到网络数据包时，它到达`enp0s8`设备。 但是，当数据库服务器向 web 应用服务器发送应答报文(`SYN-ACK`)时，应答报文是通过`enp0s3`接口发送的。

由于`enp0s3`设备连接到`10.0.2.0/24`网络，因此数据包似乎正在被`10.0.2.0/24`网络上的另一个系统或设备拒绝(`RESET`)。 这很可能是因为这是异步路由的一个主要示例。

异步路由是指包到达一个接口，但在另一个接口上得到响应。 在大多数网络配置中，默认情况下是拒绝的，但在某些情况下，可以启用; 然而，这些情况并不十分普遍。

在我们的示例中，由于`enp0s8`接口是`192.168.33.0/24`子网的一部分，因此启用异步路由没有意义。 我们发送到`192.168.33.11`的数据包应该简单地通过`enp0s8`接口路由。

# 试错

现在，我们已经确定了数据收集的问题，并建立了我们的假设的可能原因，我们可以开始下一个故障排除步骤:使用尝试和错误来纠正问题。

## 移除无效路由

为了纠正我们的问题，我们需要删除无效的路由`192.168.33.11`。 为此，我们将再次使用`ip`命令，这一次使用`route del`选项。

```sh
[db]# ip route del 192.168.33.11
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
169.254.0.0/16 dev enp0s8  scope link  metric 1003
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12

```

在前面的示例中，我们使用带有`route del`选项的`ip`命令来删除以单个 IP 为目标的路由。 我们可以使用相同的命令和选项来删除为子网定义的路由。 下面的例子将删除`169.254.0.0/16`网络的路由:

```sh
[db]# ip route del 169.254.0.0/16
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12

```

从`ip`route show 执行中，我们可以看到`192.168.33.11`不再有冲突的 route。 问题是:这解决了我们的问题吗? 唯一确定的方法是测试它，而要做到这一点，我们只需刷新加载了博客错误页面的浏览器。

![Removing the invalid route](../images/00005.jpeg)

看来我们成功地纠正了这个问题。 如果现在执行`tcpdump`，就可以验证博客和数据库服务器是否能够通信。

```sh
[db]# tcpdump -nnvvv -i enp0s8 port 3306
tcpdump: listening on enp0s8, link-type EN10MB (Ethernet), capture size 65535 bytes
16:14:05.958507 IP (tos 0x0, ttl 64, id 7605, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.11.47350 > 192.168.33.12.3306: Flags [S], cksum 0xa9a7 (correct), seq 4211276877, win 14600, options [mss 1460,sackOK,TS val 46129656 ecr 0,nop,wscale 6], length 0
16:14:05.958603 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
 192.168.33.12.3306 > 192.168.33.11.47350: Flags [S.], cksum 0xc396 (incorrect -> 0x786b), seq 2378639726, ack 4211276878, win 14480, options [mss 1460,sackOK,TS val 46102446 ecr 46129656,nop,wscale 6], length 0
16:14:05.959103 IP (tos 0x0, ttl 64, id 7606, offset 0, flags [DF], proto TCP (6), length 52)
 192.168.33.11.47350 > 192.168.33.12.3306: Flags [.], cksum 0xdee0 (correct), seq 1, ack 1, win 229, options [nop,nop,TS val 46129657 ecr 46102446], length 0
16:14:05.959336 IP (tos 0x8, ttl 64, id 24256, offset 0, flags [DF], proto TCP (6), length 138)
 192.168.33.12.3306 > 192.168.33.11.47350: Flags [P.], cksum 0xc3e4 (incorrect -> 0x99c9), seq 1:87, ack 1, win 227, options [nop,nop,TS val 46102447 ecr 46129657], length 86
16:14:05.959663 IP (tos 0x0, ttl 64, id 7607, offset 0, flags [DF], proto TCP (6), length 52)

```

前面的输出是我们期望从一个健康的连接中看到的。

在这里,我们看到四个包,第一个是一个`SYN`(`Flags [S],`)`blog.example.com`(`192.168.33.11`),紧随其后的是一个`SYN-ACK`(`Flags [S.],`)`db.example.com`(`192.168.33.12`)和一个【显示】或`SYN-ACK-ACK`(`Flags [.],`)`blog.example.com`(【病人】)。 这三个数据包就是完成的 TCP 三次握手。 第四个包是`PUSH`(`Flags [P.],`)包，它是实际的数据传输。 所有这些都是良好工作的网络连接的标志。

## 配置文件

现在我们已经从路由表中删除了无效的路由，我们可以看到博客正在工作; 这意味着我们结束了，对吧? 不，至少还没有。

当我们使用`ip`命令删除路由时，我们从活动路由表中删除了这条路由，但并没有从系统中整体删除这条路由。 如果我们重新启动网络，或者简单地重新启动服务器，这个无效的路由将重新出现。

```sh
[db]# service network restart
Restarting network (via systemctl):                        [  OK  ]
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
169.254.0.0/16 dev enp0s8  scope link  metric 1003
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12
192.168.33.11 via 10.0.2.1 dev enp0s3  proto static  metric 1

```

这是因为，当系统引导时，它会根据一组文件中的配置来配置网络。 `ip`命令用于操作当前的网络配置，而不是这些网络配置文件。 因此，使用`ip`命令所做的任何更改都不是永久性的，而只是临时的，直到下一次系统读取并应用网络配置。

为了从网络配置中完全删除这条路由，我们需要修改网络配置文件。

```sh
[db]# cd /etc/sysconfig/network-scripts/

```

在基于 Red Hat Enterprise linux 的系统中，网络配置文件大多存储在`/etc/sysconfig/network-scripts`文件夹中。 首先，我们可以切换到这个文件夹并执行 ls -la 来识别当前的网络配置文件。

```sh
[db]# ls -la
total 228
drwxr-xr-x. 2 root root  4096 Mar 14 14:37 .
drwxr-xr-x. 6 root root  4096 Mar 14 23:42 ..
-rw-r--r--. 1 root root   195 Jul 22  2014 ifcfg-enp0s3
-rw-r--r--. 1 root root   217 Mar 14 14:37 ifcfg-enp0s8
-rw-r--r--. 1 root root   254 Apr  2  2014 ifcfg-lo
lrwxrwxrwx. 1 root root    24 Jul 22  2014 ifdown -> ../../../usr/sbin/ifdown
-rwxr-xr-x. 1 root root   627 Apr  2  2014 ifdown-bnep
-rwxr-xr-x. 1 root root  5553 Apr  2  2014 ifdown-eth
-rwxr-xr-x. 1 root root   781 Apr  2  2014 ifdown-ippp
-rwxr-xr-x. 1 root root  4141 Apr  2  2014 ifdown-ipv6
lrwxrwxrwx. 1 root root    11 Jul 22  2014 ifdown-isdn -> ifdown-ippp
-rwxr-xr-x. 1 root root  1642 Apr  2  2014 ifdown-post
-rwxr-xr-x. 1 root root  1068 Apr  2  2014 ifdown-ppp
-rwxr-xr-x. 1 root root   837 Apr  2  2014 ifdown-routes
-rwxr-xr-x. 1 root root  1444 Apr  2  2014 ifdown-sit
-rwxr-xr-x. 1 root root  1468 Jun  9  2014 ifdown-Team
-rwxr-xr-x. 1 root root  1532 Jun  9  2014 ifdown-TeamPort
-rwxr-xr-x. 1 root root  1462 Apr  2  2014 ifdown-tunnel
lrwxrwxrwx. 1 root root    22 Jul 22  2014 ifup -> ../../../usr/sbin/ifup
-rwxr-xr-x. 1 root root 12449 Apr  2  2014 ifup-aliases
-rwxr-xr-x. 1 root root   859 Apr  2  2014 ifup-bnep
-rwxr-xr-x. 1 root root 10223 Apr  2  2014 ifup-eth
-rwxr-xr-x. 1 root root 12039 Apr  2  2014 ifup-ippp
-rwxr-xr-x. 1 root root 10430 Apr  2  2014 ifup-ipv6
lrwxrwxrwx. 1 root root     9 Jul 22  2014 ifup-isdn -> ifup-ippp
-rwxr-xr-x. 1 root root   642 Apr  2  2014 ifup-plip
-rwxr-xr-x. 1 root root  1043 Apr  2  2014 ifup-plusb
-rwxr-xr-x. 1 root root  2609 Apr  2  2014 ifup-post
-rwxr-xr-x. 1 root root  4154 Apr  2  2014 ifup-ppp
-rwxr-xr-x. 1 root root  1925 Apr  2  2014 ifup-routes
-rwxr-xr-x. 1 root root  3263 Apr  2  2014 ifup-sit
-rwxr-xr-x. 1 root root  1628 Oct 31  2013 ifup-Team
-rwxr-xr-x. 1 root root  1856 Jun  9  2014 ifup-TeamPort
-rwxr-xr-x. 1 root root  2607 Apr  2  2014 ifup-tunnel
-rwxr-xr-x. 1 root root  1621 Apr  2  2014 ifup-wireless
-rwxr-xr-x. 1 root root  4623 Apr  2  2014 init.ipv6-global
-rw-r--r--. 1 root root 14238 Apr  2  2014 network-functions
-rw-r--r--. 1 root root 26134 Apr  2  2014 network-functions-ipv6
-rw-r--r--. 1 root root    30 Mar 13 02:20 route-enp0s3

```

从目录列表中，我们可以看到几个配置文件。 但是，通常我们只对以“`ifcfg-`”和以“`route-`”开头的文件感兴趣。

以“`ifcfg-`”开头的文件用于定义网络接口; 这些文件的命名约定为“`ifcfg-<device name>`”; 例如，要查看`enp0s8's`配置，可以读取`ifcfg-enp0s8`文件。

```sh
[db]# cat ifcfg-enp0s8
NM_CONTROLLED=no
BOOTPROTO=none
ONBOOT=yes
IPADDR=192.168.33.12
NETMASK=255.255.255.0
DEVICE=enp0s8
PEERDNS=no

```

我们可以看到这个配置文件定义了这个接口使用的 IP 地址和`Netmask`。

“`route-`”文件用于定义系统的路由配置。 该文件的约定类似于接口文件“`route-<device name>`”，在文件夹列表中，只有一个路由文件`route-enp0s3`。 这是最可能定义错误路由的位置。

```sh
[db]# cat route-enp0s3
192.168.33.11/32 via 10.0.2.1

```

一般来说，除非定义了静态路由(静态定义的路由)，否则“`route-*`”文件是不存在的。 我们可以看到这个文件中只定义了一条路由，这意味着路由表中定义的所有其他路由都是根据接口配置动态配置的。

在上例中，`route-enp0s3`文件中定义的路由没有指定接口。 因此，接口将基于文件名定义; 如果相同的条目在 route-`enp0s8`文件中，网络服务将尝试在`enp0s8`接口上定义路由。

为了确保这条路由不再出现在路由表中，我们需要将它从这个文件中删除; 或者，在这种情况下，由于它是唯一的路由，我们应该删除整个文件。

```sh
[db]# rm route-enp0s3
rm: remove regular file 'route-enp0s3'? y

```

删除文件和路由的决定取决于所支持的环境; 如果你不确定这是不是正确的做法，你应该事先问一个能告诉你是否正确的人。 对于本例，我们假设可以删除这个网络配置文件。

重新启动网络服务后，我们应该看到路由消失了。

```sh
[db]# service network restart
Restarting network (via systemctl):                        [  OK  ]
[db]# ip route show
default via 10.0.2.2 dev enp0s3  proto static  metric 1024
10.0.2.0/24 dev enp0s3  proto kernel  scope link  src 10.0.2.16
169.254.0.0/16 dev enp0s8  scope link  metric 1003
192.168.33.0/24 dev enp0s8  proto kernel  scope link  src 192.168.33.12

```

现在，路由已经消失，网络配置已经重新加载，我们可以安全地说，我们已经纠正了这个问题。 我们可以通过再次加载网页来验证这一点，以确保博客正常工作。

![Configuration files](../images/00006.jpeg)

# 总结

如果我们回顾这一章，我们学习了很多关于 Linux 上如何排除网络连接问题的知识。 我们学习了如何使用`netstat`和`tcpdump`工具来查看传入和传出的连接。 我们了解了 TCP 三次握手以及`/etc/hosts`文件如何取代 DNS 设置。

在这一章中，我们介绍了许多命令，虽然我们对每个命令及其功能都给出了相当好的概述，但有些命令我们仅仅触及了表面。

像`tcpdump`这样的命令就是最好的例子。 在本章中，我们使用了`tcpdump`很多次，但是这个工具的功能远远超过了我们使用它的功能。 在本书中涉及的所有命令中，我个人认为`tcpdump`是一个需要花时间学习的命令，因为它是一个非常有用和强大的工具。 我用它解决过很多问题，有时这些问题不是特定于网络而是特定于应用程序。

在下一章中，我们将通过故障排除防火墙保持这种网络势头。 我们可能会在下一章中看到我们在本章中使用过的一些相同的命令，但这没关系; 它只是说明了理解网络和排除网络故障的工具是多么重要。***