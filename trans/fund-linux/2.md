# Linux 命令行

在本章中，我们将向您介绍开始使用 Linux 命令行时最基本的概念。这是一个非常强大和高效的工具，使用它，您可以执行在使用 Linux 时通常需要的各种操作。过多的快捷方式和技巧将帮助您更有效地浏览命令行。

在本章中，我们将带您了解以下内容:

*   壳球状
*   重定向和管道
*   `grep`、`sed`和`awk`命令
*   在 Linux 系统中导航文件和文件夹

# 介绍命令行

在本节中，您将学习如何运行 Linux 命令行程序以及命令行的基本结构。您还将了解什么是程序选项和参数，以及为什么它们对自定义命令很重要。

当我们说 Linux 命令行的时候，我们真正指的是 **shell** 。重要的是要知道外壳不同于终端仿真器。终端是一个屏幕或窗口，允许你访问 Linux 服务器的输入和输出。shell 只是一个在服务器上运行的程序，和任何其他命令一样，它等待、解释、处理、执行和响应用户键入的命令。

首先，打开一个新的终端模拟器，使用 SSH 登录到您的 CentOS 7 服务器，正如我们在[第 1 章](1.html)、*Linux 简介*中了解到的。使用您在安装过程中设置的普通用户帐户登录，因为正如我们之前说过的，除非必须，否则永远不要使用根用户。在我的例子中，用户名是`olip`:

![](assets/3973123b-3647-47cd-963a-91fd8ea28937.png)

成功登录到您的服务器后，一个重要的程序已经自动启动，它被称为 shell，并且一直在使用它。事实上，当我们谈论 Linux 终端时，我们真正谈论的是外壳。存在几种外壳变体；在 CentOS 7 上，我们默认使用 **Bash** ，或者**伯恩再一次 Shell** 。当 shell 启动时，您首先会注意到以美元符号($)结尾的行，这称为 shell 提示符。

在我们的例子中，它给了我们一些有用的信息:登录用户名和我们所在的当前目录。波浪号是一个特殊的字符，它意味着主目录，这是登录时的默认目录。shell 提示符后出现光标，它是下划线字符，用户可以在这里键入文本，然后由 shell 处理和执行。但是用户输入只有在*键输入结束后才会被 shell 处理和执行。如果你犯了任何类型的错误，只要按退格键删除最后一个字符。我们将在本章中学习的第一个有用的命令是如何注销系统。*

在 Linux 终端上，该命令注销当前用户并返回登录屏幕:

1.  打开 Linux 终端，输入`logout`命令，然后按下*进入*键。
2.  但是，如果您在使用 SSH 连接的同时执行相同的操作，它与我们在上一章中学习的`exit`命令具有相同的效果。
3.  让我们尝试再次登录到 CentOS 服务器。
4.  让我们尝试一个简单的命令；键入`date`并按下*进入*键。这是一个输出当前日期时间值的命令:

![](assets/997fd978-1da6-461b-a240-4087ce52aff9.png)

如您所见，如果 shell 已经完成了特定命令的执行，并准备好接受用户的新输入，新的 shell 提示将出现在新的一行中，标记其准备就绪。现在，输入`cal`并按*进入*。这个命令打印出当前月份的漂亮的表格视图。

If the first character of any command types is prepended in the shell with the hash key, the command will not be executed when pressing the *Enter* key.

典型的 Linux 系统(如 CentOS 7)包含数百个不同的命令，包括在默认安装中。如果你只能输入纯命令，其他什么都不能输入，我们在 shell 中的工作将非常有限和静态，你将根本无法正常工作。因此，我们需要一种方法来定制我们的命令或在执行过程中更改默认行为，为它们提供进一步的信息。但是我们怎么做呢？

输入命令行选项和参数的威力。首先，我们需要讨论 shell 中一个命令的一般结构，它最简单的形式是`COMMANDNAME OPTIONS ARGUMENTS`。命令名称是要启动的命令的名称。请注意，在 Linux 中，命令名称区分大小写。键入`whoami`，然后按*进入*。这个命令将打印出在 shell 中工作的当前用户的名字。由于 Linux 区分大小写，该命令不能使用大写字母启动，因为每个版本都引用不同的命令。在这里，我们也将看到为什么 shell 是如此有用的程序。它不仅可以监听和解释命令，还可以在出现问题时向您显示有用的错误消息，例如在系统中找不到命令。通常，在 Linux 上，所有标准的 Bash 脚本命令都是用小写字母编写的。要获得一些可用命令的列表，请键入`ls /bin`。现在，让我们继续讨论 shell 中最基本的命令之一。键入`ls`并按下*进入*键。此命令列出目录中的文件。如果没有给出进一步的信息，它会打印出我们当前所在目录中的所有可见文件:

![](assets/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)

如您所见，shell 命令还可以包含附加到命令名称的选项和参数，并使用空格将其隔开。这意味着，如果您想提供至少一个选项或参数，那么我们需要在命令名称后至少有一个空格。首先，让我们谈谈命令行选项。他们的目的是影响命令的行为。它们也被称为**开关**或**旗帜**。没有强制性标准，但通常任何单字符命令行选项都以单个破折号开始，而较长的选项名称有两个破折号符号。此外，如果您想提供多个单字符命令行选项，对于大多数标准的 Linux 命令，您可以将它们串联起来编写。最好知道单字符命令行选项通常是描述其含义的缩写:`-d`可以代表目录，`-x`代表排除，等等。

我们已经知道，没有任何进一步选项的`ls`命令会给出当前目录中所有文件的列表。如果您键入`ls -a`并按*进入*，您只需使用命令行选项运行第一个命令。`a`开关代表全部，它会影响默认行为`ls`，给你一个所有文件的列表，包括隐藏的文件，在 Linux 中这些文件以当前目录中的前导破折号开始。现在，让我们输入`ls -alth`并按下*进入*键查看结果:

![](assets/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)

通过使用我们刚才讨论的`-a`标志，以及使用代表**列表**的`-l`开关，这会更加影响命令的默认行为，并且它会以列表格式打印所有文件，包括更详细的信息，例如创建日期。`-t`开关代表**时间**，它按照修改日期对文件列表进行排序，最新的条目最先出现，`-h`代表**人类可读的**，它将使用 **MB** 而不是字节作为文件大小，以更易读的形式打印出文件大小。

Often, command-line options can have arguments bound to them. In addition to options, we have command-line arguments, which are also called **parameters**. This is any dynamic or free-text piece of information that is not an option, and which gets fed into the command when it starts. Typical examples are filenames or directories that the command wants to process during execution. Arguments are also divided by *spaces*.

键入`echo Hello`并按*进入*:

![](assets/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)

在上一个命令中，`Hello`是`echo`命令的参数，而不是选项。`echo`命令是最基本的 shell 命令之一。它只是将提供给它的参数打印回命令行。正如我们将看到的，这是测试外壳特性的理想选择，例如 **globbing** ，我们将在本节后面详细了解。现在让我们在终端中输入`ls -al /boot /var`并按*进入*查看类似于以下的结果:

![](assets/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)

在这个例子中，我们第一次使用了命令行选项和参数。命令`ls`用`a`和`l`选项执行，参数为`/boot`和`/var`。这将在`/boot`和`/var`目录的详细列表视图中打印出所有文件，包括隐藏的文件。如前所述，参数经常绑定到特定的选项，例如`tar`命令，我们将在后面讨论。当你需要处理一个输入文件时，你必须直接在`-f`选项之后指定，而不是其他地方，或者，简而言之，输入文件参数绑定到`-f`选项。这种方法是不正确的，会产生错误。

# 文件环球化

在这一节中，您将了解 shell 扩展是如何工作的，以及当使用处理大量输入文件的命令时，我们如何使用文件 globbing 使我们的生活变得更容易。我们将讨论所有现有的和可用的 shell globbing 字符类，并向您展示每个类的重要用例和示例。当使用使用文件或目录名作为参数的命令时，例如`ls`命令，了解文件和目录全局化非常有帮助。这些是在 shell 中键入的特殊字符，其行为不同于常规字符。所有的 globbing 字符都将被 shell 替换，在任何命令都可以使用它们作为参数之前，shell 会给出一个与字符模式匹配的文件列表。这是一种简化处理文件的符号，尤其是在处理大量需要键入和处理的文件时。使用文件 globbing 可以节省你很多时间，因为多个文件可以用一个字符来处理。用 shell 的文件组列表替换这些特殊字符的概念也称为 **shell 扩展**。有几个可用的 globbing 字符，我们可以使用它们来创建非常复杂的文件列表选择。

全局字符是通配符、问号、感叹号、方括号和破折号。虽然它们的外观和行为非常相似，但 shell globbing 和正则表达式并不相同，两个概念也不可互换。这意味着您不能对 globbing 文件应用正则表达式，反之亦然。我们将在本章下一节中了解更多关于正则表达式的内容。最重要的全局字符是通配符。它将匹配特定目录中可用的任意数量的任意字符文件名，除了一个例外，它不匹配以点开头的文件，您可能已经在 Linux 中查看隐藏文件时注意到了这一点。如果在以点开头的文件中使用通配符并按下*回车*会发生什么？我们来看一个例子。如前所述，我们可以使用`echo`命令在终端中打印出随机文本。

让我们先换一个不同的目录。键入`cd /etc`并按*进入*。现在，输入`echo *`并按*进入*:

![](assets/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)

在前面的命令中，在第一步中，shell 用当前目录中的文件列表替换通配符，并按照规则用空格分隔打印它们，然后显示包含任何字符的所有文件和目录，但不显示以点开头的文件。使用`echo`是在将你的 globbing 模式作为真正的命令行参数应用之前，测试它们是否与你想要的完全匹配的完美方法。您可以将通配符与任何其他静态字符混合使用，以使文件过滤器更加严格。键入`echo pa*`并按*进入*。这将匹配所有以小写字母`p`开头，后跟`a`，后跟任何其他字符的文件。或者输入`echo *.d`并按*进入*。本示例查找所有扩展名为`.d`的文件:

![](assets/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)

您甚至可以定义更严格的模式，例如，通过键入`echo li*.conf`并按*进入*。这个 globbing 模式将匹配当前目录中的所有文件，首先是小写的`l`，然后是`i`，接着是任何其他字符，但只匹配那些扩展名为`.conf`的文件。我们可以将文件 globbing 与任何接受文件选项列表作为参数的命令一起使用，例如`ls`命令。

例如，使用 globbing 模式`li *.conf`作为`ls`命令的命令行参数，为我们提供了与该模式匹配的所有文件的详细列表。同样，重要的是要理解我们没有将 globbing 模式输入到`ls`命令中，并且`ls`没有在程序执行期间在内部扩展文件。事实是，第一步中的一个 shell 将通配符扩展为一个文件列表，然后将该列表作为参数提供给`ls`命令。

We will use the `ls -d` option to not show directory content, which it does by default; this is because shell globbing doesn't differentiate between files and directories.

在终端中输入`ls -d rc?.d`。这将为您提供一个所有文件的列表，其中只有一个随机字符作为第三个字符。接下来，输入`ls -d krb5.conf??`命令，如下所示:

![](assets/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)

可以看到，问号也可以多次使用。这将获得扩展名为两个随机字符的所有文件，并且只有这些文件。我们将学习的最后一个全局字符是方括号，它定义了特定位置允许的字符范围，例如，键入`ls -l sub[ug]id`。这将扩展为所有文件的列表，以`sub`开头，第四个字符为`u`或`g`，后跟单词`id`:

![](assets/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)

正如我们接下来将学习的，我们可以将括号与其他全局字符混合在一起。键入以下`ls`命令参数:

```
ls /bin/[mM]ail*  
```

这将扩展到`bin`目录中所有邮件程序的列表，有大写和无大写。稍后我们将了解更多关于`bin`目录的信息。您也可以将数字用于范围；在终端中键入`ls -d rc[01234].d`命令:

![](assets/91788f1c-35a5-43be-9bcb-aaa224664a62.png)

在我们的示例中，这将扩展到`rc0.d`、`rc1.d`等等。如果您有连续的数字或字母范围，如在最后一个例子中，您也可以使用减号来缩短您的 globbing 表达式甚至更多。例如，输入`ls /bin/m[a-z] [a-z]`。这将给出以`m`开头的`bin`目录中的所有三个字母的命令名。

还有另一个有用的 globbing 字符，它是感叹号，可以用在括号中来定义扩展结果中不能有的东西，例如:`ls -d rc[!256].d`:

![](assets/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)

这表示我们不想展开第三个字符为`2`、`5`或`6`的文件。这也适用于括号内的连续范围，例如`ls -d rc[!3-6].d`。

关于 Linux 中的隐藏文件，您已经了解了三件事。它们以文件名中的一个点开始，通配符 globbing 会忽略它们，默认情况下`ls`不会显示它们；因此，它们被命名为隐藏。要显示主目录中的所有隐藏文件，我们使用`ls`命令的`-a`选项。您会看到您的主目录中有几个隐藏文件，例如`.bashrc`文件:

![](assets/873ee66e-2631-4a6b-909f-71cd386f56a8.png)

但是你的目录里还有另外两个特殊文件，名字分别是[ `.` ]和[ `..` ]，这两个特殊文件在本章后面会讲到。如果您想只显示当前目录中的隐藏文件而不显示这两个点文件，您需要键入什么？有了你现在拥有的所有知识，这应该很容易完成，下一行现在应该对你有意义。所以，输入`ls .[!.]*`。但这也会列出目录内容。要不列出目录内容，请使用`ls -d`标志，这样命令将是`ls -d .[!.]*`:

![](assets/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)

在这一节中，我们讨论了关于 Linux shell globbing 的所有知识。请记住，通配符匹配任何位置的每个文件名字符。非常重要的是，这条规则有一个例外:它与以点开头的文件名不匹配，在 Linux 中，这些文件名被称为隐藏文件。问号也是如此，但只是在一个位置；它也不匹配带前导点的文件名。括号在括号之间定义的单个位置匹配特定字符。当有连续的允许字符时，也可以使用破折号。要匹配除特定位置的一组字符之外的所有内容，请使用括号中的感叹号。

# 引用命令

正如我们在上一节中了解到的，shell 有一个特殊字符列表，这些字符在 shell 中有特殊的含义，并触发一些功能，例如使用通配符作为文件名。但是有比我们之前给你看的更特别的角色。如果您想使用这样的特殊字符，例如，使用包含问号符号的文件名，这些符号是有效的文件名，那么您就有一个问题，因为 shell 总是首先尝试对特殊字符应用特殊操作，所以它们不会像普通的文件名字符那样工作。这里的解决方案是使用各种方法禁用这些字符的所有特殊含义，例如引用，这样我们就可以将它们视为任何其他正常的文字字符。如您现在所知，在 Linux Bash shell 中，有一些特殊的字符，例如`* # [ ] . ~ ! $ { } < > | ? & - / , "`，它们对 shell 有特殊的意义，并得到与普通字符不同的对待。但是，如果您想使用文件名或目录作为参数，并且在其名称中包含一个这样的特殊字符，该怎么办呢？此外，如何处理名称中带有空格的文件名，空格也可以被视为特殊字符？

例如，如果您的目录中有一个名为`My private Documents.txt`的文件，您如何将其用作命令行参数？如果将它与`ls`命令一起使用，由于空格是命令行参数分隔符，外壳不能将其视为一个不同的文件。相反，它认为你提供了三个不同的文件，分别是`My`、`private`和`Documents.txt`:

![](assets/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)

此外，如果您想使用包含特殊字符(如感叹号)的文件，例如，如果您有一个名为`!super!file!.txt`的文件，这在 Linux 中是一个有效的文件名，会发生什么？如果我们试图使用这个文件名作为命令行参数，它就不能通过这个名称找到这个文件，因为它包含了特殊的字符，这些字符被 shell 以不同的方式处理。或者如果你想`echo`一些单词之间有多个空格的文本会发生什么？正如我们所知，空格也是一个特殊的 shell 字符，用于分隔命令行参数:

![](assets/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)

在刚刚显示的示例中，我们需要找到一种方法来禁用 shell 扩展，并阻止 shell 处理特殊字符。有两种简单的方法可以禁用参数中的 shell 扩展，它们是引用和转义。将特殊字符和空格放入单引号将防止 shell 扩展，并将所有可能的字符(包括特殊字符)视为普通字母数字字符。在单引号中，没有任何东西会被扩展；对于大多数特殊字符，这也适用于双引号，只有少数例外。

在下面的截图中，有两个例子起作用，但其他例子不起作用，它们得到了特殊待遇:

![](assets/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)

此外，如前面的截图所示，美元符号也保持特殊，如果您在报价时需要 shell 扩展环境变量，通常会使用这种符号。如前所述，单引号将禁用所有特殊字符。您可以通过使用反斜杠键来完成同样的操作，反斜杠键在 shell 中也称为**转义字符**，它的作用几乎与引号完全相同，但只会禁用 shell 扩展和下一个的所有特殊含义，并且只禁用反斜杠键后面的下一个直接字符:

![](assets/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)

如你所见，基本上是一样的。转义字符通常用于通过转义或禁用每行中的新行字符来创建清晰的多行命令行调用。反斜杠字符的另一种用法是在处理参数(如以破折号开头的文件)时使用它，因为这通常会混淆 shell，因为它将任何破折号都解释为选项。

例如，如果我们想创建一个名为`-dashy.txt`的空文件，这将不起作用，因为命令行很混乱，并且认为文件名是单字符选项的列表。在这里，我们可以使用转义字符来摆脱破折号的特殊含义。对于以破折号开始的参数，一些命令，如`ls`或`touch`，也有另一个很好的特性，双破折号，它标志着选项列表的结束。因此，要将您的 dashy 文件视为参数而不是选项，我们还可以键入`nano -dashy.txt`或`touch '-dashy.txt'`命令。

如您所知，外壳中存在许多具有特殊含义的特殊字符，例如外壳球形字符或感叹号。如果您想使用这些字符，而不是 shell 扩展文件列表，而是在文件名或其他文字命令参数中使用这些字符，该怎么办？你需要禁用它们。使用单引号将禁用所有特殊字符，并且是在 shell 中工作时的首选方式；它适用于几乎所有日常引用用例。使用双引号时，大多数特殊字符会被禁用，但不是全部，例如环境变量的 shell 扩展。因此，这种方法对于包含正常字符和环境变量值的文本创建非常有用。反斜杠或转义字符只会禁用以下字符的任何特殊含义。

# 寻求帮助

在我们开始教您如何使用 Linux 命令可用的各种形式的文档获得帮助之前，我们首先必须学习如何阅读默认命令语法文档。Linux 中提供的大多数标准 shell 命令都遵循描述其用法的统一格式。之后，我们将向您展示如何获得帮助。

当使用 Linux 命令行时，获得帮助和查找信息和文档非常重要，因为命令行可能非常复杂，没有人知道并且可以记住所有的东西。在每个 Linux 系统上，有几种方法可以获得帮助，这取决于您需要了解的信息的种类。在本节中，我们将探索不同的文档来源。

在前一节中，您已经学习了 Bash shell 命令的一般结构，以及您需要了解的关于命令选项和参数的所有内容，但通常这还不够。对于很多 shell 命令，选项和参数的具体结构非常复杂。一个职位可以绑定到一个特定的职位，其中一些可以是强制性的，也可以是可选的。另外，选项和参数可以相互依赖。在 Linux 中，对命令命令行格式的描述，包括参数和选项，被称为命令用法或命令语法**。学习阅读命令的用法是 Linux 初学者在开始时需要学习的最基本的技能之一。在 Linux 中描述命令用法的标准方式是命令名称，包含文本、点和文本的方括号，例如`CommandName [XXX]... TEXT`。方括号表示中的内容是可选的。三个点意味着点前的表达式可以重复多次或只重复一次。任何不带方括号的单词都是强制性的。**

以`ls`命令的一般语法为例，您已经知道如何使用它。从官方`ls`手册上看，可以解读为`ls [OPTION]... [FILE]...`；这意味着列出文件的命令有以下用法。它以`ls`命令名开始，其他都在括号中，所以所有选项和参数都是可选的，这意味着您也可以执行`ls`而不提供任何进一步的信息，只需按*回车*键。但是您也可以提供多个选项或仅一个选项。另外，我们可以看到参数是`FILE`类型的，这意味着在这个位置需要一个文件或目录。您也可以提供多个文件或目录，或者只提供一个或零个，如下图所示:

![](assets/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)

作为另一个例子，`copy`命令可以通过使用后跟零或多个选项的`cp`命令名称来运行。`cp`命令的语法是`cp [OPTION]... SOURCE... DEST_DIR`。您可以完全跳过选项，但至少一个或多个源目录和一个目标目录是必需的，并由三个点表示，没有它们您无法运行命令。例如，在没有至少两个参数的情况下运行`cp`会产生以下错误。所有选项都要正确使用:

![](assets/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)

既然我们已经知道如何阅读任何标准的命令语法或用法，那么我们实际上如何获得帮助呢？正如我们之前所说的，有几种方法可用，它们是命令帮助选项、手册页和完整的程序文档。通常，所有这三种类型的帮助都与命令行或程序一起安装，因此首先尝试在命令所在的同一台机器上本地获取 shell 命令的帮助是一个非常好的习惯。这通常是每个命令最准确、最可靠和最新的信息，在进行互联网研究或使用具有不同 Linux 版本或系统的另一台计算机的文档之前，应该优先考虑这一点。

Often internet solutions found in blogs or forums are too unspecific or plain wrong for your specific Linux installation, and should always be used with caution. Don't ever blindly copy and paste command snippets from the internet.

命令参数、选项和功能可能会随着时间的推移而改变，具体取决于版本和实现，如果应用不当，可能会非常危险。Linux 上有数百个命令，每个命令都有不同的语法。没有人能记住所有的东西，所以首先让我们从最简单快捷的方法开始，为你已经知道名字的任何标准 Linux 程序获得快速帮助。事实上，大多数程序都有一个特殊的命令行开关，可以在屏幕上打印出选项和参数使用情况的快速摘要，这在大多数情况下是您需要知道的全部内容。然而，在 Linux 上帮助或使用标志并不标准化，有些命令甚至根本没有这个标志，但是大多数工具开发人员遵循规则使用单字符标志`-h`，或者长选项标志`--help`。

Not all shell commands have a help option, especially those very easy ones.

现在，如果你需要更多的帮助，你可以查看命令手册，Linux 用户通常称之为**手册页**。大多数程序都有这样的文档。在接下来的几个示例中，您需要使用您在安装过程中设置的根帐户密码安装一些附加软件。手册页使用较少的导航，我们将在后面学习如何查看文本文件时讨论。

以下步骤将帮助您浏览 Linux 终端中任何命令的手册:

1.  打开终端，输入`copy`命令的`man cp`。
2.  使用*向上翻页*和*向下翻页*键上下滚动文档，斜线( */)* 可用于搜索文本；在斜线后输入任意关键词进行搜索，然后按*进入*。比如`/backup`。
3.  按下*结束*键，在手册页中搜索下一个条目。
4.  要退出搜索选项，请使用 *Esc* 键。
5.  使用小写 *g* ，可以滚动到页面顶部，而大写 *G* 滚动到页面底部。
6.  可以按小写 *q* 退出手册页。

回到页面顶部，`cp`命令的手册页分为不同的主题和标题，如下图截图所示:

![](assets/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)

大多数标准的 Linux 命令都遵循这种类型的结构。此外，您可以在这里看到，根据给定的选项和参数，一些命令可以有不同的使用格式。现在，停止使用 *q* 键。`man`命令有一个非常有用的选项，键入`man -k`，然后将任何利益定义作为参数。这将在系统上安装的所有手册页中搜索某个关键字。例如，如果您忘记了特定的命令名称，或者需要关于要使用的主题或命令的一般帮助，或者需要首先查看哪里，这非常有用。如果您键入`man -k copy`命令，这将打印出与复制有关的命令的所有手册页:

![](assets/ad0c03ec-3196-4227-9505-5a66403941ef.png)

在使用`-k`标志的同时，还可以看到搜索结果在男名后面的括号中写了一些数字；这些是手册页部分，这是我们需要知道的另一个非常有用的概念。一个 Linux shell 定义，比如`printf`，可以描述的不仅仅是一个命令行程序，手册页也不仅仅描述命令行工具。在我们的例子中，`printf`不仅是一个可以由 shell 用户启动的命令行工具，也是这个系统使用的编程语言 C 中库函数的名称。`man`现在为某个特定的人的名字来自的类型定义一个区段编号系统。键入`man man`将显示`man`命令的手动文档，并搜索键盘部分，如下所示:

![](assets/e1609794-341f-41c7-b07b-b02aa13663cb.png)

正如我们在前面的截图中看到的，man 命令的手册页有九个部分。第一个是本节中对我们来说最重要的，因为我们很可能是 shell 命令用户。但是，如您所见，第三部分是库调用。键入`man printf`，打印`printf`命令的用法。另一方面，如果你输入`man 3 printf`，它会打印出 C 语言的 Linux 程序员手册。

让我们跳到第八部分，这是为系统管理员编写的`xfs_copy`命令的手册。除了手动页面之外，许多可以安装在 Linux 上或随系统一起提供的命令，在硬盘文件系统的特定文件夹位置确实有额外的高级文档。对于某些程序，也可以使用特殊的安装包来安装其他文档，我们将在本节后面部分了解到这一点。有时，这些额外的文档包含如何使用程序的宝贵使用示例；关于使用的内部算法或方法的信息；更改日志和许可证信息；作者联系方式；历史；错误或限制的列表；或者示例配置文件，我们将在后面讨论。

如果您坚持使用手册，或者手册对您来说不够用，请尝试查看 CentOS 7 标准文档路径中是否存在您感兴趣的文档文件夹。例如，键入`postfix`文档文件夹所在的位置。这是一个很好的例子。如果你进入目录，你会发现很多文本文件格式的附加文档。有关更多信息，请参考以下屏幕截图:

![](assets/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)

使用 less 程序读取文件。使用与手册页相同的键盘快捷键来浏览文件，例如，键入 *q* 退出。

If you need more or advanced documentation, look into the `/usr/share/doc` folder and see if there's something available for you.

# 使用 Linux 外壳

在本节中，我们将学习如何在 shell 中高效地工作。我们将介绍一些重要的实践和技术，这些实践和技术将提高您的工作效率，并使您成为更快的 shell 命令黑客。这可以让你成为一个更快乐的人，因为最终，你将能够在壳里工作，感觉非常舒服。请注意，在这一部分，我们将向您展示许多键盘快捷键。学习键盘快捷键就像学习其他任何一门手艺一样，你慢慢地、循序渐进地开始，因为一次学习太多新技能会让你不知所措，比小块学习更容易让你忘记。我的建议是从学习前三到四个命令编辑快捷方式开始，然后一天一天或一周一周地融入更多内容。我们将从命令编辑快捷方式开始。现在，如果您根本不知道任何命令编辑快捷方式，让我们回顾一下您可能知道的关于如何在命令行中键入和编辑文本的内容。

移动光标位置的第一个快捷方式是可以使用左右箭头键，这有助于编辑您编写的文本，以在特定位置插入或删除字符。但是如果这是在 shell 中所能做的，那么在 shell 中工作将会非常低效，因为单字符光标移动非常慢。此外，每次执行一个带有输入错误的命令，或者命令需要以很小的差异重新运行，例如更改一个选项，完整的命令需要从头到尾重新输入。

为了提高效率，让我们为您的 Linux 日常工作介绍一些非常重要的命令编辑快捷方式:

*   要将光标移动到行尾，请使用 *Ctrl* + *E* 。
*   回到开头，分别按 *Ctrl* + *A* 、 *Ctrl* + *E* 、 *Ctrl* + *A* 。
*   要将光标移动到由空格或特殊字符(如点、分号或点)定义的下一个单词，请使用 *Ctrl* 和右箭头键向前移动。
*   要向后移动一个单词，在按住 *Ctrl* 键的同时使用左箭头键。也可以使用 *meta* + *F* 和 *meta* + *B* 进行同样的操作。
*   在大多数系统上，像任何普通的电脑键盘一样，没有元键，所以元键被映射到 *Esc* 或 *Alt* 键。

Using the *Alt* key in some terminal emulators such as the Xfce4 Terminal is reserved for menu accessibility. So, you first have to disable the *Alt* key as a menu shortcut in the preferences before you can use it as a shortcut.

*   要在当前位置和行首之间切换，按 *Ctrl* + *XX* 两次。
*   按 *Ctrl* + *K* 删除光标到命令行末尾的文本。
*   要删除光标到命令行开头的文本，请按 *Ctrl* + *U* 。使用 *Alt* + *D* 删除到单词末尾。

我们在这里刚刚讨论的所有命令编辑键盘快捷键只是您日常使用中最重要和最有效的快捷键，还有很多很多。

要获得所有 Bash 键盘快捷键的完整列表，请执行以下操作:

*   键入`man bash`，然后搜索要移动的截面命令
*   在此手册页中，搜索`Killing`
*   在此手册页中， *C* 键是 *Ctrl* 键， *M* 键是元键，破折号表示组合或按住两个键，正如我们之前使用 *Ctrl* + *A* 快捷键向您展示的那样

例如，`C-k`代表**删除线**，从点到线的末端删除文本。 *Alt* + *T* 交换单词，`M-u`让单词大写，`M-l`让单词小写。

现在，让我们转到命令完成快捷方式。最重要的命令完成快捷键是键盘上的 *Tab* 键。它会尝试猜测并自动完成您要键入的命令。它非常有用，大大加快了键入命令的速度，但是在使用该键时不要过度，如果没有替代选项，它只能打印完整的唯一命令名。键入`pass`并按下*选项卡*键；它将自动完成名称`passwd`，因为没有其他具有此全名的程序可用。键入`pa`并按下*选项卡*键；这将给你几个结果，因为找不到唯一的名字。键入`yp`并按下*选项卡*键；这将自动完成一个长名字，因为这是唯一可用的`variant`。*选项卡*短键默认自动完成命令；要自动完成其他内容，如文件名，请使用 *Alt* + */* 键。更多信息可以在 Bash 手册页的相应部分找到。

现在，让我们来看看命令调用的快捷方式。Linux 外壳有一个非常好的功能，那就是`history`命令。这是一个存储和检索所有输入到 shell 中的命令的系统。默认情况下，在 CentOS 7 系统上，会存储最后一千个命令。这个号码也可以更改。命令行历史记录是一个非常有用的功能，可以节省时间，因为它不需要重复键入，或者可以查看某个特定的命令在某段时间之前是如何执行的。要打印当前历史，输入`history`并按*进入*。如果要重新执行该列表中的命令，请使用感叹号和相应的数字。两个感叹号运行历史记录中的最后一个命令。另一个感叹号符号可以用来从历史命令中提取特定的参数。这将从`history`命令`166`中提取第三个参数，如下图所示:

![](assets/8a19d06c-e425-49dd-8361-beb6320793cd.png)

另一个非常有用的历史功能是回忆最后一个命令:

*   要浏览之前执行的历史命令，请按键盘上的向上箭头键。
*   要返回下一个历史命令，请使用向下箭头键。
*   要在历史记录中搜索命令，请按 *Ctrl* + *R* ，然后输入搜索关键字。
*   要循环显示结果，再次按下 *Ctrl* + *R* 。
*   要运行您找到的特定命令，请按*进入*键。

*   要快速插入前一个命令的最后一个参数，请使用 *Alt* +点。
*   另一个非常有用的特性是 shell 手动扩展一行，而实际上不必执行该行，这对于找出错误和盒子非常有用。这可以使用*Ctrl*+*Alt*+*E*来完成。

接下来，我们需要知道如何使用程序和流程。首先，我们将讨论如何中止任何正在运行的程序。如果您需要退出一个命令，因为它没有响应，或者您犯了一个错误，想要停止它，这一点很重要。例如，让我们键入`cat`命令，它将永远运行。让我们忽略这个命令目前正在做什么。这使得外壳没有反应，因为`cat`永远不会在我们外壳的最前端完成运行，并且永远运行。要返回 shell 提示符以便我们可以键入新命令并再次工作，我们需要在命令运行时退出命令。为此，我们可以在 shell 中使用一个特殊的组合键来退出当前的前台进程。按下 *Ctrl* + *C* 。

This is a very important key shortcut and it should be memorized: *Ctrl* + *C*.

您也可以暂停一个程序，这就像暂停它的处理并将其放入后台，这样您就可以再次在 shell 中工作。这可以通过以下方式实现:

1.  按 *Ctrl* + *Z* 。如果以后想继续前台运行的程序，输入`fg`并按*进入*。
2.  也可以在暂停时使用`bg`命令将其放在后台。现在程序在后台运行，你可以在前台工作。
3.  退出这个后台运行的程序最简单的方法就是把它放到前台，然后用 *Ctrl* + *C* 中止。
4.  下一个很有用的命令是按 *Ctrl* + *L* ，清除屏幕，效果和`clear`命令一样。
5.  我们将在这里学习的最后一个非常有用的命令是按下 *Ctrl* + *D* ，关闭 Bash 外壳。这类似于键入`exit`命令。

# 理解标准流

在本节中，您将了解为什么每个命令都可以使用三个标准流来访问其输入和输出。此外，您将学习如何处理这些输入和输出流，以及如何使用重定向。最后，我们将学习如何使用管道，以及它们为什么如此重要。Linux 操作系统的一个理念是，每个命令在系统中只有一个功能，不多也不少。例如，有一个命令列出文件，另一个命令对文本进行排序，还有一个命令打印文件的内容，等等。

现在，shell 最重要的功能之一是连接不同的命令，为各种问题和工作流创建定制的解决方案和工具。但是，在我们向您展示如何将不同的命令连接在一起以构建强大的东西之前，我们首先需要知道命令如何使用其输入和输出，以及什么是输入和输出重定向。大多数 Linux 命令在处理数据时遵循类似的模式。我们使用的大多数命令确实得到某种输入，例如，它们读取文件的内容，然后处理这些信息，然后几乎所有的命令都在计算机屏幕上输出某种结果。因为每个命令都使用某种输入，并在 Linux 上返回某种输出，所以定义了三个标准通道，每个命令都可以使用。它们用于在执行过程中操作系统和命令之间的通信。分别称为**标准输入**或`stdin`、**标准输出**或`stdout`、**标准误差**或`stderr`。

正常程序输出到`stdout`通道，而`stderr`也是一个输出流，它可以用来显示和处理命令执行时出现的任何类型的错误信息。这些也被称为**标准溪流**。它们被称为流，因为数据通过特定的通道连续流动，并由命令连续处理或生成，尽管它们有一个开放端，这意味着使用它们的命令无法预测数据流何时停止或结束。现在，我们可以使用某些文件更改`stdin`和`stdout`位置；这叫做**重定向**。

在本节中，我们还将解释管道的概念，以及如何使用它们，管道是 Linux shell 最基本的概念和主要特性之一。例如，如果您键入`ls /var/lib/system/`，结果随机种子将被打印到屏幕上，因为默认情况下，对于每个 Linux 命令，它都被定义为`stdout`设备。但是如果你输入`cat /var/log/messages`，一条错误信息会被打印到同一个屏幕上，因为`stdout`和`stderr`都连接到同一个输出设备，屏幕。

在 Linux 上，您的物理输入和输出设备，如键盘或屏幕，像任何其他硬件设备一样，是由特殊的系统文件抽象和表示的。所有这些特殊文件都驻留在名为`/dev`的系统目录中，该目录也称为**系统设备目录**。但是我们能用这样的系统做什么呢？它的妙处在于，我们可以将命令的输入和输出重定向到默认键盘和屏幕源或目的地之外的另一个位置，该位置也必须是 filetype。这对于将`stdout`和`stderr`分离到两个不同的位置也非常有用，如果命令产生大量输出，这尤其有助于保持命令的概览运行。

对于输出通道重定向，我们使用大于号( *>* )，对于输入重定向我们使用小于号( *<* )。要寻址特定的通道，如`stdin`、`stdout`、`stderr`，我们使用相应的数字`0`、`1`和`2`。使用输出重定向时，`stdout`通道是预期的，所以我们不必显式编写。对于 99%的情况，您只重定向`stdout`和`stderr`，所以让我们专注于那些例子。

要将命令的`stdout`流输出重定向到文件，请使用大于号。如前所述，`stdout`通道是预期的，所以最后一个命令也可以输入如下:

```
ls /var/lib/systemd/ > /tmp/stdout-output.txt
ls /var/lib/systemd/ 1> /tmp/stdout-output.txt  
```

使用`card`命令打印出我们刚刚创建的文件内容，重定向到`stdout`。要重定向`stderr`频道，请使用数字`2`作为标准流描述符。下面的屏幕截图显示了前面命令的输出:

![](assets/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)

如您所见，错误消息已被重定向到一个文件。要将`stdout`和`stderr`重定向到两个不同的文件，请键入以下屏幕截图中显示的命令:

![](assets/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)

另一种符号，使用*符号*字符，允许将一个通道重定向到另一个通道。要将`stderr`重定向到`stdout`通道，请键入以下屏幕截图中显示的命令:

![](assets/5754adbc-5759-4200-8c37-19fcac394707.png)

有时候，你只对一个输出流感兴趣，因此在任何一个 Linux 系统中都存在一个特殊的设备文件，叫做`null`设备，它消耗并消失任何一种被重定向到它的流数据到虚空中。例如，如果您不希望任何命令有任何输出，您可以使用下面屏幕截图中显示的命令:

![](assets/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)

最后，要重定向`stdin`，可以使用小于号[ `<` ]。例如，这可能非常有用，因为一些可用的 shell 命令可以直接读取文件的内容作为`stdin`，例如`grep`命令，我们将在后面了解该命令。

现在，让我们讨论管道。除了将命令的默认输入和输出流`stdin`、`stdout`和`stderr`重定向到文件，我们还可以使用 shell 管道的概念来获取一个命令输出作为另一个命令的输入。这个系统没有限制，很容易建立多命令链来回答你非常复杂的问题。如前所述，这个 shell 特性允许您创建非常强大的命令管道和工作流，为各种 Linux 命令行工作创建定制的解决方案，并为您回答非常复杂的问题。

为了将命令链接在一起，这意味着使用`stdout`从第一个命令作为`stdin`到下一个命令，我们使用键盘上的竖线符号[ `|` ]，在 Linux 中称为**管道**符号。例如，如果您有一个非常长的目录内容列表，您想在不永远滚动终端窗口的情况下阅读，您可以使用管道从`ls`命令输出目录内容，而不是在屏幕上，而是直接作为文件查看器的输入，正如我们之前所学的。通常，管道用于避免中间结果文件，没有它们会更高效。这方面的用例是无穷无尽的，例如，如果我们得到一个文件，其中有未排序的人名，我们可以使用`cat names.txt | sort`对它们进行排序:

![](assets/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)

您还可以获得该文件中所有唯一名称的列表。我们将使用 unique 命令来实现这一点，该命令仅适用于排序列表。所以，我们需要使用`cat names.text | sort | uniq`进行排序:

![](assets/729cab59-0336-4c7a-a106-a3cd9c908b25.png)

您也可以使用字数统计命令行工具使用`cat names.text | sort | uniq | wc`来统计唯一的行数:

![](assets/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)

这个文件中有很多独特的名字。说到管道的例子，天有不测风云，而且例子太多了。理想情况下，这应该使用`root`用户帐户运行。请忽略错误。下面的屏幕截图显示了文件系统的核心摘要:

![](assets/72686415-4aae-4ceb-ac5d-9819e377693e.png)

另外，另一个有用的管道命令是打印出目录中使用过的文件。如果您使用的是 Windows 系统，您可能知道一个名为 ZIP 的实用程序，它可以压缩文件。在 Linux 上，您可以做一些非常相似的事情，但是这里我们需要两个工具一起工作。对于压缩，我们使用`gzip`工具。因为`gzip`只能处理单个文件，所以我们首先需要创建一个将多个文件连接成单个文件的归档。对于归档，我们使用`tar`命令。因此，要在`/tmp`目录中创建主目录的压缩存档，首先使用`tar`命令:`tar -cv /home/olip/ | gzip`创建主目录的存档。档案将被输出到`stdout`流，因此我们将其作为`stdin`输入到`gzip`命令中。由于 gzip 本身将压缩文件输出到`stdout`，我们将把它重定向到一个文件。压缩与未压缩数据量的对比结果如下:

![](assets/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)

这本书将会展示更多管道的例子。如果将`stdout`或`stderr`重定向到一个文件中，如果该文件已经存在，通常会被删除，或者在写入任何内容之前会创建一个新文件。为了不删除文件，而是追加内容，使用大于号。例如，要创建新的输出文件，请执行下面屏幕截图中显示的命令:

![](assets/47b8f3be-2e24-459d-a657-e025a89885db.png)

现在，要将字符串`Hello World`追加到输出文件中，我们将使用大于号。当我们开始将内容重定向到文件时，这不会删除文件的内容。相反，它会将内容附加到文件的末尾。如前所述，管道是外壳最重要的概念之一，使用它们非常有趣。

# 理解正则表达式

在这一节中，我们将介绍正则表达式的奇妙艺术。你会了解他们是什么，为什么他们如此强大。有很多不同的正则表达式字符可用，这里我们将介绍最重要的。之后，您将学习如何使用`grep`命令应用正则表达式来查找、提取和过滤文本文件中的有用信息。**正则表达式**，简称 **regexps** ，是一个非常强大的概念，用于使用特殊模式搜索文本，描述搜索词的结构，而不是一个恒定的字符串，在本文中也称为**字面文本搜索**。通过不做重复的工作，使用正则表达式可以节省很多时间，Linux 系统管理员在日常工作中会大量使用它们。

在*文件环球化*部分，当我们使用环球化字符寻找模式来处理带有一些特殊字符的多个文件名时，我们学到了一个非常相似的概念。正则表达式是一个更强大的工具；它们包含一组非常广泛的各种特殊字符，用于完全或部分匹配最复杂的文本片段。在 Linux shell 中，我们使用正则表达式不是为了 shell 扩展或对文件名进行分组，而是为了处理文本文件的内容或文本行的字符串，以解析和分析它们的内容或从中提取文本特征。如前所述，正则表达式是一个非常复杂的主题，我们只能在这里给你一个概述。请注意，有几种样式的正则表达式可用，例如 Perl 正则表达式。在我们的示例中，我们将使用 POSIX、basic 和扩展正则表达式，正如大多数 shell 工具所使用的，例如`greb`、`sed`和`awk`。有很多不同的正则表达式字符可用，也称为**元字符**。

由于其中一些元字符是扩展的 POSIX 字符，我们需要在扩展模式下启动我们的正则表达式处理命令。

一些扩展表达式如下:

*   `n`用于匹配行尾。
*   `t`匹配顶部的空格。
*   插入符号`^`与行首匹配。
*   美元`$`符号与行尾匹配。
*   `[x]`和 globbing 括号很像，你之前学过。这描述了要在括号内特定位置匹配的字符类别。您也可以在这里定义字符范围。
*   `[^x]`匹配括号中未定义的所有字符。
*   括号用于分组；这将把文本保存在括号中，以便以后进一步引用。
*   `1`为数字，用于反向参考。这将获得从括号中提取的引用的编号 *n* ，这是我们之前向您展示的。
*   `a|b`表示在这个位置 *a* 或 *b* 是允许的。
*   `x*`表示在该位置匹配零次或多次出现的 *x* 字符。
*   `y+`表示在此位置匹配一个 *y* 字符的一次或多次出现。
*   点表示在特定位置匹配任何字符。

知道很多使用正则表达式的工具，比如`sed`、`awk`，期望正则表达式被斜线包围也是非常重要的。另外，脚本语言 Perl 也采用了这种风格。在其他工具如`grep`中，不需要使用斜线符号。

让我们首先使用命令`grep`来实验我们的新正则表达式概念。我们使用`egrep`命令行工具在扩展模式下启动 grep。不用运行`egrep`命令，也可以用大写`-E`选项运行`grep`命令，效果一样。`grep`是一个逐行遍历文本文件或输入流的命令，并尝试将给它的搜索模式参数匹配到每一行。如果一条特定的线与图案匹配，它将打印出完整的线。这对于各种文本提取都非常有用，`grep`是 Linux 上最重要的命令行工具之一。事实上，我不记得有一天在壳里工作的时候我根本不用它。通常，`grep`被用作过滤器，作为更大管道命令工作流的一部分，以减少您想要进一步处理的巨大输出文本。

首先，如前所述，我们将使用 POSIX `regex`。存在很多不同的正则表达式术语，太多太难背，所以每次需要查语法的时候，输入`man 7 regex`。在本手册中，您将找到关于正则表达式所需了解的一切。

让我们开始从文件中提取各种信息。我们将从使用没有正则表达式的`grep`命令开始，而是搜索简单的文本文字`grep root /etc/passwd`。这会返回`passwd`文件中包含单词`root`的所有行。输出中的任何一行都给我们提供了它所属的`root`用户的分组信息。如您所见，grep 遍历整个文件，并在任何位置找到包含字符串`root`的所有行。一个非常有用的`grep`选项是`-i`。这可用于忽略搜索词的大小写敏感性。比如执行`grep -I root /etc/services`。这会找到`root`这个词的所有出现，而忽略这个情况。这也将找到单词`root`的所有其他情况排列。当使用正则表达式作为`grep`、`sed`或`awk`等命令的参数时，建议使用*单引号*引用您的元字符。这是因为一些正则表达式字符与 shell globbing 字符是相同的字符，例如通配符，这是不好的。Shell 扩展总是在任何参数被输入到任何命令之前发生，因此使用不带禁用通配符的正确命令将搜索包含您要搜索的特定文件中所有文件名的字符串。

相反，始终将正则表达式元字符放在单引号中。此外，如果您想在文件中搜索与正则表达式元字符相同的文字特殊字符，您需要转义该字符，这类似于我们在*文件全局化*部分使用反斜杠键学习的内容。下面的截图说明了本节开头提到的每个元字符的一个例子:

![](assets/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)

美元符号在行尾匹配，因此这将打印出所有以服务文件中的数据结尾的文件。同样，我们使用插入符号`^`来匹配行首。以下命令匹配所有以单词`day`开头的行:

![](assets/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)

方括号表达式是括在方括号中的字符列表。它通常在特定位置匹配列表中的任何单个字符。您也可以使用破折号定义方括号中的范围，类似于我们在*文件球形化*部分中显示的范围。如果括号中的列表以插入符号开头，则它与列表其余部分以外的任何单个字符匹配。普通括号可以用来保存匹配的引用。为了回溯引用，我们使用括号表达式的`/number`，以便正则表达式匹配以第一个字母开始的所有行，例如`egrep 't(ac)1*s' /etc/services`。管道符号代表*或*，因此下一个表达式匹配包含**域**或**地鼠**的所有行。点匹配特定位置的任何字符。加号表示匹配前面零次或多次出现的字符，因此该正则表达式匹配所有包含`at-`的行，但不匹配行尾。星形元字符匹配之前字符的一个或多个出现，因此这里的`egrep 'aa+' /etc/services`表达式匹配包含至少两个或更多`aa`的所有行。加号字符匹配前面字符的一次或多次出现，因此此处的正则表达式匹配所有行。

如前所述，点匹配特定位置的每个字符，因此正则表达式匹配包含与表达式中的点数量相对应的字符数量的所有行。`grep`有很多有用的选项，例如，`-v`反转搜索匹配，这意味着打印所有根本不包含搜索模式的行。我经常使用这个选项来删除许多配置文件中的所有空行和命令行，这些文件以 shell 脚本文件中的 hashtag 开始。例如，执行下面屏幕截图中显示的命令:

![](assets/43c20227-c279-46f3-a1f7-9f1422d30d33.png)

手册包含许多命令行，以标签和空行开始。要过滤掉所有这些不需要的行，请使用`grep -v`选项。另一个有用的特性是`grep -o`选项，它只打印匹配的图案，而不是完整的线条。例如，`egrep 'netbios-...' /etc/services`打印出完整的行，而`-o`选项只打印模式中的纯 NetBIOS 名称。

# 与 sed 合作

在本节中，我们将了解强大的流编辑器`sed`命令。我们将向您简要介绍`sed`的工作原理，并向您展示自动替换文本和文件的替换模式，这是可用的最重要模式之一。接下来，我们将学习`sed`命令。让我们首先检查它的语法:

```
sed [OPTION] 'pattern rule' FILE  
```

`sed`代表**流编辑器**，该命令可以自动编辑文件，无需任何用户交互。它逐行处理输入文件。通常，`sed`在 shell 脚本中用于将任何命令的输出转换为所需的形式，以便进一步处理。`sed`的大多数日常用例遵循类似的模式，以最简单的形式，首先与正则表达式或其他模式一起使用，以定义输入文件或流中要更改的行，然后提供如何更改或转换匹配行的规则。类似于`grep`命令，在使用`sed`时始终使用单引号，除非您需要在`sed`表达式中使用环境变量，否则您应该使用双引号。通常`sed`从`stdin`读取，内部处理流，并将文本的转换版本输出到`stdout`。因此，它被理想地用在`pipe`命令中，因此它通常是管道的一部分。`sed`可以用于很多不同的用例。

使用地址范围的一个非常简单的例子是`d`选项，删除，这也有助于您理解`sed`是如何处理输入和输出流的。同样，`cat /etc/services | sed '20,50 d'`使用`cat`将`etc/services`文件流传输到`sed`。`sed`逐行处理输入流，这里，所有不在第 20 行到第 50 行之间的行被直接处理到`stdout`通道，而第 20 行到第 50 行被完全抑制。您也可以使用带有`d`选项的正则表达式。使用`sed`时，请记住将任何正则表达式放在斜线中。`sed`命令忽略所有以哈希符号开始的行，但它会将所有其他行打印到`stdout`。有很多不同的选项和模式可以工作，但这里要提到的太多了。

`sed`最重要的用法肯定是替换模式，可以用来自动进行文件或文本编辑，无需任何用户交互。它的一般语法是:`sed 's/search_for_text/replace_with_text/' FILENAME`。这将在文件文件名中搜索第一个斜杠之间的模式，可以是正则表达式或文字表达式，并且当且仅当该模式与该文件中某行的文本匹配时，它将被另一个斜杠之间的文本替换。这仅适用于文件中的第一次出现。如果需要替换文件中所有出现的搜索文本，必须使用斜杠表达式末尾的`g`选项。例如，将`passwd`文件中的单词`root`替换为单词`King_of_the_Jungle`，每次出现时，执行如下截图所示的命令:

![](assets/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)

如果您正在搜索任何包含斜杠的内容，您可以使用不同的模式分隔符来转义常规替换用法，因为否则您将需要转义您要搜索或替换的斜杠字符，它可能看起来非常复杂和非结构化。这也可以写成`sed 's:XX:YY:g' FILENAME`，或者你选择的任何其他字符。所以举个例子，如果你想在一个文件中用双斜线代替单斜线，而不是用`sed 's//////g' FILENAME`，那么用`sed 's:/://:g' FILENAME`，或者`sed 's#/#//#g' FILENAME`就更干净了。使用没有任何`sed`选项的替换模式将始终打印转换后的文本到`stdout`。有时，直接更改输入文件中的文本很有用。这可以使用`sed -i`选项或内嵌选项来完成。

在下面的例子中，我们将处理一份`passwd`文件，向您展示如何进行就地编辑。为此，请执行以下步骤:

1.  在`/tmp`目录下创建`passwd`文件的副本，如下图截图所示:

![](assets/140e3682-1a00-4c39-acce-e0199bc574f8.png)

2.  让我们首先显示包含单词`root`的所有行。
3.  接下来，仅在`stdout`上用随机文本替换文件中的单词`root`。执行以下命令:

```
sed 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd | less  
```

4.  现在要就地编辑文件，使用`-i`选项:

```
sed -i 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd
less /tmp/test-passwd  
```

该文件已被永久更改。使用此选项时请小心，因为如果您以前没有测试过您的替换，并且您犯了一个错误，您将无法恢复您的更改。最好在应用就地编辑之前创建原始文件的备份副本，这可以使用`sed -i`选项来完成，例如`sed -i.bak 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd`。如果您在`-i`选项后面写了一个新的扩展名，如`.bak`，它将在将正则表达式应用到原始文件之前创建一个扩展名为`bak`的备份副本。在替换模式下处理这些正则表达式时，我们之前向您展示的分组和反向引用功能使替换变得非常强大，因为这使您能够真正控制输入文本所需的更改，例如，`passwd`文件包含冒号作为字段分隔符，一个冒号分隔一个字段。反向引用时使用 sed，我们可以用四个冒号替换一个冒号:

![](assets/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)

`grep`、`sed`和`awk`使用的 POSIX 扩展正则表达式也在括号中定义了许多非常有用的特殊字符类，这在模式匹配中非常有用。一般语法是`grep '[:digit:], [:space:], [:blank:]'`。数字括号字符类匹配特定位置的所有数字。空格匹配所有空格，空格匹配所有空格，如*制表符*空格，空格匹配所有空格。要匹配`etc/passwd`文件中包含数字的所有行，请使用`grep '[[:digit:]]' /etc/passwd`。有关所有特殊字符类别的列表，请使用`man 7 regex`手册。

# 使用 awk

在本节中，我们将向您展示`awk`命令的全部内容，以及为什么它对我们很重要。我们还将向您展示如何使用它来处理文本文件。`awk`是另一个非常重要的文本处理和操纵工具。它可以作为一种完整的脚本语言来处理文本文件或流。它包含一些非常强大的编程结构，包括变量: *if...否则*、*边*、*边做边*和*进行*循环；数组；职能；和数学运算。`awk`也像`sed`一样逐行工作。`awk`的一个关键特性和`sed`的主要区别在于它自动将输入行分割成字段。但是它是如何工作的，为什么这么有帮助呢？

`awk`使您能够创建规则和操作对，并且，对于匹配此规则或条件的每个记录，操作都将触发。这些规则也被称为**模式**，相当强大，可以使用**扩展正则表达式**。动作的语言类似于编程语言 c。使用`awk`符号范式在输入中找到一个模式，然后应用某种动作，通常会将复杂而繁琐的数据操作任务减少到几行代码，甚至一行代码。`awk`还允许您创建和执行强大的`awk`脚本文件，以自动执行具有挑战性的文本转换任务，但是在本节中，我们将只关注在命令行上使用`awk`选项和参数。请注意，由于`awk`是一个完整的脚本语言，有很多特性和选项，这里只能给大家展示最重要的用例和例子。

这是任何`awk`命令的基本结构:`awk [pattern] { action }...INPUTFILE`。需要注意的是，这些动作必须用大括号括起来。这也可以理解为:逐行检查输入文件，并尝试将模式应用于每一行。如果且仅当模式匹配或规则可应用于该行且为真，则将执行花括号之间的操作。

学习和理解`awk`工具最简单的方法就是不用任何规则或模式使用它，只定义一个简单的动作。在没有给它一个模式的情况下，该操作将应用于任何输入行。如前所述，`awk`将每个输入行完全分割成字段，因此我们可以使用以下符号直接访问操作参数中的那些字段。像往常一样，动作和模式应该放在单引号中:

```
awk '{print $1}' /etc/networks  
```

这将打印出`etc/networks`文件所有行的字段`1`。如您所见，该操作必须用花括号括起来。`$number`是场数，`$0`是完全线。您现在可能已经知道，`awk`默认情况下会在每个空白位置拆分。您可以使用`-f`选项更改字段分隔符。例如，要正确分割以冒号作为字段分隔符的`passwd`文件，可以使用冒号指定字段分隔符`-f`。这将打印出`etc/passwd`文件的第一个字段和用户名:`awk -F: '{ print $1 }' /etc/passwd`。您也可以使用 awk `printf`函数，它打印出格式化的文本，您可能从其他编程语言中知道:`awk -F: '{ print "user: %stgroup: %sn", S1, S3 }' /etc/passwd`。`%s`将由字段编号代替。`t`制作一个*制表符*字符，`n`制作一个新的行字符。

现在，是时候测试一些模式了。正如我们之前所说的，如果您定义了一个模式或规则，它也可以是一个扩展的正则表达式，它将应用于每一个输入行，并且只有那些匹配规则的操作才会被执行。

以下命令将打印出所有行中的第一个字段，并且只打印行，从`etc/services`文件中的小`t`开始。这里我们将把它输入到`head`命令中，将输出减少到只有前 10 行:

![](assets/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)

使用`awk`命令时，请记住将任何正则表达式放入斜线。awk 最大的特点之一是模式不仅仅是一个简单的正则表达式。例如，您也可以在这里使用字符串和数学比较运算符。这将帮助您用几个微小的表达式来回答非常复杂的文本操作问题:

![](assets/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)

在上例中，`awk`只输出来自`etc/passwd`文件中用户的行，这些行的组标识大于`500`。大于号是运算符。还有很多其他的运营商可以利用，但是这里要提到的太多了。例如，要匹配正则表达式，请使用`awk '$1 ~ /netrjs/ {print $0}' /etc/services`。波浪号是正则表达式匹配运算符。要匹配字符串，请使用等号两次，`awk '$1 == "netrjs-4" {print $0}' /etc/services`。要获得所有 awk 操作符的列表，请在手册页中搜索操作符。还有`awk`有两种特殊的图案，分别叫做 **BEGIN** 和 **END** 。与任何其他模式一样，您可以为开始和结束模式定义一个操作，这将只在文件的开头或结尾触发一次。我们可以用它来打印出目录中的总字节数:

![](assets/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)

这个`awk`命令是这样工作的:首先，它使用了一个名为`SUM`的变量，这个变量就像一个容器，用于我们的数字计数。`+=`是一个数学运算符，它将字段号`5`添加到我们的容器`SUM`中，这样这个动作就会从每行的字段`5`中的单个字节号开始计算总字节数。此外，在每一行，我们打印出整行内容，一旦我们到达文件的末尾，将触发结束模式，这将打印出我们的`SUM`变量的内容，该变量保存该目录中的总字节数。正如您刚刚看到的，我们可以定义自定义变量来保存我们想要拥有和使用的值。awk 中还有许多预定义的变量名，其中包含非常有用的信息。例如`NR`变量名包含当前行号。这在以下`awk`命令中很有用:

```
awk '{printf "Line number: %st%sn", NR, $0}' /etc/passwd  
```

这将使用`NR`变量在输出的每一行前添加行号，该变量包含每行中的当前行号。有关所有特殊 awk 内置变量的列表，请使用手册并搜索变量。

awk 包含许多非常有用的预定义函数来使用，例如我们已经从动作语句中知道的`print`或`printf`函数。要在一个动作块中执行多个功能，可以使用分号。例如，awk 包含许多非常有用的字符串操作函数，如`toupper (argument)`函数。awk 中的函数与大多数其他编程语言中的函数一样工作。使用函数名调用它，然后在括号中添加一个或多个参数。例如，我们在 awk 动作中使用`print`和`printf`功能。例如，在 awk 中有一个名为`toupper`的字符串函数，它将每个字符串参数转换为大写字母。

以下是使用`toupper`函数的完整的`awk`命令行示例:

![](assets/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)

这将正常打印出`passwd`文件中的第一个字段，然后用大写字母再次打印。我们的最后一个示例将向您展示如何使用分号作为表达式分隔符在一个操作语句中执行多个表达式或函数:

![](assets/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)

此外，您可以在这里看到，您可以将任何函数的返回值分配给一个变量名，然后稍后引用该变量名，因此该示例与之前的示例非常相似，首先打印出大写版本，然后是正常的小写版本，然后是正常的字段值版本。对于所有可用的 awk 函数，我们使用手册并搜索函数、数值函数、字符串函数、时间函数等等。

# 浏览 Linux 文件系统

在本节中，您将学习如何浏览 Linux 文件系统。您还将了解 Linux 文件系统是如何构造的。如果我们通过执行`tree -d -L 1 /`命令打印出根目录下顶层目录的文件夹结构，你会看到一个听起来很奇怪的目录名列表。这些目录名在任何 Linux 发行版上都是相同的，它们遵循一个称为**文件系统层次标准** ( **FHS** )的标准。Linux 文件系统中的每一个标准目录都有特定的用途，用户可以在特定的位置看到特定的文件，这也意味着程序可以预测文件的位置，这也意味着任何使用这些系统目录的程序都可以预测文件的位置。以下是目录:

*   `/`斜线是主层级根。
*   `/bin`包含系统所需的基本命令，例如，当系统出现故障时，用户可以在系统的恢复模式下工作，或者，例如，当用户启动进入恢复模式时，用户需要的可执行文件。
*   `/boot`包含引导所需的文件，如内核文件。
*   `/dev`包含系统的设备文件，比如我们之前用过的`/dev/null`。该目录非常重要，当您作为系统管理员工作时，您会经常使用它。它包含系统上安装的所有应用程序的系统范围配置文件。
*   `/home`包含用户的主目录，正如我们在本节中所了解的。
*   `/lib`包含`/bin`和`/sbin`中二进制文件所必需的库，我们将在下面看到。`/lib64`包含 64 位架构的替代格式基本库。
*   `/media`包含光盘等可移动介质的挂载点。
*   `/mnt`包含临时安装的文件系统。
*   `/opt`包含可选的应用软件包。
*   `/proc`包含虚拟文件系统，提供进程和内核信息作为文件，例如，这是存储当前会话的所有环境变量的地方。
*   `/root`包含`root`用户的主目录。根用户的主目录不在`/home`。
*   `/run`包含运行时变量数据；这是自上次引导以来运行系统的信息。
*   `/sbin`包含必要的系统二进制文件。
*   `/srv`包含系统应该服务的所有数据，例如，web 服务器的数据和脚本，或者系统上作为服务运行的 FTP 服务器提供的数据。
*   `/sys`包含连接到系统的设备的信息。
*   `/tmp`包含临时文件。每个用户都可以完全访问这个目录。
*   `/usr`包含了大部分所有的用户实用程序和应用程序，例如，一个用户安装的所有应用程序都进入这里。它也被称为只读用户数据的**二级层次结构**；因为它与根目录、顶级目录具有相似的结构。例如，您还有一个`/usr/bin`目录、一个/ `usr/lib`目录、一个`/usr/sbin`目录等等。
*   `/var`目录是指在系统正常运行过程中，预期会不断变化的所有文件，例如日志文件、假脱机文件和临时电子邮件文件。

首先，让我们介绍一下 Linux 主目录的概念。Linux 系统中已知的每个用户在文件系统中都有自己的私有位置，在那里他们可以管理自己的数据，并拥有对所有内容的完全访问权限，例如，创建目录或新文件、删除内容或更改权限。出于安全原因，除了少数例外，Linux 文件系统中的大多数地方，如系统`/tmp`目录，都以这样或那样的方式受到限制，通常只有`root`用户对所有内容拥有完全访问权限，登录用户才能对其拥有完全访问权限。每个登录的用户都有一个当前目录的属性，也就是您当前所在的目录。当用户登录到 Linux 系统时，默认情况下，他们的特定主目录将被设置为当前目录，因此他们将在此目录中启动。

要显示当前目录的名称，也就是你现在所在的位置，输入`pwd`，然后按*回车*键。pwd 代表**打印工作目录**。这是一个非常有用的命令，因为当你浏览目录时，很容易迷路。目录是一个构造数据的概念。通常，它用于对属于同一项目或同一类型的所有文件进行分类，例如所有配置文件。如您所见，`pwd`命令的输出包含一个包含斜杠符号的字符串，用于分隔目录名，这也称为**目录分隔符符号**。最左边的斜线有一个特殊的名字，也叫**根目录**。当前目录的最后一个目录名也可以在 shell 提示符下看到。在 Linux 文件系统中，每个目录都可以包含文件，并且可以包含更多的目录，这些目录被称为子目录。这些子目录还可以包括文件和文件夹等等。包含子目录的目录也称为父目录，而子目录称为**子目录**。这里，在我们的例子中，主目录是`olip`目录的父目录，也称为子目录。这些类型的文件和文件夹可以使用树状结构可视化，这也可以称为分层文件系统，因为该结构中的每个目录都有一个特定的位置，一些在分层结构中较高，另一些较低。最高的目录是`/`目录，或`root`目录。我们需要记住可视化这种层次树结构。我们可以使用`tree`命令，我们需要安装它，因为它在标准安装中不可用。要安装它，请使用您在安装过程中设置的`root`密码。

安装后，您可以使用`tree`命令获得系统的第一个概述。在顶层我们有`/`目录，它是树中最高的目录。在它的正下方，我们有许多系统目录。当我们通过执行`tree -d -L 2 / | less`定制`tree`命令来显示树中的两个目录级别时，我们可以看到树中的主目录在哪里，以及我们如何从根目录访问它，根目录是所有其他目录的父目录。现在，要在主目录中创建新目录，可以使用`mkdir`命令。`mkdir`命令以您想要创建的文件夹的名称作为参数。要删除空目录，请使用`mrdir`命令。要创建新的空文件，请使用`touch`命令。要删除文件，请使用`rm`命令。

现在，让我们重新创建文件夹和文件名。要更改目录，可以使用`cd`命令，代表**更改目录**。“更改目录”命令会将您当前的目录更改为新目录，您将该目录用作`cd`命令的参数。再次使用`pwd`对此进行测试。下面的截图说明了这一点:

![](assets/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)

在 Linux 中，当我们说转到一个目录时，我们真正的意思是通过使用`cd`命令使另一个目录成为我们当前的目录。如前所述，每个目录都包含两个特殊的速记链接，您不能更改也不能删除，`.`和`..`，这是我们当前所在目录的名称。每个目录都包含名称`..`，这是我们当前所在目录的唯一父目录的名称。此外，每个子目录只包含一个父目录，而一个父目录可以包含多个子目录。这些点对于快速浏览目录非常有用。回到前面的目录，在我们的例子中是主目录，我们可以使用`..`符号。要在子目录中的子目录中创建子目录，我们可以使用以下方法:

![](assets/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)

要查看我们刚刚创建的文件夹结构，我们可以再次使用`pwd`命令。要上一级目录，我们可以使用`cd..`。要返回下去，使用`cd FolderD`。现在，要进入两级目录，可以使用文件夹分隔符斜杠符号- `cd ../ ../`。要返回子目录结构中的两个级别，我们还可以使用文件夹分隔符斜杠符号。当遍历目录时，总是有很多方法可以做到这一点。要快速返回主目录，我们可以使用几种不同的方法。要先返回主目录，可以使用一些快捷方式。正如我们之前提到的，波浪号代表主目录，所以我们可以很容易地回到主目录`cd ~`。波浪号在任何地方都可以工作，所以你可以从你所在的任何目录回到你的主目录。另外，一个非常有用的快捷方式是`cd -`，它可以让你在当前目录和你之前所在的目录之间切换。

甚至有一种更短的方法可以从每个位置回到你的主目录，只使用`cd`命令，没有任何参数。另一种从每个位置进入主目录的方法是直接使用`pwd`命令输出的路径。要删除包含子目录或文件的目录结构，不能使用`rmdir`命令。要删除包含文件和目录的目录子树，我们需要使用`rm -rf`选项，但请谨慎使用，因为这将在没有询问的情况下删除所有内容，这是完全不可逆的。

要重新创建相同的子目录结构，正如我们之前以简单得多的形式向您展示的那样，我们可以将目录分隔符符号与`mkdir -p`选项一起使用。到目前为止，我们对文件和文件夹的所有操作和动作，如`ls`、`mkdir`或`mrdir`，都始终与当前目录相关，这意味着如何转到所选目录或文件的描述始终与当前目录相关。例如，我们使用命令来处理当前目录中的文件和目录。为了引用当前目录之外的文件和文件夹，我们使用`..`和斜线目录分隔符。

如果我们想在同一个目录下处理文件和目录，我们只需要资源的名称。如果我们想访问当前目录之外的资源，我们可以使用目录分隔符和`..`符号来访问正确的文件或目录。现在，让我们再次执行`pwd`命令。`pwd`命令的输出称为**绝对**或**全路径**。正如您现在所知，从前导正斜杠(称为根目录)中可以很容易地识别出绝对路径。斜线符号表示您从顶层目录或根目录开始，向下继续。绝对路径实际上是整个层级中的名称路径。路径名指定并描述了如何遍历或导航文件系统中的分层目录名，以从最高根目录(可以是文件或目录)开始到达某个目标对象。完整路径始终包含如何从根目录到文件系统中任何目标的完整信息。换句话说，要进入当前目录，也就是所谓的`/home/olip/FolderA`，你必须遍历，从`/root`目录，到`home`目录，到`olip`目录，再到`FolderA`目录。要在树状结构中可视化这一点，请将`tree`命令与子目录 **L 3** 一起使用:

![](assets/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)

重要的是要记住绝对路径在任何地方都有效。相对路径没有前导斜杠。使用相对路径，例如，更改为`FolderA`，总是取决于您此刻在文件系统中的位置。所以，`cd FolderA`只在你目前的岗位上有效。如果您在其他地方重新执行该命令，它将不起作用。当使用任何适用于文件或目录的 Linux 命令时，您总是可以选择使用相对于当前目录的本地路径，或者使用相对于根目录的完整绝对路径。通常情况下，相对路径使用起来更快，而且更改到您想要直接处理的文件的目录也很方便。但是绝对路径对于脚本或者命令是否需要在每个目录下工作是很重要的。

# 摘要

在本章中，我们首先介绍了命令行、文件全局化和引用命令。通过使用 shell、标准流和正则表达式，我们朝着实际执行的方向前进。我们还介绍了`sed`、`awk`和 Linux 文件系统的功能。

在下一章中，我们将讨论与文件相关的概念。