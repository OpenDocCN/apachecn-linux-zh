# 第五章。 Linux 二进制程序保护

在本章中，我们将探讨 Linux 程序混淆的基本技术和动机。 混淆或加密二进制文件或使其难以篡改的技术称为软件保护方案。 通过“软件保护”，我们指的是二进制保护或二进制加固技术。 二进制加固并不是 Linux 独有的; 事实上，在这一技术类型中有更多的 Windows 操作系统产品，而且肯定有更多的例子可供选择。

许多人没有意识到的是，Linux 也有这样的市场，尽管它主要是为政府使用的防篡改产品而存在。 在过去的十年中，黑客社区还发布了许多 ELF 二进制保护程序，其中一些为今天使用的许多技术铺平了道路。

可以有一整本书专门介绍软件保护的艺术，而且作为最近一些 ELF 二进制保护技术的作者，我很容易被这一章弄得忘乎所以。 相反，我将坚持解释基本原理和一些有趣的技术，使用，然后一些见解到我自己的二元保护-**玛雅的面纱**。 二进制保护中复杂的工程和技巧使它成为一个难以表达的话题，但我将在这里尽我所能。

# ELF 二进制封隔器-哑保护

一个**封包器**是一种软件，通常被恶意软件作者和黑客用来压缩或加密一个可执行文件，以混淆其代码和数据。 一个非常常见的封包名为UPX([http://upx.sourceforge.net](http://upx.sourceforge.net))，在大多数 Linux 发行版中都可以作为包使用。 这种类型的封隔器的最初目的是压缩可执行文件并使其更小。

因为代码是压缩的，所以在内存中执行之前必须有一种解压的方法——这就是有趣的地方，我们将在*存根机制和用户域执行*部分讨论它是如何工作的。 无论如何，恶意软件作者已经意识到压缩他们的恶意软件感染的文件将逃避 AV 检测由于混淆。 这导致恶意软件/反病毒研究人员开发了自动解包器，这现在被大多数，如果不是全部，现代反病毒产品中使用。

如今，术语“打包二进制文件”不仅指压缩的二进制文件，还指加密的二进制文件或用任何种类的混淆层屏蔽的二进制文件。 自 21 世纪初以来，已经出现了几个显著的 ELF 二进制保护程序，它们塑造了 Linux 二进制保护程序的未来。 我们将探索其中的每一个，并使用它们来建模用于保护 ELF 二进制文件的不同技术。 不过，在此之前，让我们看看存根如何加载和执行压缩或加密的二进制文件。

# 存根机制和用户域执行

首先，有必要了解一个软件保护程序实际上是由两个程序组成的:

*   **保护相位码**:对目标二进制应用保护的程序
*   **运行时引擎或存根**:与负责在运行时解混淆和反调试的目标二进制文件合并的程序

保护程序可以根据应用到目标二进制的保护类型而变化很大。 运行时代码必须理解对目标二进制文件应用的任何类型的保护。 运行时代码(或存根)必须知道如何解密或消除与之合并的二进制文件的混淆。 在大多数软件保护的情况下，有一个相对简单的运行时引擎与受保护的二进制文件合并; 它的唯一目的是解密二进制文件，并将控制传递给内存中解密的二进制文件。

这种类型的运行时引擎并不是真正的引擎，我们称它为存根。 存根通常编译时不带任何 libc 链接(例如，`gcc -nostdlib`)，或者静态编译。 这种类型的存根，虽然比真正的运行时引擎简单，但实际上仍然相当复杂，因为它必须能够从内存中`exec()`一个程序——这就是**用户地执行**发挥作用的地方。 我们可以感谢 grugq 在这里的贡献。

通常由`glibc`包装器(例如`execve`、`execv`、`execle`和`execl`使用的`SYS_execve`系统调用将加载并运行一个可执行文件。 在软件保护的情况下，可执行文件是加密的，并且必须在执行之前解密。 只有经验不足的黑客才会编写他们的存根来解密可执行文件，然后把它以解密的形式写入磁盘，然后再用`SYS_exec`来执行它，尽管原来的 UPX 封隔器确实是这样工作的。

完成这一任务的熟练方法是在适当的地方(在内存中)解密可执行文件，然后从内存中加载并执行它——而不是一个文件。 这可以从用户区代码中完成，因此我们将此技术称为用户区执行。 许多软件保护程序实现了一个存根来实现这一点。 实现存根用户区执行器的挑战之一是，它必须将段加载到其指定的地址范围中，这通常是为存根可执行文件本身指定的相同地址。

这只是 et_exec 类型的可执行文件的问题(因为它们不是位置独立的)，而且通常可以通过使用自定义链接器脚本来克服这个问题，该脚本告诉存根可执行文件段在默认地址以外的地址加载。 在第 1 章，*的 Linux 环境及其工具*中关于链接器脚本的一节中展示了这样一个链接器脚本的例子。

### 注意事项

在 x86_32 上，默认基数是 0x8048000，在 x86_64 上，默认基数是 0x400000。 存根应该具有与默认地址范围不冲突的加载地址。 例如，我最近编写的一个链接使得文本段在 0xa000000 处加载。

![Stub mechanics and the userland exec](../images/00012.jpeg)

图 5.1:一个二进制保护存根模型

图 5.1 直观地显示了加密的可执行文件是如何嵌入到存根可执行文件的数据段中，并被封装在其中，这就是为什么存根也被称为包装器。

### 注意事项

我们将展示在*确定保护 binarires*部分第六章,*精灵二进制取证在 Linux 中*如何剥去一个包装器可以是一个微不足道的任务在许多情况下,以及它如何可能也是一个自动化任务使用软件或脚本。

一个典型的存根执行以下任务:

*   解密其有效负载(即原始可执行文件)
*   将可执行文件的可加载段映射到内存中
*   将动态链接器映射到内存中
*   创建一个堆栈(使用 mmap)
*   设置堆栈(argv、envp 和辅助向量)
*   将控制传递给程序的入口点

### 注意事项

如果被保护的程序是动态链接的，那么控件将被传递到动态链接器的入口点，该入口点随后将其传递给可执行程序。

这种性质的存根本质上只是一个用户域执行器实现，它加载并执行嵌入在它自己的程序体中的程序，而不是一个独立文件的可执行文件。

### 注意事项

原始的用户界面执行器研究和算法可以在 grugq 的论文*用户界面执行器的设计与实现*中[https://grugq.github.io/docs/ul_exec.txt](https://grugq.github.io/docs/ul_exec.txt)找到。

## 保护器的一个例子

让我们来看看由我编写的简单保护程序保护的可执行程序前后的情况。 使用`readelf`来查看程序头文件，我们可以看到二进制文件包含了我们在动态链接的 Linux 可执行文件中期望看到的所有段:

```sh
$ readelf -l test

Elf file type is EXEC (Executable file)
Entry point 0x400520
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000008e4 0x00000000000008e4  R E    200000
  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                 0x0000000000000248 0x0000000000000250  RW     200000
  DYNAMIC        0x0000000000000e28 0x0000000000600e28 0x0000000000600e28
                 0x00000000000001d0 0x00000000000001d0  RW     8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_EH_FRAME   0x0000000000000744 0x0000000000400744 0x0000000000400744
                 0x000000000000004c 0x000000000000004c  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                 0x00000000000001f0 0x00000000000001f0  R      1
```

现在，让我们在二进制文件上运行保护程序，然后查看程序头文件:

```sh
$ ./elfpack test
$ readelf -l test
Elf file type is EXEC (Executable file)
Entry point 0xa01136
There are 5 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000a00000 0x0000000000a00000
                 0x0000000000002470 0x0000000000002470  R E    1000
  LOAD           0x0000000000003000 0x0000000000c03000 0x0000000000c03000
                 0x000000000003a23f 0x000000000003b4df  RW     1000
```

你会注意到很多不同之处。 入口点是`0xa01136`，只有两个可加载段，分别是文本段和数据段。 这两个加载地址与之前完全不同。

这当然是因为存根的加载地址不会与其中包含的加密可执行文件的加载地址冲突，必须加载该文件并将其映射到内存中。 原可执行文件的文本段地址为`0x400000`。 存根负责解密嵌入其中的可执行文件，然后将其映射到在`PT_LOAD`程序头文件中指定的加载地址。

如果地址与存根的加载地址冲突，那么它将无法工作。 这意味着存根程序必须使用自定义链接器脚本进行编译。 这通常是通过修改现有的链接器脚本，由`ld`使用。 对于这个例子中使用的保护者，我修改了链接器脚本中的一行:

*   这是原话:

    ```sh
    PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
    ```

*   修改后的行如下:

    ```sh
    PROVIDE (__executable_start = SEGMENT_START("text-segment", 0xa00000)); . = SEGMENT_START("text-segment", 0xa00000) + SIZEOF_HEADERS;
    ```

你可以从受保护的可执行文件的程序头中注意到的另一件事是，没有`PT_INTERP`段或`PT_DYNAMIC`段。 对于未经训练的人来说，这是一个静态链接的可执行文件，因为它似乎不使用动态链接。 这是因为您没有查看原始可执行文件的程序头。

### 注意事项

记住，原始的可执行文件是加密的，并嵌入在可执行文件存根中，所以你实际上是从存根而不是它所保护的可执行文件中查看程序头文件。 在许多情况下，存根本身被编译并使用非常少的选项链接，并且不需要动态链接本身。 一个好的用户域执行器实现的主要特征之一是能够将动态链接器加载到内存中。

正如我提到的，存根是一个用户域执行程序，在它解密并将嵌入式可执行文件映射到内存之后，它将动态链接器映射到内存。 然后，动态连接器将处理符号解析和运行时重定位，然后将控制权传递给现在解密的程序。

# 由保护根执行的其他工作

除了解密和将嵌入式可执行文件加载到内存(这是用户地执行组件)之外，存根还可以执行其他任务。 存根通常会启动反调试和反仿真例程，这些例程旨在进一步保护二进制文件不被调试或仿真，以便进一步提高门槛，从而使反向工程更加困难。

在[第 4 章](4.html#164MG1-1d4163ae11644cc2802846625b2dc985 "Chapter 4. ELF Virus Technology – Linux/Unix Viruses")、*ELF 病毒技术—Linux/Unix 病毒*中，我们讨论了一些用于防止基于`ptrace`的调试的反调试技术。 这可以防止大多数调试器(包括 GDB)琐碎地跟踪二进制文件。 在本章的后面，我们将总结 Linux 二进制保护中使用的最常见的反调试技术。

# 已有的 ELF 二进制保护

多年来，有已经有一些值得注意的二进制保护程序被公开和从地下现场释放。 我将讨论一些 Linux 的保护程序，并简要介绍各种特性。

## DacryFile by the Grugq – 2001

DacryFile是我所知道的最早的 Linux([https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile](https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile))的二进制保护。 这种保护器虽然简单，但仍然很聪明，它的工作原理与病毒感染 ELF 寄生虫非常相似。 在许多保护程序中，存根围绕着加密的二进制文件，但在 DacryFile 中，存根只是一个简单的解密例程，它被注入到要保护的二进制文件中。

DacryFile 使用 RC4 加密，对从`.text`节开始到文本段结束的二进制文件进行加密。 解密存根是一个用 asm 和 C 编写的简单程序，它没有用户地执行功能; 它只是解密加密的代码体。 这个存根被插入到数据段的末尾，这非常类似于病毒插入寄生虫的方式。 可执行文件的入口点被修改为指向存根，在执行二进制文件时，存根解密程序的文本段。 然后它将控制传递到原始入口点。

### 注意事项

在支持 NX 位的系统上，数据段不能用来保存代码，除非它被显式地标记为可执行权限位，即`'p_flags |= PF_X`'。

## Burneye by Scut – 2002

很多人认为 Burneye是中第一个像样的二进制加密的例子。 按照今天的标准，它可能会被认为是弱的，但它仍然带来了一些创新的功能。 这包括三层加密，第三层是密码保护层。

密码被转换成一种哈希和类型，然后用于解密最外层。 这意味着除非二进制文件有正确的密码，否则它永远不会被解密。 另一层，称为指纹层，可以代替密码层。 该特性从一个算法中创建一个密钥，该密钥可以识别二进制文件所在的系统，并防止二进制文件在除其所在系统外的任何其他系统上被解密。

还有一个自毁功能; 它在运行一次后删除二进制文件。 Burneye 与其他保护程序的主要区别之一是，它是第一个使用用户域执行技术封装二进制文件的。 从技术上讲，这首先是由 John Resier 为 UPX 封隔器完成的，但 UPX 更被认为是一个二元压缩器而不是一个保护器。 John 据称将 userland exec 的知识传递给了 sccut，正如 sccut 和 Grugq 在[http://phrack.org/issues/58/5.html](http://phrack.org/issues/58/5.html)上写的关于 ELF 二进制保护的 Phrack 58 文章中提到的那样。 这篇文章记录了 Burneye 的内部工作原理，强烈推荐阅读。

### 注意事项

sct 还设计了一个名为`objobf`的工具，即**对象模糊器**。 这个工具混淆了 ELF32 的 ET_REL(目标文件)，因此代码很难反汇编，但在功能上是等价的。 通过使用不透明分支和不对齐组装等技术，这可以非常有效地阻止静态分析。

## Neil Mehta 和 Shawn Clowes 的 Shiva - 2003

Shiva 可能是 Linux 二进制保护的最好的公开可用示例。 源代码从来没有被公开过——只有保护程序被公开了——但是作者在各种会议上做了几次演示，比如 Blackhat USA。 这些都揭示了它的许多技术。

Shiva 为 32 位 ELF 可执行文件工作，并提供了一个完整的运行时引擎(不仅仅是一个解密存根)，该引擎在它所保护的整个进程期间，帮助解密和反调试功能。 Shiva 提供了三层加密，其中最内层永远不会完全解密整个可执行文件。 它一次解密 1024 字节的块，然后重新加密。

对于一个足够大的程序，在任何给定的时间都不会有超过 1/3 的程序被解密。 另一个强大的特性是固有的反调试—Shiva 保护程序使用一种技术，即运行时引擎使用`clone()`生成一个线程，然后该线程跟踪父线程，而父线程反过来跟踪线程。 这使得不可能使用基于`ptrace`的动态分析，因为单个进程(或线程)可能只有一个跟踪器。 另外，由于两个进程都被彼此跟踪，所以没有其他调试器可以附加。

### 注意事项

著名的逆向工程师 Chris Eagle 使用 IDA 的 x86 仿真器插件成功解包了一个 shiva 保护的二进制文件，并在Blackhat 上做了一个演示。 这种对湿婆的逆向工程据说在 3 周内完成。

*   Presentation by the authors:

    [https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf](https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf)

*   Presentation by Chris Eagle (who broke Shiva):

    [http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf](http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf)

## Ryan O'Neill 的玛雅的面纱- 2014

玛雅的面纱是我在 2014 年设计的，是为 ELF64 二进制。 到今天，保护者处于原型阶段，并没有公开发布，但是有一些分叉的版本已经演变成玛雅项目的变体。 其中之一是[https://github.com/elfmaster/](https://github.com/elfmaster/)，它是 Maya 的一个版本，只包含反开发技术，如控制流完整性。 作为玛雅守护者的创造者和设计者，我可以自由地阐述它的内部运作的一些细节，主要是为了激发对这类事情感兴趣的读者的兴趣和创造力。 除了作为这本书的作者，我也是一个很平易近人的人，所以如果你有更多关于玛雅面纱的问题，请随时联系我。

首先，这个保护器被设计为一个仅针对用户的解决方案(这意味着没有来自聪明的内核模块的帮助)，同时仍然能够保护二进制文件具有足够的抗篡改质量，甚至更令人印象深刻的是，还有额外的抗利用特性。 Maya 拥有的许多功能到目前为止只在编译器插件中看到，而 Maya 直接在已经编译的可执行二进制文件上操作。

玛雅是极其复杂的，记录它的所有内部工作将是一个关于二元保护主题的完整注释，但我将总结它的一些最重要的品质。 Maya 可以用来创建第 1 层，第 2 层，或第 3 层的二进制保护。 在第一层，它使用智能运行时引擎; 该引擎被编译为一个名为`runtime.o`的目标文件。

该文件使用反向文本填充扩展(参见[第 4 章](4.html#164MG1-1d4163ae11644cc2802846625b2dc985 "Chapter 4. ELF Virus Technology – Linux/Unix Viruses")，*ELF 病毒技术- Linux/Unix 病毒*)注入，并结合了可重定位代码注入重链接技术。 本质上，运行时引擎的目标文件链接到它所保护的可执行文件。 这个对象文件非常重要，因为它包含用于反调试、反利用、使用加密堆定制`malloc`的代码、关于它所保护的二进制文件的元数据，等等。 这个对象文件是用大约 90%的 C 语言和 10%的 x86 汇编语言编写的。

### 玛雅的保护层

Maya 有多层保护和加密。 每增加一层都增加了更多的工作，使攻击者可以摆脱这些工作，从而增强了安全级别。 最外层的层对于防止静态分析最有用，而最内层(第 1 层)仅解密当前调用堆栈中的函数，并在完成时重新加密它们。 下面是对每个层的更详细的解释。

#### 第一层

第 1 层受保护的二进制文件由单独加密的二进制文件的每一个函数组成。 每个函数在被调用和返回时都会动态地解密和重新加密。 这是因为`runtime.o`包含了一个智能的、自主的自我调试功能，该功能允许它密切监视进程的执行，并确定它何时受到攻击或分析。

运行时引擎本身已经使用代码混淆技术进行了混淆，例如在 sct 的对象混淆工具中发现的那些技术。 解密和重新加密函数的密钥存储和元数据存储在一个自定义的`malloc()`实现中，该实现使用运行时引擎生成的加密堆。 这使得定位按键变得困难。 第 1 层保护是第一个也是最复杂的保护级别，因为它为二进制文件提供了智能和自主的动态解密、反调试和反利用的自跟踪能力。

![Layer 1](../images/00013.jpeg)

这是一个过度简化的图，展示了第 1 层受保护的二进制文件是如何被放置在原始二进制文件旁边的

#### 第二层

第 2 层受保护的二进制文件与第 1 层受保护的二进制文件是一样的，除了，它不仅对函数进行加密，而且对二进制文件中的其他所有部分都进行了加密，以防止静态分析。 这些部分在运行时进行解密,使某些数据暴露如果有人能够转储过程,它必须通过一个内存司机因为`prctl()`用于保护过程从正常的用户空间转储到`/proc/$pid/mem`(也是阻止这个过程倾倒任何核心文件)。

#### 第三层

第 3 层的受保护二进制和第 2 层是一样的，除了它通过将第 2 层的二进制嵌入到第 3 层存根的数据段中而增加了一个更完整的保护层。 第三层存根的工作方式类似于传统的用户域执行。

### 玛雅的纳米虫

玛雅的面纱有许多其他特点，使其难以逆向工程。 其中一个特征被称为**纳米虫**。 这是指原始二进制文件中的某些指令被完全移除，并用垃圾指令或断点替换。

当玛雅的运行时引擎看到这些垃圾指令或断点时，它会检查它的纳米虫记录，看看那里存在的原始指令是什么。 这些记录存储在运行时引擎的加密堆段中，因此对反向工程师来说，访问这些信息并非易事。 一旦 Maya 知道原始指令做了什么，它就会使用`ptrace`系统调用来模拟该指令。

### 玛雅的反剥削

反剥削的特点玛雅是什么使它独特的比较其他保护。 然而大多数保护程序的目的只是让反向工程变得困难，Maya 能够加强二进制程序，使其许多固有的漏洞(如缓冲区溢出)不能被利用。 具体来说，Maya 通过在运行时引擎中嵌入特殊的控制流完整性技术来插装二进制文件，从而防止**ROP**(简称**面向返回编程**)。

受保护二进制文件中的每个函数在入口点和每个返回指令处都有一个断点(`int3`)。 `int3`断点提供了一个触发运行时引擎的 SIGTRAP; 然后运行时引擎做以下几件事之一:

*   解密函数(仅当它击中条目`int3`断点时)
*   对函数进行加密(仅当它击中返回`int3`断点时)
*   检查返回地址是否被覆盖
*   检查`int3`断点是否为纳米虫; 如果是这样，它将效仿

第三个亮点是反 rop 功能。 运行时引擎检查包含程序中不同点的有效返回地址的哈希映射。 如果返回地址是无效的，那么 Maya 将保释出来，利用尝试将失败。

以下是一个脆弱的片段软件代码的例子，是专门为测试和显示Maya 的反 rop 功能:

#### vuln.c .的源代码

```sh
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>

/*
 * This shellcode does execve("/bin/sh", …)
 /
char shellcode[] = "\xeb\x1d\x5b\x31\xc0\x67\x89\x43\x07\x67\x89\x5b\x08\x67\x89\x43\"
"x0c\x31\xc0\xb0\x0b\x67\x8d\x4b\x08\x67\x8d\x53\x0c\xcd\x80\xe8"
"\xde\xff"\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e\x41\x41\x41\x41"
"\x42\x42";

/*
 * This function is vulnerable to a buffer overflow. Our goal is to
 * overwrite the return address with 0x41414141 which is the addresses
 * that we mmap() and store our shellcode in.
 */
int vuln(char *s)
{
        char buf[32];
        int i;

        for (i = 0; i < strlen(s); i++) {
                buf[i] = *s;
                s++;
        }
}

int main(int argc, char **argv)
{
        if (argc < 2)
        {
                printf("Please supply a string\n");
                exit(0);
        }
        int i;
        char *mem = mmap((void *)(0x41414141 & ~4095),
                                 4096,
                                 PROT_READ|PROT_WRITE|PROT_EXEC,
                                 MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
                                -1,
                                 0);

        memcpy((char *)(mem + 0x141), (void *)&shellcode, 46);
        vuln(argv[1]);
        exit(0);

}
```

#### 开发 vuln.c .的实例

让我们看看如何利用`vuln.c`:

```sh
$ gcc -fno-stack-protector vuln.c -o vuln
$ sudo chmod u+s vuln
$ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# whoami
root
#
```

现在让我们使用 Maya 的`-c`选项来保护 vuln，这意味着控制流的完整性。 然后我们将尝试利用受保护的二进制文件:

```sh
 $ ./maya -l2 -cse vuln

[MODE] Layer 2: Anti-debugging/anti-code-injection, runtime function level protection, and outter layer of encryption on code/data
[MODE] CFLOW ROP protection, and anti-exploitation
[+] Extracting information for RO Relocations
[+] Generating control flow data
[+] Function level decryption layer knowledge information:
[+] Applying function level code encryption:simple stream cipher S
[+] Applying host executable/data sections: SALSA20 streamcipher (2nd layer protection)
[+] Maya's Mind-- injection address: 0x3c9000
[+] Encrypting knowledge: 111892 bytes
[+] Extracting information for RO Relocations
[+] Successfully protected binary, output file is named vuln.maya

$ ./vuln.maya AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[MAYA CONTROL FLOW] Detected an illegal return to 0x41414141, possible exploitation attempt!
Segmentation fault
$
```

这表明 Maya 在返回指令实际成功之前检测到一个无效的返回地址`0x41414141`。 Maya 的运行时引擎通过安全地崩溃程序(没有利用)来进行干扰。

另一个 Maya 强制执行的反剥削特性是**relro**(**只读重定位**)。 大多数现代 Linux 系统启用了此功能,但是如果没有启用,玛雅将执行它自己的通过创建一个只读页面包含`the.jcr`的`mprotect()`,`.dynamic`,`.got`,`.ctors`(`.init_array`),`.dtors`(`.fini_array`)部分。 其他反利用特性(如函数指针完整性)正在计划中，还没有加入到代码库中。

# 下载 maya 保护的二进制文件

对于那些对反向工程一些受 Maya 面纱保护的简单程序感兴趣的人，可以在[http://www.bitlackeys.org/maya_crackmes.tgz](http://www.bitlackeys.org/maya_crackmes.tgz)下载一些示例。 该链接包含三个文件:`crackme.elf_hardest`、`crackme.elf_medium`和`test.maya`。

# 反调试二进制保护

由于二进制保护程序通常会加密或混淆程序的物理体，静态分析可能会非常困难，而且在许多情况下被证明是徒劳的。 大多数试图解包或破坏受保护二进制文件的反向工程师都会同意，必须使用动态分析和静态分析的组合来访问解密的二进制文件。

受保护的二进制文件必须解密自身，或者至少解密其在运行时执行的部分。 没有任何反调试技术，逆向工程师可以简单地附加到受保护程序的进程上，并在存根的最后一条指令上设置断点(假设存根解密了整个可执行文件)。

命中断点后，攻击者可以查看代码段，找出受保护的二进制文件所在的位置，并找到它的解密体。 这将是非常简单的，因此，对于好的二进制保护来说，使用尽可能多的技术使调试和动态分析对反向工程师来说变得困难是非常重要的。 像 Maya 这样的保护程序会不遗余力地保护二进制文件不受静态和动态分析的影响。

动态分析并不局限于`ptrace`系统调用，尽管大多数调试器为了访问和操纵进程而局限于它。 因此，二进制保护器不应仅限于保护`ptrace`; 理想情况下，它还将抵抗其他形式的动态分析，如仿真和动态仪器(例如，**引脚**和**DynamoRIO**)。 我们在前面的章节中讨论了许多针对`ptrace`分析的反调试技术，但是对仿真的抵制呢?

# 抗仿真

通常，模拟器被用来在可执行文件上执行动态分析和反向工程任务。 这样做的一个很好的原因是，它们允许反向工程师轻松地控制执行，而且它们还绕过了许多典型的反调试技术。 有许多仿真器正在被使用，例如 qemu、BOCHS 和 Chris Eagles 的 IDA X86 仿真器插件。 因此，存在无数的反仿真技术，但其中一些是特定于每个仿真器的特定实现的。

这个话题可以扩展到一些非常深入的讨论，并向许多方向发展，但我将仅限于我自己的经验。 在我自己的实验与仿真和反仿真在玛雅保护者，我已经学会了一些通用技术，应该工作在至少一些模拟器。 我们的二进制保护程序的反仿真的目标是能够检测它何时在模拟器中运行，如果这是真的，它应该停止执行并退出。

## 通过系统调用测试检测仿真

这种技术可以在应用程序级特别有用模拟器,有些操作系统无关和不太可能实现超过基本系统调用(`read`、`write`、`open`,`mmap`,等等)。 如果模拟器不支持系统调用，也不将不支持的系统调用委托给内核，它很可能会假定一个错误的返回值。

因此，二进制保护程序可以调用一些不太常见的系统调用，并检查返回值是否与预期值匹配。 一个非常类似的技术是调用某些中断处理程序来查看它们是否行为正确。 在这两种情况下，我们都在寻找模拟器没有正确实现的操作系统特性。

## 检测仿真 CPU 不一致

模拟器完美模拟 CPU 架构的可能性几乎为零。 因此，在模拟器的行为和 CPU 应该的行为之间寻找某些不一致是很常见的。 其中一种技术是尝试写入特权指令，如调试寄存器(例如，从`db0`到`db7`)或控制寄存器(例如，从`cr0`到`cr4`)。 仿真检测代码可能有一个 ASM 代码存根，它试图写入`cr0`，并查看是否成功。

## 检查某些指令之间的时间延迟

另一种可能导致模拟器本身不稳定的技术是检查某些指令之间的时间戳，看看执行花了多长时间。 一个真正的 CPU 执行一系列指令的速度应该比模拟器快几个数量级。

# 模糊处理方法

二进制文件可以用许多创造性的方法进行混淆或加密。 大多数二进制保护器只是用一层或多层保护来保护整个二进制。 在运行时，二进制文件被解密，并可以从内存中转储，以获取未打包的二进制文件的副本。 在更高级的保护器中，如 Maya，每个函数都是单独加密的，并且在任何给定的时间只允许一个函数被解密。

一旦二进制被加密，当然，它必须将加密密钥存储在某个地方。 在 Maya(前面讨论过)的例子中，设计了一个自定义堆实现，该实现本身使用加密来存储加密密钥。 在某些情况下，似乎必须公开一个密钥(例如用于解密另一个密钥的密钥)，但可以使用白盒加密等特殊技术使这些最终的密钥极其模糊。 如果在保护程序中使用了来自内核的帮助，那么就有可能将密钥完全存储在二进制文件和进程内存之外。

代码混淆技术(如假拆卸,在[第四章描述](4.html#164MG1-1d4163ae11644cc2802846625b2dc985 "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"),*精灵病毒技术——Linux / Unix 病毒*)也常用于二进制保护使代码静态分析更加困难解密或者是没有加密。 二进制保护程序通常也会从二进制文件中删除 section 头表，并删除任何不需要的字符串和字符串表，比如那些给出符号名的字符串表。

# 保护控制流的完整性

一个受保护的二进制文件的目的应该是在运行时保护程序(进程本身)，就像保护磁盘上的静止二进制文件一样。 运行时攻击一般分为两类:

*   基于`ptrace`的攻击
*   Vulnerability-based 攻击

## 基于 ptrace 的攻击

第一种类型，基于`ptrace`的攻击，也属于调试进程的类别。 如前所述，二进制保护程序希望使基于`ptrace`的调试对逆向工程师来说非常困难。 除了调试,然而,还有许多其他的攻击可能有助于打破一个受保护的二进制,重要的是要知道,了解这些是为了给进一步说明为什么一个二进制保护想保护一个运行的进程从`ptrace`。

如果一个保护者,以至于它能够检测断点指令(因此使调试更加困难),但不能保护自己免受被`ptrace`追踪,然后可能仍然很容易受到`ptrace`基础攻击,劫持和共享库注入等功能。 攻击者可能不想简单地解包受保护的二进制文件，而可能只想改变二进制文件的行为。 一个好的二进制保护程序应该尽力保护其控制流的完整性。

假设攻击者知道一个受保护的二进制文件正在调用`dlopen()`函数来加载一个特定的共享库，而攻击者希望进程加载一个被木马攻击的共享库。 以下步骤可能导致攻击者通过改变受保护二进制文件的控制流来危及其安全:

1.  用`ptrace`附加到过程。
2.  修改全局偏移表项`dlopen()`指向`__libc_dlopen_mode`(在`libc.so`中)。
3.  调整寄存器`%rdi`，使其指向路径`/tmp/evil_lib.so`。
4.  继续执行。

此时，攻击者已经强迫一个受保护的二进制文件加载一个恶意的共享库，因此已经完全破坏了受保护二进制文件的安全性。

正如前面所讨论的，多亏了一个作为主动调试器工作的运行时引擎，防止了任何其他进程的附加，所以 Maya 保护程序能够防范此类漏洞。 如果一个保护程序可以禁止`ptrace`连接到被保护的进程，那么该进程受到这种类型的运行时攻击的风险就会小得多。

## 安全漏洞类攻击

基于漏洞的攻击是一种攻击类型，在这种攻击中，攻击者可以利用受保护程序中的固有弱点，例如基于堆栈的缓冲区溢出，然后将执行流更改为他们所选择的内容。

这种类型的攻击通常很难在受保护的程序上执行，因为它产生的关于它自己的信息要少得多，而且使用调试器来缩小内存中使用的位置可能更难以深入了解。 然而，这种类型的攻击是非常可能的，这就是为什么 Maya 保护程序强制控制流完整性和只读重定位，以特别防止漏洞利用攻击。

我不知道是否有其他的保护者现在正在使用类似的反剥削技术，但我只能猜测他们在那里。

# 其他资源

仅写一章关于二进制保护的内容不足以让你完全了解这一主题。 然而，这本书的其他章节相互补充; 当结合在一起时，它们将帮助你获得更深层次的理解。 关于这个主题有很多很好的资源，其中一些已经被提到了。

安德鲁·格里菲斯(Andrew Griffith)写的一篇文章特别推荐大家阅读。 这篇文章写于十多年前，但描述了许多技术和实践，这些技术和实践仍然与今天的二进制保护程序非常相关:

[http://www.bitlackeys.org/resources/binary_protection_schemes.pdf](http://www.bitlackeys.org/resources/binary_protection_schemes.pdf)

这篇论文之后是稍后的一个演讲，幻灯片可以在这里找到:

[http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf](http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf)

# 总结

在这一章中，我们揭示了 Linux 二进制文件的基本二进制保护方案的内部工作原理，并讨论了过去十年中为 Linux 发布的现有二进制保护程序的各种特性。

在下一章中，我们将从相反的角度来探索，并开始研究 Linux 中的 ELF 二进制取证。