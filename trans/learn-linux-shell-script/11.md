# 条件测试和脚本循环

本章首先回顾一下`if-then-else`，然后介绍`if-then-else`条件句的高级用法。我们将以`while`和`for`的形式介绍脚本循环，我们将展示如何使用`exit`、`break`和`continue`控制这些循环。

本章将介绍以下命令:`elif`、`help`、`while`、`sleep`、`for`、`basename`、`break`和`continue`。

本章将涵盖以下主题:

*   高级`if-then-else`
*   `while`循环
*   `for`循环
*   `loop`控制

# 技术要求

本章所有脚本均可在 GitHub:[https://GitHub . com/PacktPublishing/Learn-Linux-Shell-Scripting-Bash-4.4 基础/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11) 上找到。所有其他工具仍然有效，无论是在您的主机上还是在您的 Ubuntu 虚拟机上。对于 break-x.sh、for-globbing.sh、square-number.sh、while-interactive.sh 脚本，只有最终版本可以在网上找到。在您的系统上执行之前，请确保验证标题中的脚本版本。

# 高级 if-then-else

本章专门介绍与条件测试和脚本循环相关的所有内容，这是两个经常交织在一起的概念。我们已经在[第九章](09.html)、*错误检查和处理*中看到了`if-then-else`循环，重点是错误检查和处理。在进入高级概念之前，我们将简单回顾一下我们所描述的关于`if-then-else`的事情。

# 对 if-then-else 的概括

`If-then-else`逻辑几乎完全如其名:**如果**T3、**那么**T7【做某事】T8 或**else**T11【做某事】else 。实际上，这可能是**如果** *磁盘已满*，**则** *删除一些文件*或**否则** *报告磁盘空间看起来很大*。在脚本中，这可能看起来像这样:

```sh
reader@ubuntu:~/scripts/chapter_09$ cat if-then-else-proper.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-09-30
# Description: Use the if-then-else construct, now properly.
# Usage: ./if-then-else-proper.sh file-name
#####################################

file_name=$1

# Check if the file exists.
if [[ -f ${file_name} ]]; then 
  cat ${file_name} # Print the file content.
else
  echo "File does not exist, stopping the script!"
  exit 1
fi
```

如果文件存在，我们打印内容。否则(所以，如果文件不存在)，我们以错误消息的形式给用户反馈，然后退出脚本，退出状态为`1`。请记住，任何不为 0 的退出代码都表示*脚本失败*。

# 在测试中使用正则表达式

介绍完`if-then-else`后的一章，我们学习了所有正则表达式。然而，那一章大多是理论性的，只包含一个剧本！现在，正如您可能意识到的，正则表达式主要支持将与其他脚本工具一起使用的构造。在我们描述的测试中，我们可以在`[[...]]`块中使用 globbing 和正则表达式！让我们更深入地了解这一点，如下所示:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim square-number.sh 
reader@ubuntu:~/scripts/chapter_11$ cat square-number.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-26
# Description: Return the square of the input number.
# Usage: ./square-number.sh <number>
#####################################

INPUT_NUMBER=$1

# Check the number of arguments received.
if [[ $# -ne 1 ]]; then
 echo "Incorrect usage, wrong number of arguments."
 echo "Usage: $0 <number>"
 exit 1
fi

# Check to see if the input is a number.
if [[ ! ${INPUT_NUMBER} =~ [[:digit:]] ]]; then 
 echo "Incorrect usage, wrong type of argument."
 echo "Usage: $0 <number>"
 exit 1
fi

# Multiple the input number with itself and return this to the user.
echo $((${INPUT_NUMBER} * ${INPUT_NUMBER}))
```

我们首先检查用户是否提供了正确数量的参数(这是我们应该一直做的)。接下来，我们在测试`[[..]]`块中使用`=~`运算符。这允许我们使用正则表达式进行**评估。在这种情况下，它只允许我们验证用户输入的是一个数字，而不是其他任何东西。**

现在，如果我们调用这个脚本，我们将看到以下内容:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh
Incorrect usage, wrong number of arguments.
Usage: square-number.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 3 2
Incorrect usage, wrong number of arguments.
Usage: square-number.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh a
Incorrect usage, wrong type of argument.
Usage: square-number.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 3
9
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 11
121
```

我们可以看到我们的两个输入检查都有效。如果我们在没有一个参数(`$# -ne 1`)的情况下调用这个脚本，它会失败。这对于`0`和`2`的论点都是正确的。接下来，如果我们用字母而不是数字来调用脚本，我们会得到第二个检查和随之而来的错误消息:`wrong type of argument`。最后，为了证明剧本确实做到了我们想要的，我们就用单编号:`3`和`11`来试试。`9`和`121`的回报都是这些数字的平方，看来我们达到目的了！

然而，并不是一切都像看上去的那样。使用正则表达式时，这是一个常见的陷阱，如下代码所示:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh a3
0
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 3a
square-number.sh: line 28: 3a: value too great for base (error token is "3a")
```

这是怎么发生的？我们检查了用户输入是否是一个数字，不是吗？事实上，与你可能想的相反，我们实际上检查了用户输入的*是否与数字*匹配。简单地说，如果输入包含一个数字，则检查成功。我们真正要检查的是从开始到结束输入的是否是数字*。也许这听起来很熟悉，但它绝对闻起来像线锚！以下代码适用于此:*

```sh
reader@ubuntu:~/scripts/chapter_11$ vim square-number.sh
reader@ubuntu:~/scripts/chapter_11$ head -5 square-number.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.1.0
reader@ubuntu:~/scripts/chapter_11$ grep 'digit' square-number.sh 
if [[ ! ${INPUT_NUMBER} =~ ^[[:digit:]]$ ]]; then
```

我们做了两个改变:我们匹配的搜索模式不再仅仅是`[[:digit:]]`，而是`^[[:digit:]]$`，我们更新了版本号(到目前为止我们还没有做太多的事情)。因为我们现在将数字锚定到行的开头和结尾，所以我们不能再在随机位置插入一个字母。使用不正确的输入运行脚本以验证这一点:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh a3
Incorrect usage, wrong type of argument.
Usage: square-number-improved.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 3a
Incorrect usage, wrong type of argument.
Usage: square-number-improved.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 3a3
Incorrect usage, wrong type of argument.
Usage: square-number-improved.sh <number>
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 9
81
```

我很想告诉你我们现在非常安全。但是，唉，就像正则表达式经常发生的那样，事情没那么简单。这个脚本现在对单个数字(0–9)很有效，但是如果你用两位数来尝试，它会以`wrong type of argument error`失败(试试看！).我们需要最后一个调整，以确保它完全符合我们的要求:我们需要确保数字也接受多个连续的数字。正则表达式中的*一个或多个*构造是+号，我们可以将其附加到`[[:digit:]]`中:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim square-number.sh 
reader@ubuntu:~/scripts/chapter_11$ head -5 square-number.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.2.0
reader@ubuntu:~/scripts/chapter_11$ grep 'digit' square-number.sh 
if [[ ! ${INPUT_NUMBER} =~ ^[[:digit:]]+$ ]]; then 
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 15
225
reader@ubuntu:~/scripts/chapter_11$ bash square-number.sh 1x5
Incorrect usage, wrong type of argument.
Usage: square-number-improved.sh <number>
```

我们改变了模式，提高了版本号，并用不同的输入运行了脚本。`^[[:digit:]]+$`的最终模式可以读作*从行首到行尾的一个或多个数字*，在这种情况下，它的意思是*一个数字，而不是别的*！

The lesson here is that you really need to test your regular expressions thoroughly. As you know by now, search patterns are greedy, and as soon as a little bit matches, it considers the result a success. As seen in the previous example, this was not specific enough. The only way to implement (and learn!) this is by trying to break your own scripts. Try wrong input, weird input, very specific input, and so on. Unless you try a lot, you can't be sure that it will *probably* work.

您可以在测试语法中使用所有正则表达式搜索模式。其他例子，我们不会充实，但绝对应该考虑，如下所示:

*   变量应以`/`开头(对于完全限定的路径)
*   变量不能包含空白(使用`[[:blank:]]`搜索模式)
*   变量应该只包含小写字母(可通过`^[[:lower:]]+$`模式实现)
*   变量应包含扩展名为的文件名(可在`[[:alnum:]]\.[[:alpha:]]`上匹配)

# elif 条件

在我们到目前为止看到的场景中，只需要检查一个**条件*。但正如你可能预料的那样，有时候，有多个你想检查的东西，每个东西都有自己的一组下面的动作(*然后* *阻止*)。您可以通过使用两个完整的`if-then-else`语句来解决这个问题，但至少您会有一个重复的*否则* *块*。更糟糕的是，如果你有三个或更多的条件要检查，你会有越来越多的重复代码！幸运的是，我们可以通过使用`elif`命令来解决这个问题，这是`if-then-else`逻辑的一部分。你可能已经猜到了，`elif`是`else-if`的简称。它允许我们做如下事情:*

*IF condition1, THEN do thing1, ELIF condition2, THEN do thing2, ELSE do final-thing

可以在初始`if`命令后链任意多的`elif`命令，但有一点要考虑:只要有条件成立，就只执行`then`语句；所有其他的都被跳过。

如果你想的是多个条件可以为真，并且应该执行它们的`then`语句的情况，你需要使用多个`if-then-else`块。让我们看一个简单的例子，首先检查用户给出的参数是否是一个文件。如果是，我们使用`cat`打印文件。如果不是这样，我们检查它是否是一个目录。如果是这样，我们用`ls`列出目录。如果情况也不是这样，我们将打印一条错误消息，并以非零退出状态退出。请看下面的命令:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim print-or-list.sh 
reader@ubuntu:~/scripts/chapter_11$ cat print-or-list.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-26
# Description: Prints or lists the given path, depending on type.
# Usage: ./print-or-list.sh <file or directory path>
#####################################

# Since we're dealing with paths, set current working directory.
cd $(dirname $0)

# Input validation.
if [[ $# -ne 1 ]]; then
  echo "Incorrect usage!"
  echo "Usage: $0 <file or directory path>"
  exit 1
fi

input_path=$1

if [[ -f ${input_path} ]]; then
  echo "File found, showing content:"
  cat ${input_path} || { echo "Cannot print file, exiting script!"; exit 1; }
elif [[ -d ${input_path} ]]; then
  echo "Directory found, listing:"
  ls -l ${input_path} || { echo "Cannot list directory, exiting script!"; exit 1; }
else
  echo "Path is neither a file nor a directory, exiting script."
  exit 1
fi
```

如您所见，当我们处理用户输入的文件时，我们需要额外的卫生设施。我们确保在脚本中使用`cd $(dirname $0)`设置当前工作目录，并且我们假设每个命令都可能失败，因此我们使用||构造来处理这些失败，如[第 9 章](09.html)、*错误检查和处理*中所述。让我们试着看看我们是否能找到这种逻辑可以走的大多数路径:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh 
Incorrect usage!
Usage: print-or-list.sh <file or directory path>
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh /etc/passwd
File found, showing content:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
<SNIPPED>
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh /etc/shadow
File found, showing content:
cat: /etc/shadow: Permission denied
Cannot print file, exiting script!
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh /tmp/
Directory found, listing:
total 8
drwx------ 3 root root 4096 Oct 26 08:26 systemd-private-4f8c34d02849461cb20d3bfdaa984c85...
drwx------ 3 root root 4096 Oct 26 08:26 systemd-private-4f8c34d02849461cb20d3bfdaa984c85...
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh /root/
Directory found, listing:
ls: cannot open directory '/root/': Permission denied
Cannot list directory, exiting script!
reader@ubuntu:~/scripts/chapter_11$ bash print-or-list.sh /dev/zero
Path is neither a file nor a directory, exiting script.
```

按照顺序，我们已经看到了脚本的以下场景:

1.  **无争论** : `Incorrect usage`错误
2.  **文件参数/etc/passwd** :文件内容打印
3.  **不可读文件/etc/shadow 上的文件参数** : `Cannot print file`错误
4.  **目录参数/tmp/** :已打印目录列表
5.  **不可列表目录/根目录/** 上的目录参数:`Cannot list directory`错误
6.  **特殊文件(块设备)参数/dev/zero** : `Path is neither a file nor a directory`错误

这六个输入场景代表了我们的脚本可以采用的所有可能的路径。虽然您可能已经考虑了一个(看似简单的)脚本的所有错误处理，但是这些参数应该验证为什么我们实际上需要所有这些错误处理。

While `elif` greatly enhances the possibilities of an `if-then-else` statement, too much `if-elif-elif-elif-`.......`-then-else` will make your script really hard to read. There is another construct (which is outside the scope of this book), called `case`. This deals with many different, unique conditions. Look at the further reading section at the end of this chapter for a good resource on `case`!

# 嵌套

另一个非常有趣的概念是嵌套。本质上，嵌套非常简单:它将另一个`if-then-else`语句放在*外部* `if-then-else`的`then`或`else`中。例如，这允许我们首先确定文件是否可读，然后再确定它是什么类型的文件。通过使用嵌套的`if-then-else`语句，我们可以重写前面的代码，这样我们就不再需要||构造:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim nested-print-or-list.sh 
reader@ubuntu:~/scripts/chapter_11$ cat nested-print-or-list.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-26
# Description: Prints or lists the given path, depending on type.
# Usage: ./nested-print-or-list.sh <file or directory path>
#####################################

# Since we're dealing with paths, set current working directory.
cd $(dirname $0)

# Input validation.
if [[ $# -ne 1 ]]; then
  echo "Incorrect usage!"
  echo "Usage: $0 <file or directory path>"
  exit 1
fi

input_path=$1

# First, check if we can read the file.
if [[ -r ${input_path} ]]; then
  # We can read the file, now we determine what type it is.
  if [[ -f ${input_path} ]]; then
    echo "File found, showing content:"
    cat ${input_path} 
  elif [[ -d ${input_path} ]]; then
    echo "Directory found, listing:"
    ls -l ${input_path} 
  else
    echo "Path is neither a file nor a directory, exiting script."
    exit 1
  fi
else
  # We cannot read the file, print an error.
  echo "Cannot read the file/directory, exiting script."
  exit 1
fi
```

使用与前面示例相同的输入尝试前面的脚本。在这种情况下，您将在错误场景中看到更好的输出，因为我们现在控制这些输出(例如，而不是来自`cat`的`cat: /etc/shadow: Permission denied`的默认输出)。然而，在功能上，一切都没有改变！我们认为这个使用嵌套的脚本比前面的例子更易读，因为我们现在自己处理错误场景，而不是依赖系统命令来完成。

We've discussed indentation before, but in our opinion, scripts like this one are where it truly shines. By indenting the inner `if-then-else` statement, it is much more clear that the second `else` belongs to the outer `if-then-else` statement. If you're using multiple levels of indentation (because, in theory, you can nest as often as you'd like), it really helps everyone working on the script to follow this logic.

嵌套不仅仅是为`if-then-else`保留的。我们将在本章后面介绍的两个循环`for`和`while`也可以嵌套。而且，更实际的是，你可以将它们嵌套在所有其他的里面(从技术角度来看；当然，从逻辑的角度来看，这也是有意义的！).稍后我们解释`while`和`for`时，你会看到这方面的例子。

# 寻求帮助

现在，你可能害怕你永远不会记得这一切。虽然我们确信，经过足够的练习，你肯定会及时接受，但我们也明白，当你没有那么丰富的经验时，你需要接受很多东西。为了使这变得更容易，除了`man`页面之外，还有另一个有用的命令。正如你可能已经发现的(当你尝试时失败了)，`man if`或`man [[`不起作用。如果你用`type if`和`type [[`检查这些命令，你实际上会看到它们不是命令，而是*外壳关键字*。对于大多数的 shell 内建和 shell 关键字，您可以使用`help`命令打印一些关于它们做什么和如何使用它们的信息！使用`help`就像`help if`、`help [[`、`help while`等一样简单。对于`if-then-else`语句，只有`help if`起作用:

```sh
reader@ubuntu:~/scripts/chapter_11$ help if
if: if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi
    Execute commands based on conditional.

    The 'if COMMANDS' list is executed. If its exit status is zero,
     then the 'then COMMANDS' list is executed.  Otherwise, each 
     'elif COMMANDS' list is executed in turn, and if its 
     exit status is zero, the corresponding
    'then COMMANDS' list is executed and the if command completes.  Otherwise,
    the 'else COMMANDS' list is executed, if present. 
    The exit status of the entire construct is the 
     exit status of the last command executed, or zero
    if no condition tested true.

    Exit Status:
    Returns the status of the last command executed.
```

因此，总的来说，有三种方法可以让 Linux 为您打印一些有用的信息:

*   带`man`命令的手册页
*   使用`help`命令帮助信息
*   命令原生帮助打印(通常为`flag -h`、`--help`或`-help`

根据命令的类型(二进制或 shell 内置/关键字)，您可以使用`man`、`help`或`--help`标志。请记住，通过检查您正在处理的是哪种类型的命令(这样您就可以更好地猜测您可以先尝试哪种帮助方法)，使用`type -a <command>`。

# while 循环

现在我们已经回顾了`if-then-else`和高级用法，是时候讨论第一个脚本循环:`while`了。看看下面的定义，在`if-then-else`之后应该很熟悉了吧:

WHILE condition-is-true DO thing-to-do DONE

`if`和`while`最大的区别是，while 会多次执行动作，只要指定的条件仍然成立。因为通常不需要有一个无休止的循环，所以动作会定期地改变与条件相关的东西。这基本上意味着*做*的动作最终会导致 while 条件为假而不是真。让我们看一个简单的例子:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim while-simple.sh 
reader@ubuntu:~/scripts/chapter_11$ cat while-simple.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of a while loop.
# Usage: ./while-simple.sh 
#####################################

# Infinite while loop.
while true; do
  echo "Hello!"
  sleep 1 # Wait for 1 second.
done
```

这个例子是 while 最基本的形式:一个无休止的循环(因为条件只是`true`)，打印一条消息，然后休眠一秒钟。这个新命令`sleep`经常在循环(T2 和 T3)中使用，以等待指定的时间。在这种情况下，我们运行`sleep 1`，在返回循环顶部并再次打印`Hello!`之前等待一秒钟。一定要试一试，注意它是如何永不停止的( *Ctrl* + *C* 会杀死这个过程，因为它是交互式的)。

现在，我们将创建一个将在特定时间结束的脚本。为此，我们将在`while`循环之外定义一个变量，用作计数器。该计数器将在每次运行`while`循环时递增，直到达到条件中定义的阈值。看一看:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim while-counter.sh 
reader@ubuntu:~/scripts/chapter_11$ cat while-counter.sh
cat while-counter.sh
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of a while loop with a counter.
# Usage: ./while-counter.sh 
#####################################

# Define the counter outside of the loop so we don't reset it for 
# every run in the loop.
counter=0

# This loop runs 10 times.
while [[ ${counter} -lt 10 ]]; do
  counter=$((counter+1)) # Increment the counter by 1.
  echo "Hello! This is loop number ${counter}."
  sleep 1 
done

# After the while-loop finishes, print a goodbye message.
echo "All done, thanks for tuning in!"
```

这个脚本应该是不言自明的，因为我们已经添加了注释。`counter`被添加到`while`循环之外，因为否则循环的每次运行都将从`counter=0`开始，这将重置进度。只要计数器小于 10，我们就继续循环运行。10 次运行后，情况不再如此，我们不再返回循环，而是转到脚本中的下一条指令，即打印再见消息。继续运行这个脚本。睡眠后编辑数字(提示:它也接受小于一秒的值)，或者完全取消睡眠。

# 直到循环

而拥有双胞胎:`until`。一个`until`循环的作用和 while 完全一样，只有一个区别:只要条件为**假**，循环就运行。一旦条件变为**真**，循环不再运行。我们将对之前的脚本做一些小的改动，看看`until`是如何工作的:

```sh
reader@ubuntu:~/scripts/chapter_11$ cp while-counter.sh until-counter.sh
reader@ubuntu:~/scripts/chapter_11$ vim until-counter.sh 
reader@ubuntu:~/scripts/chapter_11$ cat until-counter.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of an until loop with a counter.
# Usage: ./until-counter.sh 
#####################################

# Define the counter outside of the loop so we don't reset it for 
# every run in the loop.
counter=0

# This loop runs 10 times.
until [[ ${counter} -gt 9 ]]; do
  counter=$((counter+1)) # Increment the counter by 1.
  echo "Hello! This is loop number ${counter}."
  sleep 1
done

# After the while-loop finishes, print a goodbye message.
echo "All done, thanks for tuning in!"
```

正如您所看到的，对这个脚本的更改非常小(但是很重要)。我们把`while`换成了`until`、`-lt`换成了`-gt`、`10`换成了`9`。现在，它显示的是`run the loop until the counter is greater than 9`而不是`run the loop as long as the counter is lower than 10`。因为我们使用的是小于和大于，所以我们必须更改数字，否则我们将会遇到著名的*逐个*错误(在这种情况下，这意味着我们将循环 11 次，如果我们没有将`10`更改为`9`；试试看！).

本质上，`while`和`until`循环完全相同。您将更多地使用`while`循环而不是直到循环:因为您可以直接否定条件，所以`while`循环将一直有效。然而，有时候，一个`until`循环可能会让*觉得*更合理。在任何情况下，使用最容易理解的情况！有疑问的时候，只要条件合适，只使用`while`几乎不会错。

# 创建交互式 while 循环

实际上，你不会经常使用`while`循环。在大多数情况下，`for`循环更好(我们将在本章后面看到)。然而，有一种情况`while`循环非常好:处理用户输入。如果您使用带有 if-then-else 块嵌套的`while true`构造，您可以继续向用户请求输入，直到得到您想要的答案。下面的例子是一个简单的谜语，应该可以澄清一些问题:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim while-interactive.sh 
reader@ubuntu:~/scripts/chapter_11$ cat while-interactive.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: A simple riddle in a while loop.
# Usage: ./while-interactive.sh
#####################################

# Infinite loop, only exits on correct answer.
while true; do
  read -p "I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? " answer
  if [[ ${answer} =~ [Kk]eyboard ]]; then # Use regular expression so 'a keyboard' or 'Keyboard' is also a valid answer.
    echo "Correct, congratulations!"
    exit 0 # Exit the script.
  else
    # Print an error message and go back into the loop.
    echo "Incorrect, please try again."
  fi
done

reader@ubuntu:~/scripts/chapter_11$ bash while-interactive.sh 
I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? mouse
Incorrect, please try again.
I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? screen
Incorrect, please try again.
I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? keyboard
Correct, congratulations!
reader@ubuntu:~/scripts/chapter_11$
```

在这个脚本中，我们使用`read -p`向用户提问，并将回答存储在`answer`变量中。然后，我们使用嵌套的 if-then-else 块来检查用户是否给出了正确的答案。我们使用一个简单的正则表达式 if-condition，`${answer} =~ [Kk]eyboard`，它给用户提供了一点关于大写字母和前面的单词`a`的灵活性。对于每一个不正确的答案， *else* 语句都会打印一个错误，并且循环从`read -p`开始。如果答案正确，则执行*然后*块，以`exit 0`结束，表示脚本结束。只要没有给出正确的答案，循环就会永远继续下去。

您可能会发现这个脚本有问题。如果我们想在`while`循环之后做任何事情，我们需要*在不退出脚本的情况下将*从循环中分离出来。我们将看看如何使用–等待它–`break`关键字来实现这一点！但是首先，我们要检查一下`for`循环。

# for 循环

`for`循环可以被认为是 Bash 脚本中更强大的循环。实际上，`for`和`while`是可以互换的，但是`for`有更好的速记语法。这意味着在`for`中编写一个循环通常比等效的`while`循环需要更少的代码。

`for`循环有两种不同的语法:C 风格语法和`regular` Bash 语法。我们将首先看看 Bash 语法:

FOR value IN list-of-values DO thing-with-value DONE

一个`for`循环允许我们*迭代*一系列事情。每个循环将按顺序使用列表中的不同项目。这个非常简单的例子应该可以说明这种行为:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-simple.sh
reader@ubuntu:~/scripts/chapter_11$ cat for-simple.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Simple for syntax.
# Usage: ./for-simple.sh
#####################################

# Create a 'list'.
words="house dog telephone dog"

# Iterate over the list and process the values.
for word in ${words}; do
  echo "The word is: ${word}"
done

reader@ubuntu:~/scripts/chapter_11$ bash for-simple.sh 
The word is: house
The word is: dog
The word is: telephone
The word is: dog
```

如您所见，`for`接受一个列表(在这种情况下，是一个由空格分隔的字符串)，对于它找到的每个值，它都会执行`echo`操作。我们在那里添加了一些额外的文本，这样您就可以看到它实际上进入循环四次，而不仅仅是打印带有额外新行的列表。这里要注意的主要事情是，在回声中我们使用了`${word}`变量，我们将其定义为`for`定义中的第二个单词。这意味着对于`for`循环的每一次运行，`${word}`变量的值是不同的(这很大程度上是按照预期使用变量，包含*变量*！).你可以给它起任何名字，但是我们更喜欢给它起语义上合乎逻辑的名字；既然我们称我们的列表为*单词*，那么列表中的一个项目就是*单词*。

如果你想用`while`做同样的事情，事情会变得复杂得多。使用一个计数器和一个命令(比如`cut`(它允许你切掉一个字符串的不同部分)肯定是可能的，但是既然`for`循环是以这种简单的方式完成的，为什么还要麻烦呢？

我们可以与 for 一起使用的第二种语法对于那些对其他脚本编程语言有经验的人来说会更容易识别。这种 C 风格的语法使用了一个递增到某个点的计数器，这与我们在查看`while`时看到的例子并无不同。语法如下:

```sh
FOR ((counter=0; counter<=10; counter++)); DO something DONE
```

似乎很相似，对吧？查看以下示例脚本:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-counter.sh 
reader@ubuntu:~/scripts/chapter_11$ cat for-counter.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of a for loop in C-style syntax.
# Usage: ./for-counter.sh 
#####################################

# This loop runs 10 times.
for ((counter=1; counter<=10; counter++)); do
  echo "Hello! This is loop number ${counter}."
  sleep 1
done

# After the for-loop finishes, print a goodbye message.
echo "All done, thanks for tuning in!"

reader@ubuntu:~/scripts/chapter_11$ bash for-counter.sh 
Hello! This is loop number 1.
Hello! This is loop number 2.
Hello! This is loop number 3.
Hello! This is loop number 4.
Hello! This is loop number 5.
Hello! This is loop number 6.
Hello! This is loop number 7.
Hello! This is loop number 8.
Hello! This is loop number 9.
Hello! This is loop number 10.
All done, thanks for tuning in!
```

同样，由于逐个错误的性质，我们不得不使用稍微不同的数字。由于计数器在循环结束时增加*，我们需要从 1 开始而不是从 0 开始(或者我们可以在 while 循环中做同样的事情)。在 C 风格语法中， **< =** 表示*小于或等于*，而++表示*增加 1* 。所以，我们有一个计数器，从 1 开始，一直持续到 10，每次循环都递增 1。我们发现这个`for`循环比等价的 while 循环更可取；它需要更少的代码，在其他脚本/编程语言中更常见。*

 *更好的是，有一种方法可以迭代一个数字范围(就像我们之前对 1–10 所做的那样)，也可以使用 for 循环 Bash 语法。因为一个数字范围只不过是一个数字的*列表*，我们可以使用与第一个例子中几乎相同的语法，在第一个例子中，我们迭代了一个单词的*列表*。看看下面的代码:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-number-list.sh
reader@ubuntu:~/scripts/chapter_11$ cat for-number-list.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of a for loop with a number range.
# Usage: ./for-number-list.sh
#####################################

# This loop runs 10 times.
for counter in {1..10}; do
  echo "Hello! This is loop number ${counter}."
  sleep 1
done

# After the for-loop finishes, print a goodbye message.
echo "All done, thanks for tuning in!"

reader@ubuntu:~/scripts/chapter_11$ bash for-number-list.sh 
Hello! This is loop number 1.
Hello! This is loop number 2.
Hello! This is loop number 3.
Hello! This is loop number 4.
Hello! This is loop number 5.
Hello! This is loop number 6.
Hello! This is loop number 7.
Hello! This is loop number 8.
Hello! This is loop number 9.
Hello! This is loop number 10.
All done, thanks for tuning in!
```

因此，`<list>`中`<variable>`的语法适用于一系列`{1..10}`。这被称为**支撑扩展**，是在 Bash 版本 4 中添加的。大括号扩展的语法非常简单:

```sh
{<starting value>..<ending value>}
```

大括号扩展有多种用途，但最广为人知的是打印数字或字符列表:

```sh
reader@ubuntu:~/scripts/chapter_11$ echo {1..5}
1 2 3 4 5
reader@ubuntu:~/scripts/chapter_11$ echo {a..f}
a b c d e f
```

大括号扩展`{1..5}`返回字符串`1 2 3 4 5`，这是一个由空格分隔的值列表，因此可以在 Bash 风格的`for`循环中使用！或者，`{a..f}`打印字符串`a b c d e f`。范围实际上是由 ASCII 十六进制代码决定的；这也允许我们执行以下操作:

```sh
reader@ubuntu:~/scripts/chapter_11$ echo {A..z}
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [  ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z
```

你可能会看到一些特殊的字符印在中间，这看起来很奇怪，但这些字符介于大写和小写拉丁字母字符之间。请注意，该语法非常类似于用`${variable}`获取变量的值(但是，这是参数展开，而不是括号展开)。

支撑扩展还有一个有趣的功能:它允许我们定义增量！简而言之，这允许我们告诉 Bash 每次增量时要跳过多少步。其语法如下:

```sh
{<starting value>..<ending value>..<increment>}
```

默认情况下，增量值为 1。如果这是期望的功能，我们可以省略增量值，就像我们之前看到的那样。但是，如果我们真的设置了它，我们会看到如下内容:

```sh
reader@ubuntu:~/scripts/chapter_11$ echo {1..100..10}
1 11 21 31 41 51 61 71 81 91
reader@ubuntu:~/scripts/chapter_11$ echo {0..100..10}
0 10 20 30 40 50 60 70 80 90 100
```

现在，增量以 10 为单位。如前例所示，`<ending value>`被认为是*包含*。这意味着低于或等于*的值将被打印，但其他值不会被打印。上例中第一个大括号扩展的下一个值。`{1..100..10}`，早就 101 了；因为该值不小于或等于 100，所以不打印该值，并且扩展终止。*

最后，因为我们承诺我们可以用`while`做的任何事情我们也可以用`for`做，我们想通过向你展示如何用`for`创建一个无限循环来结束这一章的这一部分。这是选择`while`而不是`for`最常见的原因，因为`for`的语法有点怪异:

```sh
eader@ubuntu:~/scripts/chapter_11$ vim for-infinite.sh 
reader@ubuntu:~/scripts/chapter_11$ cat for-infinite.sh 
#!/bin/bash
```

```sh

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Example of an infinite for loop.
# Usage: ./for-infinite.sh 
#####################################

# Infinite for loop.
for ((;;)); do
  echo "Hello!"
  sleep 1 # Wait for 1 second.
done

reader@ubuntu:~/scripts/chapter_11$ bash for-infinite.sh 
Hello!
Hello!
Hello!
^C
```

我们使用 C 风格的语法，但是省略了计数器的初始化、比较和递增。因此，其内容如下:

for ((<nothing>;<no-comparison>;<no-increment>)); do

这最终会成为`((;;));`，这只有在你把它放在正常语法的上下文中才有意义，就像我们在前面的例子中所做的那样。我们也可以省略增量或对相同效果的比较，但是这将对更多的代码做同样的事情。通常，越短越好，因为越清晰。

Try to replicate the infinite `for` loop, but only by omitting a single value from the `for` clause. If you get that working, you'll be a step closer to understanding why you have now made it unending. If you need a little nudge, perhaps you'd want to echo the value of `counter` in the loop so that you can see what is happening. Or you could always run it with `bash -x`, of course!

# 球形化和 for 循环

现在，让我们看几个更实际的例子。你在 Linux 上做的大多数事情都会处理文件(还记得为什么吗？).假设服务器上有一堆日志文件，您想要对它们执行一些操作。如果它只是一个带有单个命令的单个动作，您很可能可以使用带有该命令的 globbing 模式(例如`grep -i 'error' *.log`)。但是，想象一下这样一种情况，您想要收集包含特定短语的日志文件，或者可能只收集这些文件中的行。在这种情况下，使用 globbing 模式结合`for`循环将允许我们对许多文件执行许多命令，我们可以动态地找到这些命令！让我们试一试。因为这个脚本将结合我们到目前为止所学的许多课程，所以我们将从简单开始，逐步扩展它:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-globbing.sh 
reader@ubuntu:~/scripts/chapter_11$ cat for-globbing.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-27
# Description: Combining globbing patterns in a for loop.
# Usage: ./for-globbing.sh 
#####################################

# Create a list of log files.   
for file in $(ls /var/log/*.log); do
  echo ${file}
done

reader@ubuntu:~/scripts/chapter_11$ bash for-globbing.sh 
/var/log/alternatives.log
/var/log/auth.log
/var/log/bootstrap.log
/var/log/cloud-init.log
/var/log/cloud-init-output.log
/var/log/dpkg.log
/var/log/kern.log
```

通过使用`$(ls /var/log/*.log)`构造，我们可以创建一个在`/var/log/`目录中找到的以`.log`结尾的所有文件的列表。如果您手动运行`ls /var/log/*.log`命令，您会注意到该格式与我们在 Bash 风格语法中看到的其他格式相同:单个单词，空格分隔。正因为如此，我们现在可以按顺序操作我们找到的所有文件了！让我们看看如果我们尝试在这些文件中进行 grep 会发生什么:

```sh
reader@ubuntu:~/scripts/chapter_11$ cat for-globbing.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.1.0
# Date: 2018-10-27
# Description: Combining globbing patterns in a for loop.
# Usage: ./for-globbing.sh 
#####################################

# Create a list of log files.   
for file in $(ls /var/log/*.log); do
  echo "File: ${file}"
  grep -i 'error' ${file}
done
```

自从我们改变了剧本的内容，我们把版本从`v1.0.0`提升到了`v1.1.0`。如果您现在运行此脚本，您将看到一些文件在 grep 上返回正匹配，而其他文件则没有:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash for-globbing.sh 
File: /var/log/alternatives.log
File: /var/log/auth.log
File: /var/log/bootstrap.log
Selecting previously unselected package libgpg-error0:amd64.
Preparing to unpack .../libgpg-error0_1.27-6_amd64.deb ...
Unpacking libgpg-error0:amd64 (1.27-6) ...
Setting up libgpg-error0:amd64 (1.27-6) ...
File: /var/log/cloud-init.log
File: /var/log/cloud-init-output.log
File: /var/log/dpkg.log
2018-04-26 19:07:33 install libgpg-error0:amd64 <none> 1.27-6
2018-04-26 19:07:33 status half-installed libgpg-error0:amd64 1.27-6
2018-04-26 19:07:33 status unpacked libgpg-error0:amd64 1.27-6
<SNIPPED>
File: /var/log/kern.log
Jun 30 18:20:32 ubuntu kernel: [    0.652108] RAS: Correctable Errors collector initialized.
Jul  1 09:31:07 ubuntu kernel: [    0.656995] RAS: Correctable Errors collector initialized.
Jul  1 09:42:00 ubuntu kernel: [    0.680300] RAS: Correctable Errors collector initialized.
```

太好了，现在我们已经用一个复杂的 for 循环完成了同样的事情，我们也可以直接用`grep`完成！现在，在我们确定文件包含单词`error`后，让我们让我们的钱物有所值，并对文件做些事情:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-globbing.sh 
reader@ubuntu:~/scripts/chapter_11$ cat for-globbing.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.2.0
# Date: 2018-10-27
# Description: Combining globbing patterns in a for loop.
# Usage: ./for-globbing.sh 
#####################################

# Create a directory to store log files with errors.
ERROR_DIRECTORY='/tmp/error_logfiles/'
mkdir -p ${ERROR_DIRECTORY}

# Create a list of log files. 
for file in $(ls /var/log/*.log); do
 grep --quiet -i 'error' ${file}

 # Check the return code for grep; if it is 0, file contains errors.
 if [[ $? -eq 0 ]]; then
 echo "${file} contains error(s), copying it to archive."
 cp ${file} ${ERROR_DIRECTORY} # Archive the file to another directory.
 fi

done

reader@ubuntu:~/scripts/chapter_11$ bash for-globbing.sh 
/var/log/bootstrap.log contains error(s), copying it to archive.
/var/log/dpkg.log contains error(s), copying it to archive.
/var/log/kern.log contains error(s), copying it to archive.
```

下一个版本`v1.2.0`做了一个安静的`grep`(没有输出，因为我们只是想在发现什么的时候退出状态为 0)。紧接在`grep`之后，我们使用嵌套的`if-then`将文件复制到我们在脚本开头定义的归档目录中。当我们现在运行该脚本时，我们可以看到在该脚本的前一版本中生成输出的相同文件，但是现在它复制了整个文件。此时，`for`循环正在证明它的价值:我们现在对使用 globbing 模式找到的单个文件执行多个操作。让我们更进一步，从存档文件中删除所有不包含错误的行:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-globbing.sh 
reader@ubuntu:~/scripts/chapter_11$ cat for-globbing.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.3.0
# Date: 2018-10-27
# Description: Combining globbing patterns in a for loop.
# Usage: ./for-globbing.sh 
#####################################

# Create a directory to store log files with errors.
ERROR_DIRECTORY='/tmp/error_logfiles/'
mkdir -p ${ERROR_DIRECTORY}

# Create a list of log files.   
for file in $(ls /var/log/*.log); do
  grep --quiet -i 'error' ${file}

  # Check the return code for grep; if it is 0, file contains errors.
  if [[ $? -eq 0 ]]; then
    echo "${file} contains error(s), copying it to archive ${ERROR_DIRECTORY}."
    cp ${file} ${ERROR_DIRECTORY} # Archive the file to another directory.

    # Create the new file location variable with the directory and basename of the file.
    file_new_location="${ERROR_DIRECTORY}$(basename ${file})"
    # In-place edit, only print lines matching 'error' or 'Error'.
    sed --quiet --in-place '/[Ee]rror/p' ${file_new_location} 
  fi

done
```

版本 v1.3.0！为了保持可读性，我们没有包括对`cp`和`mkdir`命令的错误检查。然而，由于这个脚本的性质(在`/tmp/`中创建一个子目录并在那里复制文件)，出现问题的可能性非常小。我们添加了两个新的有趣的东西:一个名为`file_new_location`的新变量，带有新位置的文件名和`sed`，这确保了只有错误行保留在归档文件中。

首先我们来考虑`file_new_location=${ERROR_DIRECTORY}$(basename ${file})`。我们正在做的是将两个字符串粘贴在一起:首先是归档目录，然后是处理后文件的*基本名称。*`basename`命令剥离文件的全限定路径，只保留路径叶子处的文件名不变。如果我们看一下 Bash 解析这个新变量的步骤，它可能看起来像这样:

*   `file_new_location=${ERROR_DIRECTORY}$(basename ${file})`
    `-> resolve ${file}`
*   `file_new_location=${ERROR_DIRECTORY}$(basename /var/log/bootstrap.log)`
    `-> resolve $(basename /var/log/bootstrap.log)`
*   `file_new_location=${ERROR_DIRECTORY}bootstrap.log`
    `-> resolve ${ERROR_DIRECTORY}`
*   `file_new_location=/tmp/error_logfiles/bootstrap.log`
    `-> done, final value of variable!`

有了这些，我们现在可以在那个新文件上运行`sed`。`sed --quiet --in-place '/[Ee]rror/p' ${file_new_location}`命令只是用符合`[Ee]rror`正则表达式搜索模式的所有行替换文件的内容，这(几乎)是我们最初的 grep。记住，我们需要`--quiet`，因为默认情况下，`sed`打印所有行。如果我们忽略这一点，我们将得到文件中的所有行，但是所有的错误文件将被复制:一次来自`sed`的非安静输出，一次来自搜索模式匹配。但是，当- quiet 处于活动状态时，`sed`仅打印匹配的行并将它们写入文件。让我们在实践中看到这一点，并验证结果:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash for-globbing.sh 
/var/log/bootstrap.log contains error(s), copying it to archive /tmp/error_logfiles/.
/var/log/dpkg.log contains error(s), copying it to archive /tmp/error_logfiles/.
/var/log/kern.log contains error(s), copying it to archive /tmp/error_logfiles/.
reader@ubuntu:~/scripts/chapter_11$ ls /tmp/error_logfiles/
bootstrap.log  dpkg.log  kern.log
reader@ubuntu:~/scripts/chapter_11$ head -3 /tmp/error_logfiles/*
==> /tmp/error_logfiles/bootstrap.log <==
Selecting previously unselected package libgpg-error0:amd64.
Preparing to unpack .../libgpg-error0_1.27-6_amd64.deb ...
Unpacking libgpg-error0:amd64 (1.27-6) ...

==> /tmp/error_logfiles/dpkg.log <==
2018-04-26 19:07:33 install libgpg-error0:amd64 <none> 1.27-6
2018-04-26 19:07:33 status half-installed libgpg-error0:amd64 1.27-6
2018-04-26 19:07:33 status unpacked libgpg-error0:amd64 1.27-6

==> /tmp/error_logfiles/kern.log <==
Jun 30 18:20:32 ubuntu kernel: [    0.652108] RAS: Correctable Errors collector initialized.
Jul  1 09:31:07 ubuntu kernel: [    0.656995] RAS: Correctable Errors collector initialized.
Jul  1 09:42:00 ubuntu kernel: [    0.680300] RAS: Correctable Errors collector initialized.
```

可以看到，每个文件顶部的三行都包含`error`或`Error`字符串。实际上，所有这些文件中的所有行都包含这些字符串中的任何一个；请务必在您自己的系统上验证这一点，因为内容无疑会有所不同。

既然我们已经完成了这个例子，我们有一些挑战给读者，您是否愿意接受它们:

*   让这个脚本接受输入。这可能是归档目录、路径 glob、搜索模式，甚至三者都有！
*   通过给*可能会*失败的命令添加异常处理，使这个脚本更加健壮。
*   通过使用`sed '/xxx/d'`语法来反转这个脚本的功能(提示:您可能需要为此进行重定向)。

While this example should illustrate a lot of things, we realize that just searching on the word `error` does not actually only return errors. Actually, most of what we saw being returned was related to an installed package, `liberror`! In practice, you might be working with log files that have a predefined structure when it comes to errors. In this case, it is much easier to determine a search pattern that only logs real errors.

# 循环控制

此时，您应该对使用`while`和`for`循环感到舒适。关于回路，还有一个相当重要的话题需要讨论:**回路控制**。循环控制是一个通用术语，指的是你对循环所做的任何事情！然而，如果我们想释放循环的全部力量，我们需要两个*关键词*:`break`和`continue`。我们从`break`开始。

# 打破循环

对于一些脚本逻辑来说，打破循环将被证明是必要的。你可能会想象，在你的一个脚本中，你正在等待一些事情完成。一旦发生这种情况，你就想*做点什么*。在`while true`循环中等待和定期检查可能是一种选择，但是如果你回想一下`while-interactive.sh`脚本，我们在成功回答这个谜语后退出。在出口处，我们不能运行任何超出`while`循环的命令！这就是`break`发挥作用的地方。它允许我们退出*循环*，但继续*脚本*。首先，让我们更新`while-interactive.sh`来利用这个循环控制关键字:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim while-interactive.sh 
reader@ubuntu:~/scripts/chapter_11$ cat while-interactive.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.1.0
# Date: 2018-10-28
# Description: A simple riddle in a while loop.
# Usage: ./while-interactive.sh
#####################################

# Infinite loop, only exits on correct answer.
while true; do
  read -p "I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? " answer
  if [[ ${answer} =~ [Kk]eyboard ]]; then # Use regular expression so 'a keyboard' or 'Keyboard' is also a valid answer.
    echo "Correct, congratulations!"
    break # Exit the while loop.
  else
    # Print an error message and go back into the loop.
    echo "Incorrect, please try again."
  fi
done

# This will run after the break in the while loop.
echo "Now we can continue after the while loop is done, awesome!"
```

我们做了三个改变:

*   采用了更高的版本号
*   将`exit 0`替换为`break`
*   while 循环后增加了一个简单的`echo`

当我们还有`exit 0`的时候，最后的`echo`绝对不会跑(但是不要相信我们，一定要自己验证这一点！).现在，用`break`运行它并观察:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash while-interactive.sh 
I have keys but no locks. I have a space but no room. You can enter, but can’t go outside. What am I? keyboard
Correct, congratulations!
Now we can continue after the while loop is done, awesome!
```

又来了，一个中断的`while`循环后的代码执行。通常，在无限循环之后，肯定还有其他代码需要执行，这就是执行的方式。

我们不仅可以在`while`循环中使用`break`，而且最确定的是在`for`循环中。以下示例显示了我们如何在`for`循环中使用`break`:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-loop-control.sh
reader@ubuntu:~/scripts/chapter_11$ cat for-loop-control.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-28
# Description: Loop control in a for loop.
# Usage: ./for-loop-control.sh
#####################################

# Generate a random number from 1-10.
random_number=$(( ( RANDOM % 10 )  + 1 ))

# Iterate over all possible random numbers.
for number in {1..10}; do

  if [[ ${number} -eq ${random_number} ]]; then
    echo "Random number found: ${number}."
    break # As soon as we have found the number, stop.
  fi

  # If we get here the number did not match.
  echo "Number does not match: ${number}."
done
echo "Number has been found, all done."
```

在这个脚本功能的顶部，确定了一个 1 到 10 之间的随机数(不要担心语法)。接下来，我们迭代数字 1 到 10，对于每个数字，我们将检查它是否等于随机生成的数字。如果是，我们打印成功信息*并打破循环*。否则，我们将超出`if-then`块并打印失败消息。如果不包含 break 语句，输出将如下所示:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash for-loop-control.sh 
Number does not match: 1.
Number does not match: 2.
Number does not match: 3.
Random number found: 4.
Number does not match: 4.
Number does not match: 5.
Number does not match: 6.
Number does not match: 7.
Number does not match: 8.
Number does not match: 9.
Number does not match: 10.
Number has been found, all done.
```

我们不仅看到打印的数字既匹配又不匹配(当然，这是一个逻辑错误)，而且当我们确定这些数字不匹配时，脚本还会继续检查所有其他数字。现在，如果我们使用 exit 而不是 break，将永远不会打印最终声明:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash for-loop-control.sh 
Number does not match: 1.
Number does not match: 2.
Number does not match: 3.
Number does not match: 4.
Number does not match: 5.
Number does not match: 6.
Random number found: 7.
```

只有通过使用`break`我们才能准确地得到我们需要的产出量；不多也不少。你可能已经看到，我们也可以在`Number does not match:`信息中使用`else`子句。尽管如此，没有什么能阻止这个项目。因此，即使第一次尝试就找到了随机数(最终会发生)，它仍然会比较列表中的所有值，直到到达该列表的末尾。

这不仅浪费时间和资源，而且想象一下，如果随机数在 1 到 1，000，000 之间，输出会是什么样子！只要记住:如果你完成了循环，**打破它。**

# continue 关键字

和 Bash(和人生)中的大多数事情一样，阴中有阳，那就是`break`:`continue`这个关键词。如果使用继续，则告诉循环停止当前循环，但*继续下一次运行*。因此，您将停止当前迭代，而不是停止整个循环。让我们看看另一个例子是否能说明这一点:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim for-continue.sh
reader@ubuntu:~/scripts/chapter_11$ cat for-continue.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-28
# Description: For syntax with a continue.
# Usage: ./for-continue.sh
#####################################

# Look at numbers 1-20, in steps of 2.
for number in {1..20..2}; do
  if [[ $((${number}%5)) -eq 0 ]]; then
    continue # Unlucky number, skip this!
  fi

  # Show the user which number we've processed.
  echo "Looking at number: ${number}."

done
```

在这个例子中，所有能被 5 整除的数字都被认为是不吉利的，不应该被处理。这是通过`[[ $((${number}%5)) -eq 0 ]]`条件实现的:

*   **[[**$($ { number } % 5))**-eq 0]]**->测试语法
*   [[**$((**$ { number } % 5**))**-eq 0]]->算术语法
*   [[$((**$ { number } % 5**))-eq 0]]->变量的模 5**数**

如果这个数通过了这个测试(因此可以被 5 整除，比如 5、10、15、20 等等)，就执行`continue`。当这种情况发生时，循环的下一次迭代运行(并且`echo`是**而不是**被执行！)，运行此脚本时可以看到:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash for-continue.sh 
Looking at number: 1.
Looking at number: 3.
Looking at number: 7.
Looking at number: 9.
Looking at number: 11.
Looking at number: 13.
Looking at number: 17.
Looking at number: 19.
```

正如列表所暗示的，数字`5`、`10`和`15`被处理，但是我们在`echo`中看不到它们。我们也可以看到之后的一切，这在`break`身上是不会发生的。用`bash -x`验证这是否真的发生(警告:输出负载！)并检查如果用`break`甚至`exit`替换`continue`会发生什么。

# 循环控制和嵌套

在本章的最后部分，我们将向您展示如何通过循环控制来影响`nested`循环。break 和 continue 都需要一个额外的参数:一个指定要中断哪个循环的数字。默认情况下，如果省略此参数，则假定为`1`。所以，`break`命令等于`break 1`，`continue 1`和`continue`一样。如前所述，理论上我们可以随心所欲地嵌套循环；你很可能比现代系统的技术能力问题更早地触及逻辑问题！我们将看一个简单的例子，向我们展示如何使用`break 2`不仅脱离`for`循环，还脱离外部`while`循环:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim break-x.sh 
reader@ubuntu:~/scripts/chapter_11$ cat break-x.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-10-28
# Description: Breaking out of nested loops.
# Usage: ./break-x.sh
#####################################

while true; do
  echo "This is the outer loop."
  sleep 1

  for iteration in {1..3}; do
    echo "This is inner loop ${iteration}."
    sleep 1
  done
done
echo "This is the end of the script, thanks for playing!"
```

这个第一版脚本不包含`break`。当我们运行这个程序时，我们永远看不到最终的信息，我们会得到一个无穷无尽的重复模式:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash break-x.sh 
This is the outer loop.
This is inner loop 1.
This is inner loop 2.
This is inner loop 3.
This is the outer loop.
This is inner loop 1.
^C
```

现在，让我们在迭代到达`2`时打破内部循环:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim break-x.sh 
reader@ubuntu:~/scripts/chapter_11$ cat break-x.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.1.0
# Date: 2018-10-28
# Description: Breaking out of nested loops.
# Usage: ./break-x.sh
#####################################
<SNIPPED>
  for iteration in {1..3}; do
    echo "This is inner loop ${iteration}."
    if [[ ${iteration} -eq 2 ]]; then
      break 1
    fi
    sleep 1
  done
<SNIPPED>
```

当我们现在运行脚本时，我们仍然会得到无限个循环，但是在两次迭代而不是三次迭代后，我们会缩短内部 for 循环:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash break-x.sh 
This is the outer loop.
This is inner loop 1.
This is inner loop 2.
This is the outer loop.
This is inner loop 1.
^C
```

现在，让我们使用`break 2`命令指示内环脱离外环:

```sh
reader@ubuntu:~/scripts/chapter_11$ vim break-x.sh 
reader@ubuntu:~/scripts/chapter_11$ cat break-x.sh 
#!/bin/bash

#####################################
# Author: Sebastiaan Tammer
# Version: v1.2.0
# Date: 2018-10-28
# Description: Breaking out of nested loops.
# Usage: ./break-x.sh
#####################################
<SNIPPED>
    if [[ ${iteration} -eq 2 ]]; then
      break 2 # Break out of the outer while-true loop.
    fi
<SNIPPED>
```

看，一个内环成功地打破了一个外环:

```sh
reader@ubuntu:~/scripts/chapter_11$ bash break-x.sh 
This is the outer loop.
This is inner loop 1.
This is inner loop 2.
This is the end of the script, thanks for playing!
```

我们开始了，完全控制我们的循环，即使当我们根据脚本需要嵌套很多循环时。同样的理论也适用于`continue`。如果，在这个例子中，我们用`continue 2`代替`break 2`，我们仍然会得到一个无限循环(因为虽然真永远不会结束)。然而，如果你的另一个循环也是一个`for`或非无限的`while`循环(在我们的经验中，这是更常见的，但不是一个很好的简单的例子)，`continue 2`可以让你精确地执行情况所需的逻辑。

# 摘要

本章专门介绍条件测试和脚本循环。因为我们已经讨论了`if-then-else`语句，所以在继续展示条件测试工具包的更高级的用途之前，我们概括了这些信息。这些高级信息包括在条件测试场景中使用正则表达式，这是我们在上一章中了解到的，以便进行更灵活的测试。我们还向您展示了如何使用`elif`(T2 的缩写)顺序测试多个条件。我们解释了如何嵌套多个`if-then-else`语句来创建高级逻辑。

在本章的第二部分，我们介绍了`while`循环。我们向您展示了如何使用它来创建一个无限期运行的脚本，或者如何在满足某个条件时使用条件来停止循环。我们给出了`until`关键字，它具有与`while`相同的功能，但是允许对`while`进行否定检查而不是肯定检查。我们在`while`上结束了解释，向您展示了如何在无休止的`while`循环中创建交互式脚本(使用我们的老朋友`read`)。

`while`之后，我们引入了更强大的`for`循环。这个循环可以做`while`可以做的同样的事情，但是通常更短的语法允许我们写更少的代码(和更可读的代码，这仍然是脚本中非常重要的一个方面！).我们向您展示了`for`如何遍历列表，以及如何使用*括号扩展*创建数字列表。我们结束了对`for`循环的讨论，给出了一个将`for`与文件全局模式相结合的实际例子，允许我们动态地查找、抓取和处理文件。

本章最后我们解释了循环控制，这是在 Bash 中用`break`和`continue`关键字实现的。这些关键词允许我们*打破*出一个循环(甚至从嵌套循环，尽可能远地回到我们需要的外部)，也允许我们停止循环的当前迭代，*继续*到下一个迭代。

本章介绍了以下命令/关键词:`elif`、`help`、`while`、`sleep`、`for`、`basename`、`break`和`continue`。

# 问题

1.  一个`if-then` ( `-else`)语句是怎么结束的？
2.  如何在条件求值中使用正则表达式搜索模式？
3.  为什么我们需要`elif`这个关键词？
4.  什么是*嵌套*？
5.  我们如何获得关于如何使用 shell 内置函数和关键字的信息？
6.  `while`的反义词是什么？
7.  为什么我们会选择 for 循环而不是`while`循环？
8.  什么是大括号扩展，我们可以在哪些字符上使用它？
9.  哪两个关键词可以让我们对循环进行更精细的控制？
10.  如果我们是嵌套循环，我们如何利用循环控制从内部循环影响外部循环？

# 进一步阅读

如果您想深入了解本章的主题，以下资源可能会很有意思:

*   **案情** **陈述**:[http://tldp . org/LDP/Bash-初学者-指南/html/section _ 07 _ 03 . html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)

*   **拉条扩张**:[http://wiki.bash-hackers.org/syntax/expansion/brace](http://wiki.bash-hackers.org/syntax/expansion/brace)
*   **关于循环的 Linux 文档项目**:[http://www.tldp.org/LDP/abs/html/loops1.html](http://www.tldp.org/LDP/abs/html/loops1.html)**