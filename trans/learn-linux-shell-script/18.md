# 十八、答案

# 第二章

1.  **运行虚拟机比裸机安装更可取的一些原因是什么？**
    *   虚拟机可以在当前首选的操作系统中运行，而不是替换它或设置复杂的双启动解决方案。
    *   可以对虚拟机进行快照，这意味着可以保留和恢复虚拟机的整个状态。
    *   许多不同的操作系统可以同时在一台机器上运行。
2.  **与裸机安装相比，运行虚拟机有哪些缺点？**
    *   虚拟化会带来一些开销。
    *   与运行裸机安装相比，总是会使用更多的资源(CPU/RAM/磁盘)。
3.  **1 型和 2 型虚拟机管理程序有什么区别？**
    Type-1 虚拟机管理程序直接安装在物理机上(例如 VMWare vSphere、KVM、Xen)，而 type-2 虚拟机管理程序安装在已经运行的操作系统上(例如 VirtualBox、VMWare Workstation Player)。
4.  **我们可以通过哪两种方式在 VirtualBox 上启动虚拟机？**
    *   正常情况下，这将打开一个带有终端控制台(或图形用户界面，如果安装了桌面环境)的新窗口。
    *   无头，将虚拟机作为服务器运行，没有图形用户界面。
5.  **Ubuntu LTS 版有什么特别之处？**
    LTS 代表长期支持。Ubuntu LTS 版本保证更新五年，而不是常规 Ubuntu 版本的九个月。
6.  **如果 Ubuntu 安装后，虚拟机再次引导到 Ubuntu 安装屏幕，我们该怎么办？**
    我们应该检查虚拟硬盘的引导顺序是否高于光驱，或者我们从光驱中卸载 ISO，这样只有虚拟硬盘才是有效的引导目标。

7.  **如果我们在安装过程中不小心重启了，我们永远不会在 Ubuntu 安装中结束(而是看到一个错误)，我们该怎么办？** 我们应该确保光盘在引导顺序上高于虚拟硬盘，并且我们需要确保光盘上安装了 ISO。
8.  **我们为什么要为虚拟机设置 NAT 转发？**
    所以我们不局限于使用终端控制台，而是可以使用更丰富的 SSH 工具，比如 PuTTY 或者 MobaXterm。

# 第三章

1.  **为什么语法高亮是文本编辑器的一个重要特性？** 通过使用颜色，很容易发现语法错误。
2.  **我们如何扩展 Atom 已经提供的功能？** 我们可以安装额外的软件包，甚至自己编写。
3.  **编写 shell 脚本时自动完成有什么好处？**
    *   它减少了类型，尤其是对于多行结构。
    *   这样更容易找到命令。
4.  **如何描述 Vim 和 GNU nano 的区别？** Nano 简单，Vim 强大。
5.  **Vim 中最有趣的两种模式是哪一种？** 正常模式和插入模式。
6.  **是什么。vimrc 文件？** 用于配置 Vim 的持久选项，比如配色方案以及如何处理标签。
7.  **当我们称 nano 为所见即所得编辑器是什么意思？**
    所见即所得代表所见即所得，也就是说你可以开始用光标打字。
8.  **为什么我们要把 GUI 编辑器和命令行编辑器结合起来？** 因为用 GUI 编辑器更容易写，但是用命令行编辑器更容易排除故障。

# 第四章

1.  **什么是文件系统？**
    在物理介质上存储和检索数据的软件实现。
2.  **哪些特定于 Linux 的文件系统最常见？**
    *   ext4
    *   XFS
    *   btr 护堤
3.  **真真假假:Linux 上可以同时使用多个文件系统实现？**
    真；根文件系统始终是单一类型，但文件系统树的不同部分可用于装载其他类型的文件系统。
4.  **大多数 Linux 文件系统实现中的日志功能是什么？**
    日志是确保对磁盘的写入不会中途失败的机制。它大大提高了文件系统的可靠性。
5.  **根文件系统装载在树中的哪个点？**在最高点`/.`上
6.  **PATH 变量用于什么？**
    用于确定从哪个目录可以使用二进制文件。您可以使用命令“echo $PATH”检查路径变量的内容。
7.  **根据文件系统层次标准，配置文件存储在哪个顶级目录中？**
    在`/etc/`。
8.  **流程日志通常保存在哪里？**
    在`/var/log/`。
9.  【Linux 有多少种文件类型？
    7
10.  **Bash 自动完成功能是如何工作的？**
    对于支持自动完成功能的命令，可以使用 TAB 键一次获取正确的参数(如果只有一种可能)，或者使用 TAB 键两次获取可能的参数列表。

# 第五章

1.  【Linux 文件使用哪三种权限？
    *   阅读
    *   写
    *   执行
2.  【Linux 文件定义了哪三种所有权类型？
    *   用户
    *   组
    *   其他人
3.  **哪个命令用于更改文件的权限？**
    `chmod`
4.  **什么机制控制新创建文件的默认权限？**
    `umask`
5.  **如何用八进制描述以下符号许可:** rwxrw-r -
    0764。前三名(用户)从 rwx 开始 7 个，后三名(组)从`rw-`开始 6 个，后三名(其他)从`r--`开始 4 个。
6.  **下面的八进制权限如何象征性的描述:** 0644
    rw-r - r -。第一个 6 是读/写，然后两个 4 是读。
7.  **哪个命令允许我们获得超级用户权限？**
    `sudo`
8.  **我们可以使用哪些命令来更改文件的所有权？**
    *   `chown`
    *   `chgrp`
9.  **如何安排多个用户共享文件的访问权限？** 我们确保他们共享组成员资格，并创建一个目录，其中只允许这些组的成员。
10.  【Linux 有哪些类型的高级权限？
    *   文件属性
    *   特殊文件权限
    *   访问控制列表

# 第六章

1.  **在 Linux 中我们用哪个命令复制文件？**
    `cp`。
2.  **移动文件和重命名文件有什么区别？**
    技术上没有区别。在功能上，移动会更改文件所在的目录，而重命名会将文件保留在同一目录中。两者在 Linux 中都是由`mv`命令处理的。

3.  **为什么** `rm` **命令，用来删除 Linux 下的文件，潜在危险？**
    *   它可以用来递归删除目录和目录中的任何内容
    *   (默认情况下)它不会显示“你确定吗？”提示
    *   它允许您使用通配符删除文件
4.  **硬链接和符号(软)链接有什么区别？**
    硬链接指的是文件系统上的数据，而符号链接指的是文件(而文件又指的是文件系统上的数据)。
5.  **`tar`最重要的三种运行模式是什么？**
    *   存档模式
    *   提取模式
    *   打印模式
6.  **哪个选项被`tar`用来选择输出目录？**
    `-C`
7.  **在文件名上搜索`locate`和`find`最大的区别是什么？**
    默认情况下，定位允许部分命名匹配，而如果需要部分匹配，查找需要指定通配符。
8.  **可以组合`find`的多少个选项？**
    搜索需要多少就有多少！这正是`find`如此强大的原因。

# 第七章

1.  **按照惯例，当我们学习一门新的编程或脚本语言时，首先要做什么？**
    我们打印字符串“你好世界”。
2.  【Bash 的 shebang 是什么？
    #！/bin/bash
3.  **为什么需要舍邦？**
    如果我们在运行脚本时没有指定应该使用哪个程序，shebang 将允许 Linux 使用正确的程序。
4.  **我们可以用哪三种方式运行一个脚本？**
    *   通过使用我们想要运行它的程序:`bash script.sh`
    *   通过设置可执行权限并在 scriptname 前面加上。/: ``./script.sh``

5.  **为什么我们在创建 shell 脚本时如此强调可读性？**
    *   如果使用脚本的人能够容易地理解脚本的作用，那么脚本就更容易使用了
    *   如果你以外的任何人需要编辑剧本(几个月后你也可以认为自己是“别人”！)如果简单易懂，会有很大帮助
6.  **我们为什么要用评论？**
    所以我们可以解释脚本中那些仅仅看命令可能不明显的东西。此外，它还允许我们给出一些设计原理，如果这有助于澄清脚本。
7.  **为什么我们建议为你写的所有 shell 脚本都包含一个脚本头？**
    If 给了一点关于作者的信息，年龄和对剧本的描述。它有助于为脚本提供上下文，这在脚本没有按预期工作或需要修改时非常有用。
8.  **我们讨论过哪三种类型的冗长？**
    *   评论冗长
    *   命令冗长
    *   命令输出冗长
9.  **KISS 原理是什么？**
    KISS，代表*保持简单，愚蠢*，是一个设计建议，帮助我们记住我们应该保持简单，因为这通常会提高可用性和可读性，同时在大多数情况下也是最好的解决方案。

# 第八章

1.  **什么是变量？**
    变量是编程语言的基本构件，用于存储在应用中可以多次引用的运行时值。
2.  **我们为什么需要变量？**
    变量非常适合存储您多次需要的信息。在这种情况下，如果您需要更改信息，这是一个单一的操作(在常量的情况下)。在实变量的情况下，它允许我们引用程序中的运行时信息。

最后，适当的变量命名允许我们向脚本授予额外的上下文，增加可读性。

3.  **什么是常数？**
    常数是一种特殊类型的变量，因为它的值是固定的，并在整个脚本中使用。正常变量在执行过程中经常会发生多次变异。
4.  **为什么命名约定对变量特别重要？**
    Bash 让我们几乎可以给任何变量命名。因为这会变得令人困惑(这从来都不是一件好事！)选择一个命名约定并坚持它是很重要的:这增加了我们脚本的一致性和连贯性。
5.  **什么是位置论点？**
    当您调用 Bash 脚本时，可以在脚本中访问在`bash scriptname.sh`命令之后传递的任何其他文本，因为该文本被认为是脚本的*参数*。每个没有用引号括起来的单词都被当作一个参数来处理:一个多单词的参数应该用引号括起来！
6.  **参数和自变量有什么区别？**
    参数用于填充脚本的参数。参数是脚本逻辑中使用的*静态变量名*，而参数是用作参数的*运行时值*。
7.  **怎样才能让一个剧本互动起来？**
    通过使用`read`命令。我们可以将用户给出的值存储在我们选择的变量中，否则我们可以使用默认的$REPLY 变量。
8.  **如何才能创建一个既能非交互又能交互使用的脚本？**
    通过将(可选的)位置参数与`read`命令相结合。为了在启动脚本的逻辑之前验证我们拥有所有需要的信息，我们使用`if-then`构造和`test`命令来查看我们所有的变量是否都已填充。

# 第九章

1.  **为什么我们需要退出状态？**
    因此，如果命令以简单的方式成功或失败，它们可以向调用者发出信号。
2.  **退出状态、退出代码、返回代码有什么区别？**
    一个退出码和返回码指的是同一个东西。退出状态是一个*概念*，由退出/返回代码赋予生命。

3.  **我们在测试中使用哪个标志来测试:**
    *   *一个现有的目录*
        -维
    *   *一个可写文件*
        -w
    *   *一个现有的符号链接*
        -h(或-L)
4.  **首选的`test -d /tmp/`速记语法是什么？**
    [-d/tmp/]]。请注意,[[和]之前的空格是必需的，否则命令将失败！
5.  **我们如何在 Bash 会话中打印调试信息？**
    设置-x 标志，可以在 shell 中用`set -x`或者在调用脚本时用`bash -x`设置。
6.  **如何检查一个变量是否有内容？**
    *   if [[ -n ${variable} ]]检查变量是否非零
    *   if [!-z ${variable} ]]检查变量是否不为零
7.  **抓取返回代码的 Bash 格式是什么？**
    $？。
8.  **的||和&的&，哪个是逻辑的 and，哪个是 OR？**
    ||是 OR，& &是 AND。
9.  **抓取参数数量的 Bash 格式是什么？**
    $#。
10.  **我们如何确保用户从哪个工作目录调用脚本并不重要？**
    通过提供一个`cd $(dirname $0)`开头的脚本。
11.  **Bash 参数展开在处理用户输入时如何帮助我们？**
    它允许我们删除大写字母，这样我们就可以更容易地与期望值进行比较。

# 第十章

1.  **什么是搜索模式？**
    一种正则表达式语法，它允许我们找到具有特定特征的文本片段，例如长度、内容和在一行中的位置。
2.  **为什么正则表达式被认为是贪婪的？**
    大多数正则表达式试图找到尽可能多的与搜索模式匹配的数据。这包括空白和其他标点符号，这对人类来说是一个逻辑上的分离，但对机器来说不一定。
3.  **搜索模式中的哪个字符被认为是除换行符以外的任何一个字符的通配符？**
    圆点(。).
4.  **星号在 Linux 正则表达式搜索模式中是如何使用的？**
    *与另一个字符结合使用，使其形成重复字符。搜索模式示例:spe*d 将匹配 spd、速度、速度、速度等。
5.  **什么是线锚？**
    用来表示行首和行尾的特殊字符。^为行首，美元为行尾。
6.  **说出三种字符类型。**
    这些都是正确的:
    *   含字母和数字的
    *   字母表
    *   小写字母
    *   大写字母
    *   数字
    *   空白
7.  **什么是球状？**
    当你使用*或时，就完成了全球定位？在命令行上与文件或文件路径交互时。Globbing 允许我们轻松地操作(移动、复制、删除等)在 globbing 模式下匹配的文件。
8.  **在扩展的正则表达式语法中，有什么是可能的，而在 Bash 下的普通正则表达式是不可能的？**
    *   一个或多个重复字符
    *   重复字符的准确数量
    *   重复字符的范围
    *   不止一个字符的变化
9.  **在决定使用`grep`还是`sed`之间，有什么好的经验法则？**
    如果你的目标只用一句`grep`就能实现，那就选择简约。如果无法以这种方式实现，请选择`sed`以获得更强大的语法。

10.  **为什么 Linux/Bash 上的正则表达式这么难？**
    有很多不同的实现是相似的。对于正则表达式和它们的难点，这种混淆没有帮助。只有实践和经验才能弥补这一点！

# 破产重组保护

1.  **if-then(-else)语句如何结束？**
    同 if 字的反义词:`fi`
2.  **如何在条件求值中使用正则表达式搜索模式？**
    通过使用=~比较符号。例如:`[[ ${var} =~ [[:digit:]] ]]`
3.  **为什么我们需要`elif`这个关键词？**
    如果我们想连续测试多个条件，我们可以使用 else if ( `elif`)。
4.  **什么是*筑巢*？**
    在另一个 if-then-else 语句或循环中使用`if-then-else`语句或循环。
5.  **我们如何获得如何使用 shell 内置程序和关键字的信息？**
    通过使用命令`help`，后跟我们想要了解的内置或关键字。例如:`help [[`
6.  **与`while`相反的关键词是什么？**
    `until`。一个 while 循环运行，直到条件不再*为真，*一个 while 循环运行，直到条件不再*为假*。
7.  **为什么我们会选择 for 循环而不是 while 循环？**
    `for`功能更强大，有许多方便的速记语法，用`while`很难或不可读。
8.  **什么是大括号展开，可以在哪些字符上使用？**
    大括号扩展允许我们编写非常短的代码，它基于 ASCII 字符生成一个空白分隔的列表。例如:`{1..10}`打印数字 1 到 10，中间有空格。我们也可以将它用于大写或小写字母，或者 ASCII 字符集中的任何范围。
9.  **哪两个关键词可以让我们对循环进行更精细的控制？**
    `break`和`continue`。`break`停止当前循环，而`continue`跳到循环中的下一个迭代。

10.  **如果我们是嵌套循环，我们如何利用循环控制从内部循环影响外部循环？**
    通过在`break`或`continue`关键字中添加一个大于 1 的数字。示例:`break 2`从内环和一个外环都存在。

# 第十二章

1.  **什么是文件描述符？**
    Linux 用作输入/输出接口的文件或设备的句柄。
2.  **术语 stdin、stdout 和 stderr 是什么意思？**
    *   标准输入。用于输入命令。
    *   标准输出。用于命令的正常输出。
    *   标准误差。用于命令的错误输出。
3.  **如何将 stdin、stdout、stderr 映射到默认文件描述符？**
    stdin 绑定到 fd0，stdout 绑定到 fd1，stderr 绑定到 fd2。
4.  **输出重定向`>`、`1>`和`2>`有什么区别？**
    `>`和`1>`相等，指重定向 stdout。`2>`用于重定向 stderr。
5.  **`>`和`>>`有什么区别？**
    `>`会覆盖已经有内容的文件，而`>>`会追加到文件中。
6.  **如何同时重定向 stdout 和 stderr？**
    *   使用`&>`(和`&>>`)
    *   通过将 stderr 绑定到 stdout，使用`2>&1`
    *   通过管道`|&`
7.  **哪些特殊器件可以作为输出黑洞？**
    /dev/null 和/dev/zero。
8.  **管道在转向方面有什么作用？**
    它将一个命令的 stdout/stderr 绑定到另一个命令的 stdin。
9.  **我们如何向终端和日志文件发送输出？**
    通过管道传递`tee`命令，最好使用`|&`，这样 stdout 和 stderr 都会被转发。
10.  **这里的字符串的典型用例是什么？**
    如果我们想直接向命令的 stdin 提供输入，我们可以使用这里的字符串。`bc`就是一个很好的例子。

# 第十三章

1.  **我们可以通过哪两种方式定义函数？**
    *   name() {
        }
    *   功能名称{
        }
2.  **函数有哪些优点？**
    *   易于重用的代码
    *   促进代码共享
    *   抽象复杂代码
3.  **全局作用域变量和局部作用域变量有什么区别？**
    局部范围的变量只在函数中有效，全局范围的变量可以在整个脚本中使用(甚至在函数中)。
4.  **如何设置变量的值和属性？**
    通过使用`declare`命令。
5.  **函数如何使用传递给它的参数？**
    同脚本一样可以:通过使用$1、$#、$@，等等。
6.  **如何从函数中返回值？**
    通过输出到 stdout。调用函数的命令应该知道使用命令替换来捕获输出。
7.  **命令做什么？**
    它从当前 shell 中的一个文件执行命令。如果源文件只包含函数定义，这些定义将被加载以供以后使用(但仍然只在当前 shell 中)。
8.  **我们为什么要创建函数库？**
    很多实用功能，比如参数检查、错误处理和颜色设置，永远不会改变，有时可能会很复杂。如果我们正确地执行了一次，我们就可以使用库中的预定义函数，而不需要复制旧脚本中的代码。

# 第十四章

1.  **什么是调度？**
    调度允许我们定义脚本应该在何时以及如何运行，而不需要用户在那时进行交互。
2.  **临时调度是什么意思？**
    临时调度，我们通常在 Linux 上用`at`来做，是不定期重复的调度，但通常是固定时间的一次性作业。
3.  **正常运行`at`的命令输出到哪里？**
    默认情况下，`at`尝试使用`sendmail`向拥有队列/作业的用户发送本地邮件。如果没有安装 sendmail，输出就没有了。
4.  **最常见的`cron`守护进程的调度是如何实现的？**
    作为用户绑定的 crontab。
5.  **哪些命令允许您编辑个人 crontab？**
    命令`crontab -e`。此外，您可以使用`crontab -l`列出当前的 crontab，并使用`crontab -r`删除当前的 crontab。
6.  **crontab 时间戳语法中有哪五个字段？**
    1.  分钟
    2.  小时
    3.  每月的某一天
    4.  年度月份
    5.  星期几
7.  **crontab 最重要的三个环境变量是什么？**
    1.  小路
    2.  壳
    3.  邮向指示协议指示器
8.  **我们如何检查我们用`cron`安排的脚本或命令的输出？**
    我们既可以使用 crontab 中的重定向将输出写入文件，也可以使用 Linux 本地邮件功能将输出发送给我们。大多数情况下，将输出重定向到日志文件是可行的方法。
9.  **如果我们的调度脚本没有足够的输出来有效地处理日志文件，我们应该如何补救？**
    在脚本中的多个地方使用 echo 命令，向读者传达一个信息，即执行正在做预期的事情。例如:“步骤 1 已成功完成，正在继续。”“脚本执行很成功，正在退出。”。

# 第十五章

1.  **为什么旗帜经常被用作*修改器*而位置参数被用作*目标*？**
    Flags 经常修改行为:它可以让一个脚本或多或少变得冗长，或者可能把输出写在某个地方。通常，一个命令操作一个文件，该文件被认为是该命令实际试图达到的主要目标。
2.  **为什么我们在`while`循环中运行`getopts`？**
    所有标志都是按顺序解析的，当`getopts`找不到新的标志时，它会返回一个不同于 0 的退出代码，这将在正确的时刻退出`while`循环。
3.  **为什么我们需要一个？)在案件陈述中？** 我们不能相信用户可以一直正确使用所有的旗帜。？)匹配任何我们没有指定的标志，然后我们可以用它来通知用户不正确的用法。
4.  **为什么我们(有时)在案例陈述中需要一个:)？** 当 optstring 为一个选项指定了一个参数，但用户没有给出它时，就使用了:)。它允许您通知用户丢失的信息(此时您很可能会中止脚本)。
5.  **为什么我们需要一个单独的选项串，因为我们正在解决所有选项？**
    因为选项串会告诉`getopts`哪些选项有参数，哪些没有。
6.  **为什么我们在`shift`中使用 OPTIND 变量时需要减去 1？** OPTIND 变量总是指*下一个可能的索引*，这意味着它总是比找到的最终标志提前 1。因为我们只需要移开标志(它们被视为位置参数！)，我们需要确保在换挡前将 OPTIND 降低 1。
7.  **将选项与位置参数混合是个好主意吗？**
    由于处理选项和位置参数的复杂性增加，通常最好将操作的*目标*指定为`-f`标志的标志参数；-f 几乎普遍被排除作为文件引用，这将始终被视为大多数操作的逻辑目标。

# 第十六章

1.  **什么是*参数替代*？** 无非是运行时用当时的值替换变量名。
2.  **如何为我们定义的变量包含默认值？**
    使用${variable:-value}语法，其中*变量*是名称，*值*是默认值。仅当值为 null 或空(“”)时，才会使用此选项。
3.  **如何使用参数展开来处理缺失的参数值？** 虽然您通常会使用`if [[ -z ${variable} ]]; then`，但参数扩展允许您使用以下语法生成错误消息和`exit 1` : ${1:？未提供名称！}
4.  **$ { # * }是做什么的？** 它与$#(我们用来确定传递给 shell 脚本的参数数量)相同。一般的${#name}语法允许我们获取*名称*变量的长度值。
5.  **谈到参数展开时*模式替换*是如何工作的？** *模式替换*允许我们通过搜索/替换一个*模式*来获取一个变量的值并稍微修改它。
6.  **图案去除与*图案替代*** **有何关联？**
    去掉一个图案就等于什么都不用替换一个图案。通过模式移除，我们从文本的开头(前缀)和结尾(后缀)获得了额外的搜索灵活性。在处理文件路径时，模式删除非常有用。
7.  **我们可以进行哪些类型的案例修改？**
    *   用小写字体书写
    *   Shell
    *   翻转 Shell
8.  **我们可以用哪两件事从变量的值中获取子串？** 我们需要一个*偏移量*，或者一个*长度*，或者两者的组合(最常见)。