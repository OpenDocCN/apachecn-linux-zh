# *第十五章*:了解启动过程

引导过程是在您启动一台机器(物理或虚拟)和操作系统完全加载之间发生的过程。

与许多优秀的电子游戏一样，它也有三个阶段:由硬件(同样是物理或虚拟的)执行的初始启动，操作系统初始阶段的负载，以及帮助运行系统中所需服务的机制。 我们将在本章中回顾这三个阶段，我们也将添加一些技巧和技巧，以干预一个系统并执行救援行动。

在本章中，我们将涵盖所有这些主题的章节如下:

*   了解引导过程- BIOS 和 UEFI 引导
*   使用 GRUB、引导加载程序和 initrd 系统映像
*   使用 systemd 管理启动顺序
*   干预引导过程以获得对系统的访问权

很可能您不需要在引导过程的前两个阶段进行很多更改，但在紧急情况、取证或重大故障的情况下，这些要点可能非常有用。 这就是为什么仔细阅读它们很重要。

第三阶段是由**systemd**管理的阶段，在此阶段将执行更多的操作和更改，以便管理系统中默认运行的服务。 在前面的章节中，我们已经看到了要执行的大部分任务的示例; 然而，在这篇文章中，我们将提供一个全面的评论。

让我们从第一阶段开始。

# 了解引导过程- BIOS 和 UEFI 引导

计算机有硬件嵌入式软件控制器，也称为**固件**，可以让您管理最底层的硬件。 这个固件是执行第一个识别可用的硬件是系统中和硬件特性被启用(如**pre-boot 网络执行【显示】,****PXE)。**

在架构称为**电脑**(**个人电脑),也称为 x86,英特尔和 IBM 普及,嵌入式固件是被称为**BIOS**,即【显示】基本输入输出系统。**

 **在 Linux 操作系统中，BIOS 引导过程如下:

1.  机器已上电并加载 BIOS 固件。
2.  固件初始化设备，如键盘、鼠标、存储器和其他外围设备。
3.  固件读取配置，包括引导顺序，指定要使用哪个存储设备继续引导过程。
4.  一旦选择了存储设备，BIOS 将在其上加载**主引导记录**(**MBR**)，这将使**操作系统加载器**运行。 在 RHEL 中，运行的系统加载程序被称为**Grand Unified Bootloader**(**GRUB**)。
5.  GRUB 加载配置和**操作系统内核**和**初始 RAM 磁盘**。 在**Red Hat Enterprise Linux**(**RHEL**)中，内核存储在一个名为`vmlinuz`的文件中，初始引导映像存储在一个名为`initrd`的文件中。 所有 GRUB 配置`vmlinuz`和`initrd`文件都存储在`/boot`分区中。
6.  初始引导映像允许加载系统的第一个进程，也称为`init`，在 RHEL8 中为**systemd**。
7.  *systemd*加载操作系统的其余部分。

要使这个进程发生，磁盘必须有一个 MBR 分区表，并且分配给`/boot`的分区必须标记为可引导。

提示

MBR 分区表格式非常有限，只允许 4 个主分区，并使用扩展分区等扩展来克服这一限制。 除非完全需要，否则不建议使用这种类型的分区。

UEFI 引导的过程与 BIOS 的引导过程非常相似。 **UEFI**代表**统一扩展固件接口**。 引导顺序的主要区别是 UEFI 可以直接访问和读取磁盘分区。 其流程如下:

1.  机器已上电并加载 UEFI 固件。
2.  固件初始化设备，如键盘、鼠标、存储器和其他外围设备。
3.  固件读取配置，其中指定哪个存储设备和可引导分区继续引导过程(UEFI 不需要 MBR 引导)。
4.  一旦选择了存储设备，就会从**GUID 分区表**(**GPT**)读取其上的分区。 访问第一个 VFAT 格式的分区。 然后加载 EFI 引导加载程序并运行。 RHEL 中的 EFI 引导加载程序位于`/boot/efi`分区中，它继续加载 GRUB。
5.  GRUB 然后**加载操作系统内核**,在 RHEL 存储在一个文件名为`vmlinuz`和【显示】初始引导映像,这是存储在一个名为`initrd`的文件。 GRUB 配置`vmlinuz`和`initrd`文件存放在`/boot`分区。
6.  初始引导映像允许加载系统的第一个进程，也称为`init`，在 RHEL8 中为**systemd**。
7.  *systemd*加载操作系统的其余部分。

UEFI 比 BIOS 有几个优势，支持更完整的预启动环境和其他功能，如安全启动和支持 GPT 分区，可以超过 2tb 的限制，MBR 分区。

安装程序将负责创建引导，如果需要，UEFI 分区和二进制文件。

pre-boot 中需要为 Red Hat Certified System Administrator 认证而知道的部分是如何从其中加载操作系统加载程序。 通过 BIOS 或 UEFI，我们可以选择从哪个存储设备的操作系统将加载和移动到下一个阶段。 让我们进入下一节的下一个阶段。

# 使用 GRUB、引导加载程序和 initrd 系统映像

预引导执行完成后，系统将运行 GRUB 引导加载程序。

GRUB 的任务加载操作系统的主要文件,**内核**,传递参数和选项,并加载初始 RAM 磁盘,也被称为**initrd**。

GRUB 可以通过`grub2-install`命令安装。 我们需要知道将使用哪个磁盘设备来引导，在本例中为`/dev/vda`:

```
[root@rhel8 ~]# grub2-install /dev/vda
Installing for i386-pc platform.
Installation finished. No error reported.
```

重要提示

你应该将`grub-install`指向你将用来引导系统的磁盘，与你在 BIOS/UEFI 中配置引导的磁盘相同。

这可用于手动重建系统或修复损坏的引导。

GRUB 文件存放在`/boot/grub2`中。 主要配置文件为`/boot/grub2/grub.cfg`; 然而，如果你仔细看这个文件，你会看到下面的头文件:

```
[root@rhel8 ~]# head -n 6 /boot/grub2/grub.cfg 
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub2-mkconfig using templates
# from /etc/grub.d and settings from /etc/default/grub
#
```

正如您可以看到的，这个文件是自动生成的，因此不打算手动编辑。 那么我们如何对它进行更改呢? 有两种方法:

*   第一种方法是遵循`grub.cfg`文件中提到的说明。 这意味着编辑`/etc/default/grub`文件和/或`/etc/grub.d/`目录中的内容，然后运行`grub2-mkconfig`重新生成 GRUB 配置。
*   The second way is by using the `grubby` command-line tool.

    重要提示

    在 RHEL 中，当内核有一个新版本时，它不会更新，但是会在前一个内核旁边安装一个新内核，并在 GRUB 中添加一个新条目。 这样，在需要的情况下，有一种简单的方法可以回滚到以前正在工作的内核。 在安装过程中，将为新内核创建一个新的更新的`initrd`。

让我们看看使用`grubby`的当前内核配置。 `--default-kernel`选项将显示默认加载的内核文件:

```
 [root@rhel8 ~]# grubby --default-kernel
/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
```

`--default-title`选项将显示启动期间使用的名称:

```
[root@rhel8 ~]# grubby --default-title
Red Hat Enterprise Linux (4.18.0-240.15.1.el8_3.x86_64) 8.3 (Ootpa)
```

我们可以通过使用`--info`选项查看默认内核的更多信息:

```
[root@rhel8 ~]# grubby --info=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
index=0
kernel="/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64"
args="ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet $tuned_params"
root="/dev/mapper/rhel-root"
initrd="/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img $tuned_initrd"
title="Red Hat Enterprise Linux (4.18.0-240.15.1.el8_3.x86_64) 8.3 (Ootpa)"
id="21e418ac989a4b0c8afb156418393409-4.18.0-240.15.1.el8_3.x86_64"
```

我们可以看到传递给 GRUB 的选项:

*   `index`:显示索引号
*   `kernel`:包含要载入以运行操作系统核心的内核的文件
*   `root`:将分配给根`/`目录并挂载的分区或逻辑卷
*   `initrd`:包含 RAM 磁盘的文件，用于执行引导过程的初始部分
*   `title`:引导过程中显示给用户的描述性标题
*   `id`: Identifier of the boot entry

    提示

    您可能需要运行`grubby`命令来获取配置为默认的内核的信息。 您可以运行以下命令:`grubby --info=$(grubby --default-kernel)`。

通过删除传递给内核的`quiet`和`rhbg`参数，让引导进程更加冗长:

```
[root@rhel8 ~]# grubby --remove-args="rhgb quiet" \
--update-kernel=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
[root@rhel8 ~]# grubby \ 
--info=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
index=0
kernel="/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64"
args="ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap $tuned_params"
root="/dev/mapper/rhel-root"
initrd="/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img $tuned_initrd"
title="Red Hat Enterprise Linux (4.18.0-240.15.1.el8_3.x86_64) 8.3 (Ootpa)"
id="21e418ac989a4b0c8afb156418393409-4.18.0-240.15.1.el8_3.x86_64"
```

让我们通过使用`systemctl reboot`命令重新启动机器来测试它。 下面是一个输出示例:

![Figure 15.1 – Verbose boot ](Images/B16799_15_001.jpg)

图 15.1 -详细引导

在正常启动时，这可能不是很有用，因为它运行得太快了。 但是，如果存在问题，它可以帮助从控制台调试情况。 要在启动后查看这些消息，可以使用`dmesg`命令:

![Figure 15.2 – Output of the dmesg command ](Images/B16799_15_002.jpg)

图 15.2 - dmesg 命令的输出

我们可以使用`--args`选项向内核添加一个参数。 让我们再次添加`quiet`选项:

```
[root@rhel8 ~]# grubby --args="quiet" \
--update-kernel=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
[root@rhel8 ~]# grubby \
--info=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
index=0
kernel="/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64"
args="ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap $tuned_params quiet"
root="/dev/mapper/rhel-root"
initrd="/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img $tuned_initrd"
title="Red Hat Enterprise Linux (4.18.0-240.15.1.el8_3.x86_64) 8.3 (Ootpa)"
id="21e418ac989a4b0c8afb156418393409-4.18.0-240.15.1.el8_3.x86_64"
```

重要提示

`--info`和`--update-kernel`选项接受`ALL`选项来检查或对所有配置的内核执行操作。

如果任何管理任务要求我们更改内核参数，现在我们知道如何执行该任务。 让我们进入引导过程的下一个部分`initrd`。

**initrd**文件，或**初始 RAM 磁盘**，包含一个用于准备系统启动的最小系统。 我们在前面的配置中发现它为`/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img`。 可以使用`dracut`命令重新生成。 让我们看一个如何重建当前`initrd`文件的例子:

```
[root@rhel8 ~]# dracut --force --verbose
dracut: Executing: /usr/bin/dracut --force --verbose
dracut: dracut module 'busybox' will not be installed, because command 'busybox' could not be found!
[omitted]
dracut: *** Including module: shutdown ***
dracut: *** Including modules done ***
dracut: *** Installing kernel module dependencies ***
dracut: *** Installing kernel module dependencies done ***
dracut: *** Resolving executable dependencies ***
dracut: *** Resolving executable dependencies done***
dracut: *** Hardlinking files ***
dracut: *** Hardlinking files done ***
dracut: *** Generating early-microcode cpio image ***
dracut: *** Constructing GenuineIntel.bin ****
dracut: *** Constructing GenuineIntel.bin ****
dracut: *** Store current command line parameters ***
dracut: *** Stripping files ***
dracut: *** Stripping files done ***
dracut: *** Creating image file '/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img' ***
dracut: *** Creating initramfs image file '/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img' done ***
```

我们可以在前面的输出中看到`initrd`文件中包含哪些早期访问所需的内核模块和文件。 当我们的`initrd`文件损坏时，以及当从备份中恢复系统时(如果在不同的硬件中进行)，这个步骤是有用的，以包括适当的存储驱动程序。

提示

查看`dracut`的手册页，了解创建`initrd`文件的更多选项。 这里有一篇 Red Hat 知识库文章`initrd`，这是一个有趣的练习，可以了解更多内容:[https://access.redhat.com/solutions/24029。](https://access.redhat.com/solutions/24029%0D)

我们已经学习了引导过程的早期阶段的非常基础知识，以便能够开始故障排除引导问题，作为一个 RHCSA 所需。 这个高级主题可以在一整本书中涵盖，但作为系统管理员，很少会在日常任务中用到它。 这就是为什么我们只包含了必需的部分。 我们将在本章的最后一节中包含一个特定的用例，称为*干预引导进程以访问系统*并修复磁盘问题。 让我们继续下一个主题，即如何使用**systemd**在 RHEL 中管理服务。

# 使用 systemd 管理启动顺序

我们已经了解了系统的固件如何将磁盘指向运行操作系统加载程序，在 RHEL 中是 GRUB。

GRUB 将加载内核和 initrd，准备系统启动。 然后开始系统的第一个进程，也称为进程 1 或 PID 1(**PID**表示**进程标识符**)。 这个过程必须负责有效地加载系统中所有必需的服务。 在 RHEL8 中，PID 1 由**systemd**运行。

在[*第四章*](04.html#_idTextAnchor059)、*常规操作工具*中，我们描述了使用 systemd 进行服务和目标管理。 让我们在本章回顾一下它与引导序列的交互。

我们可以使用**systemd**进行的与引导顺序相关的前两件事是重新启动系统和关闭系统。 我们将使用`systemctl`工具:

```
[root@rhel8 ~]# systemctl reboot
```

我们将看到系统将重新启动。 我们可以使用`uptime`命令检查系统已经运行了多长时间:

```
[root@rhel8 ~]# uptime
11:11:39 up 0 min,  1 user,  load average: 0,62, 0,13, 0,04
```

现在是时候检查`poweroff`了。 在这样做之前，请记住，在运行这个命令之后，您将需要有一种方法重新启动机器。 一旦我们意识到我们要遵循的过程，让我们运行它:

```
[root@rhel8 ~]# systemctl poweroff
```

现在我要重新启动机器了。

有一个命令将停止系统，但没有发送关机信号，即`systemctl halt`。 这种情况很少使用; 然而，知道它的存在和它的功能是很好的。

重要提示

前面显示的命令可以缩写为`reboot`和`poweroff`。 如果您检查`/usr/sbin/poweroff`中的文件，您将看到它是指向`systemctl`的符号链接。

在[*第四章*](04.html#_idTextAnchor059)，*常规操作工具*中，我们也复习了如何用`systemctl`设置默认的**系统目标**。 然而，我们可以在引导期间通过将`systemd.unit`参数传递给内核来覆盖默认配置。 我们可以使用`grubby`:

```
[root@rhel8 ~]# systemctl get-default 
multi-user.target
[root@rhel8 ~]# grubby --args="systemd.unit=emergency.target" --update-kernel=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
[root@rhel8 ~]# systemctl reboot
```

现在系统正在重新启动。 `systemd.unit=emergency.target`参数已经通过**GRUB****内核,内核**和****systemd【显示】,,反过来,将忽略默认配置和负载所需的服务目标****紧急。****

现在系统启动在紧急模式，并等待根密码给你控制:

![Figure 15.3 – RHEL system booted in emergency mode ](Images/B16799_15_003.jpg)

图 15.3 - RHEL 系统在紧急模式下启动

在紧急模式下，没有配置网络，也没有运行其他进程。 您可以在没有其他用户访问系统的情况下对系统进行更改。 而且，只有`/`文件系统以只读模式挂载。

如果系统中的文件系统损坏了，这将是一种很好的检查方法，而不需要任何服务访问它。 让我们尝试使用检查文件系统的命令`fsck`:

```
[root@rhel8 ~]# fsck /boot
fsck from util-linux 2.32.1
If you wish to check the consistency of an XFS filesystem or
repair a damaged filesystem, see xfs_repair(8).
```

文件系统正常。 我们可以在它上运行`xfs_repair`，因为它是一个`xfs`文件系统(`fsck`检测所使用的文件系统)，如果它有需要修复的问题。

此时，我们可能会想，如果根文件系统已经以只读方式挂载在`/`上，我们如何对它进行更改呢? 进程首先将`/`文件系统重新挂载为可读写:

```
[root@rhel8 ~]# mount -o remount -o rw /
```

请记住，您可以通过运行`man mount`来访问该命令的手册页面。 现在我们的根文件系统以读写方式挂载在`/`中。 我们还需要加载`/boot`，所以让我们这样做:

```
[root@rhel8 ~]# mount /boot
```

挂载了`/boot`后，让我们执行一些管理任务，比如删除在 GRUB 中使用的参数:

```
[root@rhel8 ~]# grubby --remove-args="systemd.unit=emergency.target" --update-kernel=/boot/vmlinuz-4.18.0-240.15.1.el8_3.x86_64
[root@rhel8 ~]# reboot
```

我们将回到系统的正常启动。 在 Linux 中，这可能不是进入紧急模式的实际方法，但它显示了如何在引导时将参数传递给 systemd。

提示

有一个`rescue.target`可以加载更多的服务，使这个过程更容易一些。 它是通过等待`sysinit.target`完成来实现的，这是紧急目标不做的。 一个很好的练习是用`rescue.target`重复前面的序列。

在下一节中，我们将看到如何进行这种更改，以及类似的更改，以便在 GRUB 引导序列中更容易地进行一次性引导，并且不需要密码。

# 干预引导进程以获得对系统的访问权

有时，您需要对移交的系统进行干预，在该系统中，您没有`root`用户的密码。 这是一个练习，虽然听起来像是紧急情况，但比你想象的更频繁。

重要提示

引导序列中不能有任何加密的磁盘，否则您将需要加密卷的密码。

执行这个过程的方法是在 GRUB 菜单期间停止引导进程。 这意味着我们需要重新启动系统。 BIOS/UEFI 检查完成后，系统将加载 GRUB。 在等待内核选择时，我们可以通过按下向上或向下箭头键来停止计数，如下截图所示:

![Figure 15.4 – GRUB menu to select the kernel ](Images/B16799_15_004.jpg)

图 15.4 - GRUB 菜单选择内核

我们将移回第一个条目。 然后我们阅读屏幕底部，在那里我们找到了编辑引导行的说明:

![Figure 15.5 – GRUB menu to select the kernel ](Images/B16799_15_005.jpg)

图 15.5 - GRUB 菜单选择内核

如果我们按下*E*键，我们将能够编辑菜单中选择的启动行。 我们将看到以下五行:

![Figure 15.6 – GRUB menu to select the kernel ](Images/B16799_15_006.jpg)

图 15.6 - GRUB 菜单选择内核

包含`load_video`、`set``gfx_payload=keep`和`insmod gzio`的前三行是为 GRUB 设置选项。 接下来的两个选项是重要的。 让我们回顾一下:

*   `linux`:定义要加载的内核，并向其传递参数
*   `initrd`: Defines where to load the initrd and if there are any options for it

    提示

    请注意，`linux`行太长了，以至于它被换行了，正如我们可以从`\`符号中看到的，这意味着该行在下面继续。

我们现在到`linux`行末尾，添加`rd.break`选项，如下图所示:

![Figure 15.7 – linux kernel line edited with the rd.break option ](Images/B16799_15_007.jpg)

图 15.7 -用 rd.break 选项编辑的 linux 内核行

要启动编辑的行，只需要按*Ctrl*+*X*。 `rd.break`选项在加载 initrd 之前停止引导进程。 目前的情况如下:

*   一个单一的外壳被装载。
*   当前安装在`/`上的根文件系统是一个最小的根文件系统，它具有基本的管理命令。
*   目标根文件系统以只读方式挂载在`/sysroot`中(而不是`/`)。
*   没有安装其他文件系统。
*   SELinux 没有加载。

现在我们可以做的第一件事是使用`chroot`切换到真正的磁盘根文件系统:

```
switch_root:/# chroot /sysroot
sh-4.4# 
```

现在根文件系统已经正确安装，但是是只读的。 让我们用与前一节相同的方法来改变它:

```
sh-4.4# mount –o remount –o rw /
```

现在我们需要用`passwd`命令修改根用户密码:

```
sh-4.4# passwd
Changing password for user root
New password:
Retype new password:
passwd: all authentication tokens updated successfully
```

root 用户的密码已经更改，并且`/etc/shadow`文件已经更新。 但是，在没有启用 SELinux 的情况下对它进行了修改，因此在下一次启动时可能会出现问题。 为了避免这种情况，有一种机制可以在下一次引导期间修复 SELinux 标签。 该机制包括创建`/.autorelabel`隐藏的空文件，然后重新启动系统:

```
sh-4.4# touch /.autorelabel
```

创建了文件之后，就应该重新引导它以应用 SELinux 更改。 在这种状态下，机器可能需要强制断电，然后再上电。 在下一次启动时，我们将看到 SELinux 自动重标:

![Figure 15.8 – SELinux autorelabel during boot ](Images/B16799_15_008.jpg)

图 15.8 - SELinux 在引导过程中自动重标

现在我们可以使用根用户和它的新密码登录。

# 总结

我们已经在本章中回顾了启动顺序。 正如您所看到的，它并不长，但很复杂，而且非常重要，因为如果系统不能引导，就不能运行。 我们已经了解了启用 bios 系统和 UEFI 系统之间的主要差异，UEFI 系统启用了一些功能，但也有自己的需求。 我们还学习了 GRUB 及其在引导序列中的重要作用，如何使用`grubby`永久地修改条目，以及如何进行一次性修改。 现在我们知道要引导的主要文件，例如内核`vmlinuz`和初始 RAM 磁盘`initrd`。

本章还向我们展示了如何在紧急和救援模式下启动，以及如何干预系统重置 root 密码。

我们现在已经为用这些工具和程序处理我们系统中的任何困难情况做好了更充分的准备。 现在是时候深入学习下一章中的内核调优和性能概要了。**