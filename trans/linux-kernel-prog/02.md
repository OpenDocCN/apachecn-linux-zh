Building the 5.x Linux Kernel from Source - Part 1

从源代码构建 Linux 内核是开始内核开发之旅的一种有趣的方式！放心，这是一个漫长而艰苦的旅程，但这就是它的乐趣，对吗？内核构建主题本身足够大，值得分成两章，这一章和下一章。

本章和下一章的主要目的是详细描述如何从零开始、从源代码开始构建 Linux 内核。在本章中，您将初步了解如何将稳定的普通 Linux 内核源代码树下载到来宾 Linux **虚拟机** ( **VM** )(所谓普通内核，我们指的是 Linux 内核社区在其存储库[https://www.kernel.org](https://kernel.org)上发布的普通且常规的默认内核源代码)。接下来，我们将学习一点关于内核源代码的布局——实际上，获得内核代码库的 10，000 英尺视图。接下来是实际的内核构建方法。

在继续之前，有一条关键信息:任何 Linux 系统，无论是超级计算机还是微型嵌入式设备，都有三个必需的组件:引导加载程序、操作系统内核和根文件系统。在本章中，我们只关注从源代码构建 Linux 内核。我们不深入研究根文件系统的细节，并且(在下一章中)学习最低限度地配置(非常特定于 x86 的)GNU GRUB 引导加载程序。

在本章中，我们将涵盖以下主题:

*   内核构建的准备工作
*   从源代码构建内核的步骤
*   步骤 1–获取 Linux 内核源代码树

*   步骤 2–提取内核源树
*   步骤 3–配置 Linux 内核
*   定制内核菜单–添加我们自己的菜单项

# 技术要求

我假设您已经完成了[第 1 章](01.html)、*内核工作区设置*，并且已经适当地准备了一个运行 Ubuntu 18.04 LTS(或 CentOS 8，或这些发行版的更高稳定版本)的来宾 VM，并且安装了所有需要的包。如果没有，我强烈建议你先做这个。

为了充分利用这本书，我强烈建议您首先设置工作空间环境，包括为代码克隆这本书的 GitHub 存储库([https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming))，并以动手的方式进行工作*。*

# 内核构建的准备工作

在构建和使用 Linux 内核的过程中，从一开始就了解一些有助于您的事情是很重要的。首先，Linux 内核及其姊妹项目是完全分散的——这是一个虚拟的、在线的开源社区！我们最接近办公室的是:Linux 内核(以及几十个相关项目)的管理权掌握在 Linux 基金会([https://linuxfoundation.org/](https://linuxfoundation.org/))手中；此外，它还管理着 Linux 内核组织，这是一个向公众免费分发 Linux 内核的私人基金会([https://www.kernel.org/nonprofit.html](https://www.kernel.org/nonprofit.html))。

我们在本节中讨论的一些要点包括:

*   内核版本或版本号命名法
*   典型的内核开发工作流程
*   存储库中存在不同类型的内核源树

有了这些信息，您将能够更好地完成内核构建过程。好了，让我们来复习一下前面的每一点。

## **内核发布术语**

要查看内核版本号，只需在你的外壳上运行`uname -r`。如何精准解读`uname -r`的输出？在我们的 Ubuntu 发行版 18.04 LTS 来宾虚拟机上，我们运行`uname(1)`，通过`-r`选项开关仅显示当前内核版本或版本:

```
$ uname -r
5.0.0-36-generic 
```

Of course, by the time you read this, the Ubuntu 18.04 LTS kernel has certainly been upgraded to a later release; that's perfectly normal. The 5.0.0-36-generic kernel was the one I encountered with the Ubuntu 18.04.3 LTS at the time of writing this chapter.

现代 Linux 内核发行号命名如下:

```
major#.minor#[.patchlevel][-EXTRAVERSION]
```

这也经常被写成或描述为`w.x[.y][-z]`。

`patchlevel`和`EXTRAVERSION`组件周围的方括号表示它们是可选的。下表总结了版本号组件的含义:

| **释放#组件** | **表示** | **示例编号** |
| 专业`#`(或`w`) | 主要或主要编号；目前，我们在 5.x 内核系列上，因此主要数字是`5`。 | `2`、`3`、`4`和`5` |
| 次要`#`(或`x`) | 次要数字，分级在主要数字之下。 | `0`向前 |
| `[patchlevel]`(或`y`) | 当需要进行重大的错误/安全修复时，有时会在次要编号(也称为 ABI 或修订版)下应用于稳定内核。 | `0`向前 |
| `[-EXTRAVERSION]`(或`-z`) | 也叫`localversion`；通常由分发内核用来跟踪它们的内部变化。 | 各不相同；Ubuntu 使用`w.x.y-'n'-generic` |

Table 2.1 – Linux kernel release nomenclature

因此，我们现在可以解释我们的 Ubuntu 18.04 LTS 发行版的内核版本号`5.0.0-36-generic`:

*   **少校#(或 w)** : `5`
*   **小调#(或 x)** : `0`
*   **【patch level】(或 y)** : `0`
*   **【-外向】(或-z)** : `-36-generic`

请注意，分发内核可能会也可能不会完全遵循这些约定，这完全取决于它们。在[https://www.kernel.org/](https://www.kernel.org/)上发布的普通或香草果仁确实遵循这些惯例(至少在莱纳斯决定改变它们之前)。

(a) As part of an interesting exercise configuring the kernel, we will later change the `localversion` (aka `-EXTRAVERSION`) component of the kernel we build.
(b) Historically, in kernels before 2.6 (IOW, ancient stuff now), the *minor number* held a special meaning; if an even number, it indicated a stable kernel release, if odd, an unstable or beta release. This is no longer the case.

## 内核开发工作流——基础

在这里，我们简要概述了典型的内核开发工作流。任何像您这样对内核开发感兴趣的人都应该至少最低限度地了解这个过程。

A detailed description can be found within the kernel documentation here: [https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works).

一个常见的误解，尤其是在它的婴儿时期，是 Linux 内核是以一种非常特别的方式开发的。这完全不是真的！内核开发过程已经发展成为一个(大部分)运行良好的系统，有一个完整的文档化过程，并且期望内核贡献者应该知道什么才能很好地使用它。我请你参考前面的链接了解完整的细节。

为了让我们看一看典型的开发周期，让我们假设我们的系统上克隆了最新的主线 Linux Git 内核树。

The details regarding the use of the powerful `git(1)` **Source Code Management** (**SCM**) tool is beyond the scope of this book. Please see the *Further reading* section for useful links on learning how to use Git. Obviously, I highly recommend gaining at least basic familiarity with using `git(1)`.

如前所述，截止到撰写本文时，**5.4 内核**是最新的**长期稳定** ( **LTS** )版本，所以后续的资料中会用到。那么，它是怎么来的呢？显然，它是从**版本候选** ( **rc** )内核及其之前的稳定内核版本演变而来的，在这种情况下，它将是*v 5.4-RC ' n’*内核及其之前的稳定 *v5.3* 内核。我们使用如下的`git log`命令来获取内核 Git 树中按日期排序的标签的人类可读日志。在这里，我们只对导致 5.4 LTS 内核发布的工作感兴趣，因此我们特意截断了以下输出，只显示了这一部分:

The `git log` command (that we use in the following code block, and in fact any other `git` sub-commands) will only work on a `git` tree. We use the following one purely for demonstrating the evolution of the kernel. A bit later, we will show how you can clone a Git tree.

```
$ git log --date-order --graph --tags --simplify-by-decoration --pretty=format:'%ai %h %d'
* 2019-11-24 16:32:01 -0800 219d54332a09  (tag: v5.4)
* 2019-11-17 14:47:30 -0800 af42d3466bdc  (tag: v5.4-rc8)
* 2019-11-10 16:17:15 -0800 31f4f5b495a6  (tag: v5.4-rc7)
* 2019-11-03 14:07:26 -0800 a99d8080aaf3  (tag: v5.4-rc6)
* 2019-10-27 13:19:19 -0400 d6d5df1db6e9  (tag: v5.4-rc5)
* 2019-10-20 15:56:22 -0400 7d194c2100ad  (tag: v5.4-rc4)
* 2019-10-13 16:37:36 -0700 4f5cafb5cb84  (tag: v5.4-rc3)
* 2019-10-06 14:27:30 -0700 da0c9ea146cb  (tag: v5.4-rc2)
* 2019-09-30 10:35:40 -0700 54ecb8f7028c  (tag: v5.4-rc1)
* 2019-09-15 14:19:32 -0700 4d856f72c10e  (tag: v5.3)
* 2019-09-08 13:33:15 -0700 f74c2bb98776  (tag: v5.3-rc8)
* 2019-09-02 09:57:40 -0700 089cf7f6ecb2  (tag: v5.3-rc7)
* 2019-08-25 12:01:23 -0700 a55aa89aab90  (tag: v5.3-rc6)
[...]
```

啊哈！在前面的代码块中，您可以清楚地看到稳定的 5.4 内核于 2019 年 11 月 24 日发布，5.3 树于 2019 年 9 月 15 日发布(您也可以通过查找其他有用的内核资源来验证这一点，例如[https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions))。

对于最终导致 5.4 内核的开发系列来说，后一个日期(2019 年 9 月 15 日)标志着下一个稳定内核的**合并窗口**的开始，为期(大约)两周。在此期间，开发人员被允许向内核树提交新代码(实际上，实际工作早就开始了；这项工作的成果现已并入主线(此时)。

两周后(2019 年 9 月 30 日)，合并窗口关闭，`rc`内核工作开始，`5.4-rc1`当然是第一个`rc`版本。`-rc`(也称为 prepatch)树主要致力于合并补丁和修复(回归)bug，最终导致被主要维护者(Linus Torvalds 和 Andrew Morton)确定为“稳定”的内核树。预匹配的数量(`-rc`版本)各不相同。然而，这个“错误修复”窗口通常需要 6 到 10 周，之后新的稳定内核就会发布。在前面的代码块中，我们可以看到八个候选发布内核最终导致了 v5.4 树在 2019 年 11 月 24 日的稳定发布(总共耗时 70 天)。

通过[https://github.com/torvalds/linux/releases](https://github.com/torvalds/linux/releases)的发布页面可以更直观地看到这一点:

![](Images/2ff835f8-e969-42bd-91f1-cb514f2f954b.png)

Figure 2.1 – The releases leading up to the 5.4 LTS kernel (read it bottom-up)

前面的截图是部分截图，展示了各种*v 5.4-RC ' n‘*版本候选内核如何最终导致 LTS 5.4 树的发布(2019 年 11 月 25 日， *v5.4-rc8* 是最后一个`rc`版本)。工作从来没有真正停止过:到 2019 年 12 月初， *v5.5-rc1* 发布候选人出局。

一般来说，以 5.x 内核系列为例(其他最近的`major`内核系列也是如此)，内核开发工作流程如下:

1.  5.x 稳定发布。因此，5.x+1(主线)内核的合并窗口已经开始。
2.  合并窗口保持打开大约 2 周，新的补丁被合并到主线中。
3.  一旦(通常)2 周过去，合并窗口关闭。
4.  `rc`(又名主线，prepatch)内核启动。 *5.x+1-rc1，5.x+1-rc2，...，5.x+1-rcn* 发布。这个过程需要 6 到 8 周。
5.  稳定发布到了:新的 *5.x+1* 稳定内核发布。
6.  发布交给“稳定团队”:
    *   重大错误或安全修复导致发布 *5.x+1.y :*
        *5.x+1.1，5* *。x+1.2，...，5.x+1.n* 。
    *   一直保持到下一个稳定版本或达到**寿命终止** ( **EOL** )日期

...整个过程重复进行。

因此，当您现在看到 Linux 内核版本时，所涉及的名称和过程将变得有意义。现在让我们继续看看不同类型的内核源代码树。

## 内核源树的类型

有几种类型的 Linux 内核源代码树。关键的一个是**长期支持** ( **LTS** )内核。好的，那么什么是 LTS 发布内核呢？这仅仅是一个“特殊”的版本，从这个意义上来说，内核维护者将继续在它的基础上支持重要的错误和安全修复(嗯，安全问题通常只是错误)，直到给定的停产日期。

LTS 内核的“寿命”通常至少为 2 年，还可以再延长几年(有时会延长)。我们将在本书中使用的 **5.4 LTS 内核**是第 20 个<sup>LTS 内核</sup>并且**的寿命刚刚超过 6 年——从 2019 年 11 月到 2025 年 12 月**。

存储库中有几种类型的发布内核。然而，在这里，我们提到一个不完整的列表，从最少到最稳定(因此，他们的生命，从最短到最长的时间跨度):

*   **-下一个树**:这确实是出血边缘，这里收集了带有新补丁的子系统树进行测试和审查。这是一个上游内核贡献者将要做的工作。
*   **预匹配，也称为-rc 或主线**:这些是在发布之前生成的发布候选内核。
*   **稳定内核**:顾名思义，这就是业务端。这些内核通常由发行版和其他项目(至少从一开始)获得。它们也被称为香草核。
*   **分布和 LTS 核**:分布核(很明显)是分布提供的核。它们通常以基础香草/稳定的果仁开始。LTS 内核是专门维护更长时间的内核，使其对工业/生产项目和产品特别有用。

In this book, we will work throughout on the latest LTS kernel as of the time of writing, which is the 5.4 LTS kernel. As I mentioned in [Chapter 1](01.html), *Kernel Workspace Setup*, the 5.4 LTS kernel was initially slated to have an EOL of "at least December 2021." Recently (June 2020), it's now been pushed **to** **December 2025**, keeping this book's content current and valid for years to come!

*   **超级 LTS (SLTS)内核**:更长时间维护的 LTS 内核(由*民用基础设施平台*([https://www.cip-project.org/](https://www.cip-project.org/)，一个 Linux 基金会项目)。

挺直观的。尽管如此，我还是建议您访问 kernel.org 的 Releases 页面，以获取关于发布内核类型的详细信息:[https://www.kernel.org/releases.html](https://www.kernel.org/releases.html)。同样，要了解更多细节，请访问*开发过程如何工作*([https://www.kernel.org/doc/html/latest/process/2.Process.html #开发过程如何工作](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works))。

有趣的是，某些 LTS 内核是非常长期的版本，被恰当地命名为 **SLTS** 或**超级 LTS** 内核。例如，4.4 Linux 内核(第 16 版<sup>LTS 版)被认为是 SLTS 内核。作为为 SLTS 选择的第一个内核，民用基础设施平台将提供支持，至少到 2026 年，可能到 2036 年。</sup>

可以使用`curl(1)`以非交互式脚本方式查询存储库`www.kernel.org`(以下输出是截至 2021 年 1 月 5 日的 Linux 状态):

```
$ curl -L https://www.kernel.org/finger_banner The latest stable version of the Linux kernel is: 5.10.4
The latest mainline version of the Linux kernel is: 5.11-rc2
The latest stable 5.10 version of the Linux kernel is: 5.10.4
The latest stable 5.9 version of the Linux kernel is: 5.9.16 (EOL)
The latest longterm 5.4 version of the Linux kernel is: 5.4.86
The latest longterm 4.19 version of the Linux kernel is: 4.19.164
The latest longterm 4.14 version of the Linux kernel is: 4.14.213
The latest longterm 4.9 version of the Linux kernel is: 4.9.249
The latest longterm 4.4 version of the Linux kernel is: 4.4.249
The latest linux-next version of the Linux kernel is: next-20210105
$ 
```

当然，当你读到这篇文章的时候，很有可能(事实上是肯定的)内核已经进一步发展，并且会出现更高的版本。对于像这本书这样的书，我能做的最好的事情就是在写作的时候选择最新的 LTS 内核。

Of course, it's happened already! The 5.10 kernel was released on 13 December 2020 and, as of the time of writing (just before going to print), the work on the 5.11 kernel is in progress...

最后，下载给定内核的另一种安全方式是由内核维护者提供的，他们提供了一个脚本来安全地下载给定的 Linux 内核源代码树，并验证其 PGP 签名。这里有脚本:[https://git . kernel . org/pub/SCM/Linux/kernel/git/mricon/korg-helpers . git/tree/get-verified-tarball](https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball)。

好了，现在我们已经掌握了内核版本命名法和内核源代码树类型的知识，是时候开始我们构建内核的旅程了。

# 从源代码构建内核的步骤

作为方便快捷的参考，以下是从源代码构建 Linux 内核所需的关键步骤。因为每一个的解释都非常详细，所以你可以参考这个总结来看到更大的图景。步骤如下:

1.  通过以下任一选项获取 Linux 内核源代码树:

    *   以压缩文件的形式下载特定的内核源代码
    *   克隆(内核)Git 树
2.  将内核源树提取到主目录中的某个位置(如果通过克隆 Git 树获得内核，请跳过这一步)。
3.  配置:根据新内核需要选择内核支持选项，
    `make [x|g|menu]config`，首选方式为`make menuconfig`。
4.  用`make [-j'n'] all`构建内核的可加载模块和任何**设备树 blob**(**dtb**)。这将构建压缩内核映像(`arch/<arch>/boot/[b|z|u]image`)、未压缩内核映像(`vmlinux`)、`System.map`、内核模块对象和任何已配置的 DTB 文件。
5.  用`sudo make modules_install`安装刚刚构建的内核模块。
    此步骤默认在`/lib/modules/$(uname -r)/`下安装内核模块。
6.  设置 GRUB 引导加载程序和`initramfs`(之前称为`initrd`)映像(x86 特定):
    `sudo make install`:
    *   这将在`/boot`下创建并安装`initramfs`(或`initrd`)图像。
    *   它更新引导加载程序配置文件来引导新内核(第一个条目)。
7.  自定义 GRUB 引导加载程序菜单(可选)。

这一章是关于这个主题的两个章节中的第一个，基本上涵盖了*步骤 1 到 3* ，同时也加入了许多必要的背景材料。下一章将介绍剩余步骤， *4 至 7* 。那么，让我们从*第一步*开始。

# 步骤 1–获取 Linux 内核源代码树

在本节中，我们将看到获取 Linux 内核源代码树的两种主要方式:

*   通过从 Linux 内核公共存储库中下载并提取特定的内核源代码树([https://www.kernel.org](https://www.kernel.org))
*   通过克隆 Linus Torvalds 的源树(或其他树)–例如`linux-next` Git 树

但是如何决定使用哪种方法呢？对于大多数像您这样从事项目或产品工作的开发人员来说，已经做出了决定——该项目使用了非常特定的 Linux 内核版本。因此，您将下载那个特定的内核源代码树，如果需要的话，很可能将特定于项目的补丁应用于它，并使用它。

对于那些打算向主线内核贡献或“上游”代码的人来说，第二种方法——克隆 Git 树——是适合你的方法。(当然，还有更多；我们在*类型的内核源树*部分中描述了一些细节)*。*

在下一节中，我们将演示这两种方法。首先，我们描述了从内核存储库中下载特定内核源树(而不是 Git 树)的方法。为此，我们在撰写本文时选择了最新的 LTS 5.4 Linux 内核。在第二种方法中，我们克隆一个 Git 树。

## 下载特定的内核树

首先，内核源代码在哪里？简而言之，它位于公共内核库服务器上，在[https://www.kernel.org](https://www.kernel.org)可见。本网站首页显示最新稳定的 Linux 内核版本，以及最新的`longterm`和`linux-next`版本(以下截图为截至 2019 年 11 月 29 日的网站。它以众所周知的`yyyy-mm-dd` 格式显示日期):

![](Images/3b94402e-51bb-4daf-9a65-72f09ecdab8f.png)

Figure 2.2 – The kernel.org site (as of 29 November 2019) A quick reminder: we also provide a PDF file that has the full-color images of the screenshots/diagrams used in this book. You can download it here: [https://static.packt-cdn.com/downloads/9781789953435_ColorImages.pdf](_ColorImages.pdf).

有许多方法可以下载(压缩的)内核源文件。让我们看看其中的两个:

*   一种互动的，也许是最简单的方式，是访问前面的网站，然后简单地点击适当的`tarball`链接。浏览器会将图像文件(以`.tar.xz`格式)下载到您的系统中。
*   或者，您可以使用`wget(1)`实用程序从命令行(外壳或命令行界面)下载它(我们也可以使用强大的`curl(1)`实用程序)。例如，要下载稳定的 5.4.0 内核源代码压缩文件，我们可以执行以下操作:

```
wget --https-only -O ~/Downloads/linux-5.4.0.tar.xz https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.0.tar.xz
```

If the preceding `wget(1)` utility doesn't work, it's likely because the kernel (compressed) `tarball` link changed. For example, if it didn't work for `5.4.0.tar.xz`, try the same `wget` utility but change the version to `5.4.1.tar.xz`.

这将安全地下载 5.4.0 压缩内核源代码树到你的电脑的`~/Downloads`文件夹。当然，您可能不希望在存储库的主页上显示内核的版本。例如，如果对于我的特定项目，我需要最新的 4.19 稳定(LTS)内核，即第 19 个<sup>LTS 版本，会怎么样？简单:通过浏览器，只需点击[https://www.kernel.org/pub/](https://www.kernel.org/pub/)(或镜像[https://mirrors.edge.kernel.org/pub/](https://mirrors.edge.kernel.org/pub/))链接(紧接在前几行显示的“HTTP”链接右侧)并导航到服务器上的`linux/kernel/v4.x/`目录(您可能会被定向到镜像站点)。或者，只需将`wget(1)`指向网址(此处，截至撰写本文时，恰好是[https://mirrors . edge . kernel . org/pub/Linux/kernel/v 4 . x/Linux-4 . 19 . 164 . tar . xz](https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz))。</sup>

## 克隆 Git 树

对于像您这样正在开发并希望向上游贡献代码的开发人员来说，您*必须*开发最新版本的 Linux 内核代码库。内核社区中有最新版本的细微变化。如前所述，`linux-next`树以及其中的一些特定分支或标签就是为此目的而工作的树。

然而，在这本书里，我们并不打算深究建立一棵`linux-next`树的血淋淋的细节。这个过程已经被很好地记录下来，我们不希望仅仅重复说明(详细链接见*进一步阅读*部分)。具体应该如何克隆`linux-next`树的详细页面在这里:*使用 linux-next、*[https://www.kernel.org/doc/man-pages/linux-next.html](https://www.kernel.org/doc/man-pages/linux-next.html)，如这里所述， *linux-next 树*、[http://git . kernel . org/cgit/Linux/kernel/git/next/Linux-next . git](http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git)是针对下一个内核合并窗口的补丁保存区域。如果您正在进行最前沿的内核开发，您可能希望从该树而不是 Linus Torvalds 的主线树开始工作。

出于我们的目的，克隆*主线* Linux Git 存储库(Torvalds 的 Git 树)就足够了。这样做(在一行中键入):

```
git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

Note that cloning a complete Linux kernel tree is a time-, network-, and disk-consuming operation! Ensure you have sufficient disk space free (at least a few gigabytes worth).

Performing `git clone --depth n <...>`, where `n` is an integer value, is very useful to limit the depth of history (commits) and thus keep the download/disk usage low(er). As the `man` page on `git-clone(1)` mentions for the `--depth` option: "Create a shallow clone with a history truncated to a specified number of commits."

根据前面的提示，为什么不做下面的事情(同样，在一行中键入这个)？

```
git clone --depth=3 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

如果您打算处理这个主线 Git 树，请跳过*步骤*2–*提取内核源树*部分(因为`git clone`操作在任何情况下都将提取源树)，并继续后面的部分(*步骤 3–配置 Linux 内核)*。

# 步骤 2–提取内核源树

如前所述，本节是为那些已经从存储库中下载了特定 Linux 内核的人准备的，[https://www.kernel.org](https://www.kernel.org)*并打算构建它。在本书中，我们使用 5.4 LTS 内核版本。另一方面，如果您已经在主线 Linux Git 树上执行了`git clone`，如前一节所示，您可以安全地跳过这一节，转到内核配置的下一节。*

 *现在下载完成了，让我们继续。下一步是提取内核源代码树——记住，这是一个经过编译和压缩的(通常是`.tar.xz`)文件。

我们假设，正如本章前面详细介绍的，您已经下载了 Linux 内核版本 5.4 的代码库作为压缩文件(进入`~/Downloads`目录):

```
$ cd ~/Downloads ; ls -lh linux-5.4.tar.xz
-rw-rw-r-- 1 llkd llkd 105M Nov 26 08:04 linux-5.4.tar.xz
```

提取该文件的简单方法是使用无处不在的`tar(1)`实用程序:

```
tar xf ~/Downloads/linux-5.4.tar.xz
```

这将把内核源树提取到`~/Downloads`目录下名为`linux-5.4`的目录中。但是如果我们想把它解压到另一个文件夹，比如`~/kernels`呢？然后，这样做:

```
mkdir -p ~/kernels
tar xf ~/Downloads/linux-5.4.tar.xz --directory=${HOME}/kernels/
```

这将把内核源代码提取到`~/kernels/linux-5.4/`文件夹中。为了方便和良好的实践，让我们设置一个*环境变量*来指向我们的内核源代码树的根的位置:

```
export LLKD_KSRC=${HOME}/kernels/linux-5.4
```

Note that, going forward, we will assume that this variable holds the location of the kernel source tree.

虽然您可以随时使用图形用户界面文件管理器应用程序(如`Nautilus(1)`)来提取压缩文件，但我强烈建议您熟悉使用 Linux 命令行界面来执行这些操作。

Don't forget `tldr(1)` when you need to quickly lookup the most frequently used options to common commands! For example, for `tar(1)`, simply use `tldr tar` to look it up.

你注意到了吗？我们将内核源树提取到主目录下的任何目录中(甚至其他地方)，不像过去树总是提取在根可写位置下(通常，`/usr/src/`)。现在，说不就行了。

如果您现在想要做的只是继续内核构建方法，请跳过以下部分，继续前进。如果感兴趣(我们当然希望如此！)，下一节将简要但重要地介绍一下内核源代码树的结构和布局。

## **内核源码树的简单浏览**

内核源代码现在可以在您的系统上使用了！酷，让我们快速看一下:

![](Images/60080ecf-a890-4c5c-aaa1-83a69461b019.png)

Figure 2.3 – The root of the 5.4 Linux kernel source tree

太好了。有多大？内核源代码树的根中的快速`du -m .`揭示了这个特定的内核源代码树(回想一下，它是 5.4 版本)的大小稍微超过了 1000 MB——几乎是一个千兆字节！

FYI, the Linux kernel has grown to be big and is getting bigger in terms of **Source** **Lines Of Code**(**SLOCs**). Current estimates are well over 20 million SLOCs. Of course, do realize that not *all* of this code will get compiled when building a kernel.

光看源代码，我们怎么知道这段代码到底是哪个版本的 Linux 内核？这很简单，一个快速的方法是检查项目 Makefile 的前几行。顺便说一下，内核到处都在使用 Makefile 大多数目录都有一个。我们将这个位于内核源代码树根的 Makefile 称为*顶级 Makefile* :

```
$ head Makefile
# SPDX-License-Identifier: GPL-2.0
VERSION = 5
PATCHLEVEL = 4
SUBLEVEL = 0
EXTRAVERSION =
NAME = Kleptomaniac Octopus

# *DOCUMENTATION*
# To see a list of typical targets execute "make help"
# More info can be located in ./README
$
```

显然，这是 5.4.0 内核的来源。

让我们自己获得内核源代码树的 10，000 英尺的缩小视图。下表总结了 Linux 内核源代码树根目录中(更重要的)文件和目录的大致分类和用途:

| **文件或目录名** | **目的** |
| **顶级文件**T2 |  |
| `README` | 项目的`README`文件。它告诉我们内核文档保存在哪里——剧透，它在名为`Documentation`的目录中——以及如何开始使用它。文档真的很重要；这是真正的东西，由内核开发人员自己编写。 |
| `COPYING` | 发布内核源代码所依据的许可条款。绝大多数是在众所周知的 GNU GPL v2(编写为 GPL-2.0)许可下发布的[1]。 |
| `MAINTAINERS` | *常见问题:**XYZ 出问题了，联系谁获得支持？*这正是这个文件所提供的——所有内核子系统的列表，实际上一直到单个组件的级别(例如特定的驱动程序)、其状态、当前维护它的人、邮件列表、网站等等。非常有帮助！甚至还有一个助手脚本来寻找可以交谈的人或团队:`scripts/get_maintainer.pl`【2】。 |
| 文件 | 这是内核的顶级 Makefile`kbuild`内核构建系统以及内核模块使用这个 Makefile(至少最初)进行构建。 |
| **主要子系统目录** |  |
| `kernel/` | 核心内核子系统:这里的代码处理进程/线程生命周期、CPU 调度、锁定、cgroups、定时器、中断、信令、模块、跟踪等等。 |
| `mm/` | **内存管理** ( **mm** )代码的大部分都在这里。我们将在[第 6 章](06.html)、*内核内部基础–进程和线程*中介绍一点，并在[第 7 章](07.html)、*内存管理内部基础–基础*和[第 8 章](08.html)、*模块作者内核内存分配–第 1 部分*中介绍一些相关内容。 |
| `fs/` | 这里的代码实现了两个关键的文件系统特性:抽象层——内核**虚拟文件系统交换机** ( **VFS** )和单个文件系统驱动程序(例如，`ext[2&#124;4]`、`btrfs`、`nfs`、`ntfs`、`overlayfs`、`squashfs`、`jffs2`、`fat`、`f2fs`等等)。 |
| `block/` | 底层(到 VFS/文件系统)块输入/输出代码路径。它包括实现页面缓存、通用块输入输出层、输入输出调度器等的代码。 |
| `net/` | 完成(至**征求意见函**(**RFC**)—[https://whats . techtarget . com/definition/征求意见函-RFC](https://whatis.techtarget.com/definition/Request-for-Comments-RFC) )网络协议栈的实现。包括高质量的 TCP、UDP、IP 和更多网络协议的实现。 |
| `ipc/` | **进程间通信** ( **IPC** )子系统代码；涵盖了 IPC 机制，如(SysV 和 POSIX)消息队列、共享内存、信号量等。 |
| `sound/` | 音频子系统代码，也称为**高级 Linux 声音架构** ( **ALSA** )。 |
| `virt/` | *虚拟化*(虚拟机管理程序)代码；这里实现了流行且强大的**内核虚拟机** ( **KVM** )。 |
| **基础设施/杂项** |  |
| `arch/` | 特定于 arch 的代码就在这里(arch 这个词，我们指的是 CPU)。Linux 最初是 i386 的一个小爱好项目。它现在可能是移植最多的操作系统了(见下表第 3 步中的拱形端口)。 |
| `crypto/` | 该目录包含密码的内核级实现(加密/解密算法，又称转换)和内核 API，为需要密码服务的消费者提供服务。 |
| `include/` | 该目录包含独立于 arch 的内核头(在`arch/<cpu>/include/...`下也有一些特定于 arch 的头)。
 |
| `init/` | 独立于 arch 的内核初始化代码；也许我们最接近内核主函数(记住，内核不是应用程序)的地方就在这里:`init/main.c:start_kernel()`，其中的`start_kernel()`函数被认为是内核初始化期间的早期 C 入口点。 |
| `lib/` | 最接近于内核库。重要的是要理解内核并不像用户空间应用那样支持共享库。这里的代码被自动链接到内核映像文件中，因此在运行时可供内核使用(各种有用的组件存在于`/lib`中:【un】压缩、校验和、位图、数学、字符串例程、树算法等)。 |
| `scripts/` | 这里包含各种脚本，其中一些在内核构建期间使用，许多用于其他目的(如静态/动态分析等；主要是 Bash 和 Perl)。 |
| `security/` | 内置内核的 **Linux 安全模块** ( **LSM** )，**强制访问控制** ( **MAC** )框架，旨在对用户应用对内核空间施加比默认内核更严格的访问控制(默认模型称为**自主访问控制** ( **DAC** )。目前，Linux 支持多种 LSMs 众所周知的有 SELinux、AppArmor、Smack、大道寺知世、Integrity 和 Yama(注意默认情况下 LSM 是“关闭的”)。 |
| `tools/` | 这里包含了各种工具，大部分是与内核“紧密耦合”的用户空间应用程序(或脚本)( *perf* ，现代分析工具，就是一个很好的例子)。 |

Table 2.2 – Layout of the Linux kernel source tree

下表给出了一些重要的解释:

1.  **内核许可**:在不拘泥于法律细节的情况下，事情的务实本质在这里:由于内核是在 GNU GPU l-2.0 许可下发布的(**GNU GPU l**是 **GNU 通用公共许可**)，任何直接使用内核代码库的项目(哪怕是一丁点！)，自动归入本许可证(GPL-2.0 的“衍生作品”属性)。这些项目或产品必须在相同的许可条款下发布它们的内核。实际上，当地的情况要糟糕得多；许多在 Linux 内核上运行的商业产品确实有专有的用户和/或内核空间代码。他们通常通过重构内核(最常见的是设备驱动程序)以**可加载内核模块** ( **LKM** )格式来实现。可以在*双许可*模式下发布内核模块(LKM)(例如，作为双 BSD/GPL；LKM 是[第 4 章](04.html)、*编写您的第一个内核模块–LKMs 第 1 部分*、[第 5 章](05.html)、*编写您的第一个内核模块–LKMs 第 2 部分*的主题，我们涵盖了那里内核模块许可的一些信息)。有些人，更喜欢专有许可，设法在没有 GPL-2.0 条款许可的内核模块中发布他们的内核代码；从技术上来说，这或许是可能的，但(至少)被认为是反社会的(甚至可以越界到违法)。感兴趣的可以在本章的*进一步阅读*文档中找到更多关于许可的链接。
2.  `MAINTAINERS`:运行`get_maintainer.pl` Perl 脚本的例子(注意:它只在 Git 树上运行):

```
$ scripts/get_maintainer.pl -f drivers/android/ Greg Kroah-Hartman <gregkh@linuxfoundation.org> (supporter:ANDROID DRIVERS)
"Arve Hjønnevåg" <arve@android.com> (supporter:ANDROID DRIVERS)
Todd Kjos <tkjos@android.com> (supporter:ANDROID DRIVERS)
Martijn Coenen <maco@android.com> (supporter:ANDROID DRIVERS)
Joel Fernandes <joel@joelfernandes.org> (supporter:ANDROID DRIVERS)
Christian Brauner <christian@brauner.io> (supporter:ANDROID DRIVERS)
devel@driverdev.osuosl.org (open list:ANDROID DRIVERS)
linux-kernel@vger.kernel.org (open list)
$ 
```

3.  Linux `arch` (CPU)端口:

```
$ cd ${LLKD_KSRC} ; ls arch/
alpha/ arm64/ h8300/   Kconfig     mips/  openrisc/ riscv/ sparc/ x86/
arc/   c6x/   hexagon/ m68k/       nds32/ parisc/   s390/  um/    xtensa/
arm/   csky/  ia64/    microblaze/ nios2/ powerpc/  sh/    unicore32/
```

As a kernel or driver developer, browsing the kernel source tree is something you will have to get quite used to (and even enjoy!). Searching for a particular function or variable can be a daunting task when the code is in the ballpark of 20 million SLOCs! Do use efficient code browser tools. I suggest the `ctags(1)` and `cscope(1)` **Free and Open Source Software** (**FOSS**) tools. In fact, the kernel's top-level Makefile has targets for precisely these:

`make tags ; make cscope`

我们现在已经完成了*第二步*，内核源树的提取！另外，您还学习了内核源代码布局的基础知识。现在让我们转到流程的第 3 步*并学习如何在构建 Linux 内核之前*配置*。*

# 步骤 3–配置 Linux 内核

配置新内核也许是内核构建过程中最关键的一步**。Linux 是广受好评的操作系统的众多原因之一是它的多功能性。认为(企业级)服务器、数据中心、工作站和微型嵌入式 Linux 设备有单独的 Linux 内核代码库是一种常见的误解–不，*它们都使用完全相同的统一 Linux 内核源代码！*因此，为特定用例(服务器、桌面、嵌入式或混合/定制)仔细配置*和*内核是一个强大的特性和需求。这正是我们正在钻研的。**

**Do carry out this kernel configuration step regardless. Even if you feel you do not require any changes to the existing (or default) config, it's very important to run this step at least once as part of the build process. Otherwise, certain headers that are auto-generated here will be missing and cause issues. At the very least, `make oldconfig` should be carried out. This will set up the kernel config to that of the existing system with config options being requested from the user only for any new options. First though, let's cover some required background on the **kernel build** (**kbuild**) system.

## 理解 kbuild 构建系统

Linux 内核用来配置和构建内核的基础设施被称为 **kbuild** 系统。kbuild 系统没有深入研究血淋淋的细节，而是通过四个关键组件将复杂的内核配置和构建过程联系在一起:

*   `CONFIG_FOO`符号
*   菜单规范文件，称为`Kconfig`
*   生成文件
*   整个内核配置文件本身

这些组件的用途总结如下:

| **Kbuild 组件** | **简要目的** |
| 配置符号:`CONFIG_FOO` | 每个可配置的内核`FOO`都由一个`CONFIG_FOO`宏表示。根据用户的选择，宏将解析为`y`、`m`或`n`之一:- `y=yes`: Implying to build the feature into the kernel image itself
- `m=module`:暗示将其构建为一个单独的对象，一个内核模块- `n=no`:暗示不构建功能Note that `CONFIG_FOO` is an alphanumeric string (as we will soon see, you can look up the precise config option name by using the `make menuconfig` option, navigating to a config option, and selecting the `< Help >` button). |
| `Kconfig`文件 | 这是定义`CONFIG_FOO`符号的地方。kbuild 语法指定其类型(布尔型、三态、[字母]数字型等)和依赖关系树。此外，对于基于菜单的配置用户界面(通过`make [menu&#124;g&#124;x]config`之一调用)，它指定了菜单项本身。当然，我们稍后会利用这个特性。 |
| 生成文件 | kbuild 系统使用递归的 Makefile 方法。内核源代码树根文件夹下的 Makefile 被称为*顶层* Makefile，每个子文件夹中都有一个 Makefile 来构建源代码。5.4 普通内核源代码总共有 2500 多个 Makefiles！ |
| `.config`文件 | 最终，它的本质——实际的内核配置——被生成并存储在名为`.config`的 ASCII 文本文件中的内核源树根文件夹中。保护好这个文件，它是你产品的关键部分。 |

Table 2.3 – Major components of the Kbuild build system

关键是给自己弄一个工作`.config`文件。我们如何做到这一点？我们反复这样做。我们从“默认”配置开始——这是下一节的主题——并根据需要小心地进行自定义配置。

## 达到默认配置

那么，如何决定初始内核配置呢？存在几种技术；一些常见的如下:

*   不要指定任何内容；kbuild 系统将引入默认的内核配置。
*   使用现有发行版的内核配置。
*   基于内存中当前加载的内核模块构建自定义配置。

第一种方法的好处是简单。内核将处理细节，给你一个默认的配置。缺点是默认配置确实非常大(这里，我们指的是为基于 x86 的桌面或服务器类型系统构建 Linux 打开了大量选项，以防万一，这可能会使构建时间非常长，内核映像大小非常大。当然，您需要手动将内核配置为所需的设置。

这就引出了一个问题，*默认内核配置存储在哪里*？kbuild 系统使用优先级列表回退方案来检索默认配置。优先级列表及其顺序(首先是最高优先级)在`init/Kconfig:DEFCONFIG_LIST`内指定:

```
$ cat init/Kconfig
config DEFCONFIG_LIST
    string
    depends on !UML 
    option defconfig_list
    default "/lib/modules/$(shell,uname -r)/.config"
    default "/etc/kernel-config"
    default "/boot/config-$(shell,uname -r)"
    default ARCH_DEFCONFIG
    default "arch/$(ARCH)/defconfig"
config CC_IS_GCC
[...]
```

仅供参考，`Kconfig`上的内核文档(可在此找到:[https://www . kernel . org/doc/Documentation/kbuild/kconfig-language . txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt))记录了`defconfig_list`是什么:

```
"defconfig_list"
    This declares a list of default entries which can be used when
    looking for the default configuration (which is used when the main
    .config doesn't exists yet.)
```

从列表中，您可以看到 kbuild 系统首先检查`/lib/modules/$(uname -r)`文件夹中是否存在`.config`文件。如果找到，那里的值将被用作默认值。如果没有找到，它接下来检查一个`/etc/kernel-config`文件的存在。如果找到，那里的值将被用作默认值，如果没有找到，它将移动到前面优先级列表中的下一个选项，以此类推。但是，请注意，内核源代码树的根中存在一个`.config`文件会覆盖所有这些！

## 获得内核配置的良好起点

这给我们带来了一个**真正重要的一点**:作为一个学习练习来玩内核配置是可以的(就像我们在这里所做的那样)，但是对于一个生产系统来说，使用一个经过验证的——已知的、经过测试的和有效的——内核配置是非常关键的。

在这里，为了帮助您理解为内核配置选择有效起点的细微差别，我们将看到三种获得内核配置起点的方法，我们希望这三种方法是典型的:

*   首先，典型的小型嵌入式 Linux 系统应该遵循的方法
*   接下来，一种模拟发行版配置的方法
*   最后，一种基于现有(或另一个)系统内核模块的内核配置的方法(T0 方法)

让我们更详细地研究一下这些方法。

### 典型嵌入式 Linux 系统的内核配置

使用这种方法的典型目标系统是小型嵌入式 Linux 系统。这里的目标是为我们的嵌入式 Linux 项目从一个经过验证的——一个已知的、经过测试的、有效的——内核配置开始。那么，我们到底如何才能实现这一点呢？

有趣的是，内核代码库本身为各种硬件平台提供了已知的、经过测试的和有效的内核配置文件。我们只需选择与我们的嵌入式目标板匹配(或最接近匹配)的那块。这些内核配置文件存在于`arch/<arch>/configs/`目录的内核源代码树中。配置文件的格式为`<platform-name>_defconfig`。可以快速浏览一下；请参见下面的截图，其中显示了正在 5.4 版 Linux 内核代码库上执行的命令`ls arch/arm/configs`:

![](Images/d9677c74-d872-470a-b7f9-b29f445d5dd3.png)

Figure 2.4 – The contents of arch/arm/configs on the 5.4 Linux kernel

因此，例如，如果您发现自己正在为一个硬件平台配置 Linux 内核，比如说，该平台上有一个三星 Exynos **片上系统** ( **SoC** )，请不要以 x86-64 内核配置文件作为默认文件(或者只是尝试使用它)。没用的。即使您管理它，内核也不会干净地构建/工作。选择合适的内核配置文件:对于我们这里的例子来说，`arch/arm/configs/exynos_defconfig`文件将是一个很好的起点。您可以将该文件复制到内核源代码树根目录下的`.config`中，然后根据您特定的项目需求对其进行微调。

又如，树莓 Pi([https://www.raspberrypi.org/](https://www.raspberrypi.org/))是一个受欢迎的业余爱好者平台。内核配置文件——在其内核源代码树中——用作(基础)如下:`arch/arm/configs/bcm2835_defconfig`。文件名反映了树莓皮板使用基于博通 2835 的系统芯片的事实。你可以在这里找到关于树莓皮内核编译的细节。不过，请稍等，我们将在[第 3 章](03.html)、*从源代码构建 5.x Linux 内核–第 2 部分*、在*为树莓皮构建内核*一节中介绍其中的一些内容。

An easy way to see exactly which configuration file is good for which platform is to simply perform `make help` on the target platform itself. The latter part of the output displays the config files under the *Architecture specific targets* heading (note though that this is meant for foreign CPUs and doesn't work for the x86[-64]).

产品内核配置的仔细调整和设置是在*平台*或**板支持包** ( **BSP** )团队中工作的工程师通常执行的工作的重要部分。

### 使用分发配置作为起点的内核配置

使用这种方法的典型目标系统是桌面或服务器 Linux 系统。

接下来，第二种方法也很快:

```
cp /boot/config-5.0.0-36-generic ${LLKD_KSRC}/.config
```

这里，我们简单地将现有的 Linux 发行版(这里，它是我们的 Ubuntu 18.04.3 LTS 来宾 VM)配置文件复制到内核源代码树的根中的`.config`文件中，当然，从而使发行版配置成为起点，然后可以进一步编辑它(一个更通用的命令:`cp /boot/config-$(uname -r) ${LLKD_KSRC}/.config`)。

### 通过 localmodconfig 方法调整内核配置

使用这种方法的典型目标系统是桌面或服务器 Linux 系统。

当目标是从基于您现有系统的内核配置开始时，我们认为第三种方法是一种很好的方法，因此(通常)与桌面或服务器 Linux 系统上的典型默认配置相比相对紧凑。在这里，我们通过简单地将`lsmod(8)`的输出重定向到一个临时文件，然后将该文件提供给构建，从而为 kbuild 系统提供系统上当前运行的内核模块的快照。这可以通过以下方式实现:

```
lsmod > /tmp/lsmod.now
cd ${LLKD_KSRC}
make LSMOD=/tmp/lsmod.now localmodconfig
```

`lsmod(8)`实用程序只是列出了当前驻留在系统(内核)内存中的所有内核模块。我们将在[第 4 章](04.html)、*编写您的第一个内核模块–LKMs 第 1 部分*中看到更多关于这方面的内容。我们将其输出保存在一个临时文件中，在`LSMOD`环境变量中传递给 Makefile 的`localmodconfig`目标。这个目标的工作是以这样一种方式配置内核，即只包括基本功能加上这些内核模块提供的功能，而忽略其余的，实际上给我们一个当前内核(或`lsmod`输出所代表的任何内核)的合理复制。在接下来的*开始使用 localmodconfig 方法*一节中，我们正是使用这种技术来配置我们的 5.4 内核。

好了，这是设置内核配置起点的三种方法。事实上，我们只是触及了表面。更多以给定方式显式生成内核配置的技术被编码到 kbuild 系统本身中！怎么做？通过配置目标至`make`。在`Configuration targets`标题下看到它们:

```
$ cd ${LKDC_KSRC}         *# root of the kernel source tree*
$ make help
Cleaning targets:
 clean             - Remove most generated files but keep the config and
 enough build support to build external modules
 mrproper          - Remove all generated files + config + various backup     
                     files
 distclean         - mrproper + remove editor backup and patch files

Configuration targets:
 config           - Update current config utilising a line-oriented  
                    program
 nconfig          - Update current config utilising a ncurses menu based 
                    program
 menuconfig       - Update current config utilising a menu based program
 xconfig          - Update current config utilising a Qt based front-end
 gconfig          - Update current config utilising a GTK+ based front-end
 oldconfig        - Update current config utilising a provided .config as 
                    base
 localmodconfig   - Update current config disabling modules not loaded
 localyesconfig   - Update current config converting local mods to core
 defconfig        - New config with default from ARCH supplied defconfig
 savedefconfig    - Save current config as ./defconfig (minimal config)
 allnoconfig      - New config where all options are answered with no
 allyesconfig     - New config where all options are accepted with yes
 allmodconfig     - New config selecting modules when possible
 alldefconfig     - New config with all symbols set to default
 randconfig       - New config with random answer to all options
 listnewconfig    - List new options
 olddefconfig     - Same as oldconfig but sets new symbols to their
                    default value without prompting
 kvmconfig        - Enable additional options for kvm guest kernel support
 xenconfig        - Enable additional options for xen dom0 and guest   
                    kernel support
 tinyconfig       - Configure the tiniest possible kernel
 testconfig       - Run Kconfig unit tests (requires python3 and pytest)

Other generic targets:
  all             - Build all targets marked with [*]
[...]
$
```

快速但非常有用的一点:为了确保清白，首先使用`mrproper`目标。我们将显示接下来执行的所有步骤的摘要，所以现在不要担心。

## 开始使用 localmodconfig 方法

现在，让我们使用之前讨论过的第三种方法，即`localmodconfig`技术，快速开始为我们的新内核创建基础内核配置。如上所述，当目标是在基于 x86 的系统上获得内核配置的起点时，这种现有的仅内核模块的方法是一个很好的方法，因为它可以保持相对较小，从而使构建更快。

Don't forget: the kernel configuration being performed right now is appropriate for your typical x86-based desktop/server systems. For embedded targets, the approach is different (as seen in the *Kernel config for typical embedded Linux systems* section). We further cover this practically in [Chapter 3](03.html), *Building the 5.x Linux Kernel from Source - Part 2*, under the *Kernel build for the Raspberry Pi* section*.*

如前所述，首先获取当前加载的内核模块的快照，然后通过指定`localmodconfig`目标让 kbuild 系统对其进行操作，如下所示:

```
lsmod > /tmp/lsmod.now
cd ${LLKD_KSRC} ; make LSMOD=/tmp/lsmod.now localmodconfig
```

现在，需要理解的是:当我们执行实际的`make [...] localmodconfig`命令时，完全有可能，甚至有可能，您当前构建的内核(版本 5.4)和您当前实际运行构建的内核(这里是`$(uname -r) = 5.0.0-36-generic`)之间的配置选项会有所不同。在这些情况下，kbuild 系统将在控制台(终端)窗口上显示每个新的配置选项以及您可以设置的可用值。然后，它将提示用户选择在构建的内核中遇到的任何新配置选项的值。您将看到这是一系列问题，并提示您在命令行上回答这些问题。

The prompt will be suffixed with `(NEW)`, in effect telling you that this is a *new* kernel config option and it wants your answer as to how to configure it.

在这里，我们至少会采取简单的方法:只需按下`[Enter]`键接受默认选择，如下所示:

```
$ uname -r5.0.0-36-generic $ make LSMOD=/tmp/lsmod.now localmodconfig 
using config: '/boot/config-5.0.0-36-generic'
vboxsf config not found!!
module vboxguest did not have configs CONFIG_VBOXGUEST
*
* Restart config...
*
*
* General setup
*
Compile also drivers which will not load (COMPILE_TEST) [N/y/?] n
Local version - append to kernel release (LOCALVERSION) [] 
Automatically append version information to the version string (LOCALVERSION_AUTO) [N/y/?] n
Build ID Salt (BUILD_SALT) [] (NEW) [Enter] Kernel compression mode
> 1\. Gzip (KERNEL_GZIP)
  2\. Bzip2 (KERNEL_BZIP2)
  3\. LZMA (KERNEL_LZMA)
  4\. XZ (KERNEL_XZ)
  5\. LZO (KERNEL_LZO)
  6\. LZ4 (KERNEL_LZ4)
choice[1-6?]: 1
Default hostname (DEFAULT_HOSTNAME) [(none)] (none)
Support for paging of anonymous memory (swap) (SWAP) [Y/n/?] y
System V IPC (SYSVIPC) [Y/n/?] y
[...]
Enable userfaultfd() system call (USERFAULTFD) [Y/n/?] y
Enable rseq() system call (RSEQ) [Y/n/?] (NEW)
[...]
  Test static keys (TEST_STATIC_KEYS) [N/m/?] n
  kmod stress tester (TEST_KMOD) [N/m/?] n
  Test memcat_p() helper function (TEST_MEMCAT_P) [N/m/y/?] (NEW)
#
# configuration written to .config
#
$ ls -la .config
-rw-r--r-- 1 llkd llkd  140764 Mar  7 17:31 .config
$ 
```

多次按下`[Enter]`键后，询问幸运地结束，kbuild 系统将新生成的配置写入当前工作目录中的`.config`文件(我们截断了之前的输出，因为它太大了，没有必要完全复制)。

前面两个步骤负责通过`localmodconfig`方法生成`.config`文件。在我们结束本节之前，这里有一些需要注意的要点:

*   为了确保完全清白，在内核源代码树的根中运行`make mrproper`或`make distclean`(当您想要从头开始时有用；放心，总有一天会发生的！请注意，这样做也会删除内核配置文件。
*   在本章中，所有的内核配置步骤和与之相关的截图都是在 Ubuntu 18.04.3 LTS x86-64 客户虚拟机上执行的，我们使用该虚拟机作为构建全新 5.4 Linux 内核的主机。菜单项的确切名称、存在和内容，以及菜单系统(用户界面)的外观和感觉，都可以并且确实根据(a)架构(中央处理器)和(b)内核版本而变化。
*   如前所述，在一个生产系统或项目中，平台或**板支持包** ( **BSP** )团队，或者实际上是嵌入式 Linux BSP 供应商公司(如果您已经与之合作过的话)，将提供一个良好的已知的、工作的和经过测试的内核配置文件。将它复制到内核源代码树根的`.config`文件中，以此作为起点。

随着您获得构建内核的经验，您会意识到第一次正确设置内核配置的努力(非常关键！)更高；当然，第一次构建所需的时间很长。然而，一旦做得正确，这个过程通常会变得简单得多——一个反复运行的配方。

现在，让我们学习如何使用一个有用且直观的用户界面来调整我们的内核配置。

## 通过 make menuconfig 用户界面调整我们的内核配置

好的，太好了，我们现在有了一个通过`localmodconfig` Makefile 目标为我们生成的初始内核配置文件(`.config`)，如前一节详细所示，这是一个很好的起点。现在，我们想进一步检查和微调内核的配置。做到这一点的一种方法——事实上，推荐的方法——是通过`menuconfig` Makefile 目标。这个目标让 kbuild 系统生成一个相当复杂的(基于 C 的)程序可执行文件(`scripts/kconfig/mconf`，它向最终用户呈现一个整洁的基于菜单的用户界面。在下面的代码块中，当我们第一次调用该命令时，kbuild 系统构建`mconf`可执行文件并调用它:

```
$ make menuconfig
 UPD scripts/kconfig/.mconf-cfg
 HOSTCC scripts/kconfig/mconf.o
 HOSTCC scripts/kconfig/lxdialog/checklist.o
 HOSTCC scripts/kconfig/lxdialog/inputbox.o
 HOSTCC scripts/kconfig/lxdialog/menubox.o
 HOSTCC scripts/kconfig/lxdialog/textbox.o
 HOSTCC scripts/kconfig/lxdialog/util.o
 HOSTCC scripts/kconfig/lxdialog/yesno.o
 HOSTLD scripts/kconfig/mconf
scripts/kconfig/mconf Kconfig
...
```

当然，一张图片无疑抵得上千言万语，所以`menuconfig` UI 是这样的:

![](Images/26cf087b-f09d-4447-86fd-d9d98afeb48b.png)

Figure 2.5 – The main menu of kernel configuration via make menuconfig (on x86-64)

作为经验丰富的开发人员，或者任何充分使用过计算机的人，我们都知道，事情可能并且确实会出错。以下面的场景为例——第一次在新安装的 Ubuntu 系统上运行`make menuconfig`:

```
$ make menuconfig
 UPD     scripts/kconfig/.mconf-cfg
 HOSTCC  scripts/kconfig/mconf.o
 YACC    scripts/kconfig/zconf.tab.c
/bin/sh: 1: bison: not found
scripts/Makefile.lib:196: recipe for target 'scripts/kconfig/zconf.tab.c' failed
make[1]: *** [scripts/kconfig/zconf.tab.c] Error 127
Makefile:539: recipe for target 'menuconfig' failed
make: *** [menuconfig] Error 2
$
```

坚持住，不要惊慌。仔细阅读故障信息。`YACC [...]`后的一行提供了线索:`/bin/sh: 1: bison: not found`。啊，那么用以下命令安装`bison(1)`:

`sudo apt install bison`

现在，一切应该都好了。嗯，差不多；再次，在一位刚出炉的 Ubuntu 客人身上，`make menuconfig`接着抱怨`flex(1)`没有安装。所以，我们安装它(你猜对了:通过`sudo apt install flex`)。另外，特别是在 Ubuntu 上，你需要安装`libncurses5-dev`包(在 Fedora 上，做`sudo dnf install ncurses-devel`)。

If you have read and followed [Chapter 1](01.html), *Kernel* *Workspace Setup*, you would have all these prerequisite packages already installed. If not, please refer to it now and install all required packages. Remember, *as ye sow…*

接下来，kbuild 开源框架(顺便说一下，在一大堆项目中重用)通过其用户界面向用户提供了一些线索。菜单项前的符号含义如下:

*   `[.]`:内核特性，布尔选项(开或关):
    *   `[*]`:开启，功能编译并内置(编译于)到内核镜像(y)
    *   `[ ]`:关，根本不建(n)
*   `<.>`:可能处于三种状态(三态)之一的特征:
    *   `<*>`:开启，功能编译内置(编译于)内核镜像(y)
    *   `<M>`:模块，作为内核模块编译和构建的特性(一个 LKM) (m)
    *   `< >`:关，根本不建(n)
*   `{.}`:该配置选项存在依赖关系；因此，需要将其构建(编译)为模块(m)或内置(编译)到内核映像(y)中。
*   `-*-`:依赖项需要在(y)中编译该项。
*   `(...)`:提示:需要输入字母数字(在此选项上按下`[Enter]`键，出现提示)。

*   `<Menu entry> --->`:随后出现一个子菜单(按下该项上的`[Enter]`导航到子菜单)。

同样，经验方法是关键。让我们实际试验一下`make menuconfig`用户界面，看看它是如何工作的。这是下一节的主题。

### 制作菜单配置界面的示例用法

为了通过方便的`menuconfig`目标获得使用 kbuild 菜单系统的感觉，让我们一步一步地导航到名为`Kernel .config support`的三态菜单项。默认情况下是关闭的，所以让我们打开它；也就是说，让我们把它`y`内置到内核映像中。我们可以在主屏幕上的`General Setup`主菜单项下找到它。

打开此功能到底能实现什么？当开启到`y`(当然，如果设为`M`，那么一个内核模块将变为可用，一旦加载完毕)，那么当前运行的内核的配置设置可以通过两种方式随时查看:

*   通过运行`scripts/extract-ikconfig`脚本
*   通过直接读取`/proc/config.gz`伪文件的内容(当然是`gzip(1)`-压缩；首先解压缩，然后读取)

作为学习练习，我们现在将学习如何使用下表中显示的值为内核配置选项配置我们的 5.4 Linux 内核(针对 x86-64 架构)。目前，不要强调这些选项的意义；这只是为了练习一下内核配置系统:

| **功能** | **效果和位置在制作菜单界面** | 
**选择<帮助>按钮**
**查看精确 CONFIG_ < FOO >选项** | **值:原**
**- >新值** |
| 本地版本 | 设置内核版本/版本的`-EXTRAVERSION`组件(用`uname -r`查看)；`General Setup / Local version - append to kernel release` | `CONFIG_LOCALVERSION` | (无)->
`-llkd01` |
| 内核配置文件支持 | 允许您查看当前内核配置的详细信息；
`General Setup / Kernel .config support` | `CONFIG_IKCONFIG` | `n` - > `y` |
| 与前面通过 procfs 访问的 plus 相同 | 允许您通过 **proc 文件系统** ( **p** **rocfs** )查看当前内核配置的详细信息；`General Setup / Enable access to .config through /proc/config.gz` | `CONFIG_IKCONFIG_PROC` | `n` - > `y` |
| 内核剖析 | 内核分析支持；`General Setup / Profiling support` | `CONFIG_PROFILING` | `y` - > `n` |
| 业余无线电 | 支持 HAM 电台；`Networking support / Amateur Radio support` | `CONFIG_HAMRADIO` | `y` - > `n` |
| VirtualBox 支持 | 对 VirtualBox 的虚拟化支持；`Device Drivers / Virtualization drivers / Virtual Box Guest integration support` | `CONFIG_VBOXGUEST` | `n` - > `m` |
| **用户空间输入输出驱动程序** ( **输入输出**) | UIO 支持；`Device Drivers / Userspace I/O Drivers` | `CONFIG_UIO` | `n` - > `m` |
| 前面的加上带有通用 IRQ 处理的 UIO 平台驱动程序 | 具有通用 IRQ 处理的 UIO 平台驱动程序；`Device Drivers / Userspace I/O Drivers / Userspace I/O platform driver with generic IRQ handling` | `CONFIG_UIO_PDRV_GENIRQ` | `n` - > `m` |
| 支持文件系统 | `File systems / DOS/FAT/NT Filesystems / MSDOS fs support` | `CONFIG_MSDOS_FS` | `n` - > `m` |
| 安全性:LSMs | 关闭*内核 LSMs`Security options / Enable different security models` *(注:对于生产系统，保持此状态通常更安全！)** | `CONFIG_SECURITY` | `y` - > `n` |
| 内核调试:堆栈利用信息 | `Kernel hacking / Memory Debugging / Stack utilization instrumentation` | `CONFIG_DEBUG_STACK_USAGE` | `n` - > `y` |

Table 2.4 – Items to configure

你具体如何解读这张表？我们以第一行为例；我们一栏一栏地看:

*   **第一列**指定了我们想要修改的内核*特性*(编辑/启用/禁用)。这里，它是内核版本字符串的最后一部分(如`uname -r`的输出所示)。它被称为版本的`-EXTRAVERSION`组件(详见*内核版本命名*部分)。

*   **第二列**指定两件事:
    *   第一，我们想要做的。在这里，我们要设置内核释放字符串的`-EXTRAVERSION`组件。
    *   第二，显示了这个内核配置选项在`menuconfig`界面中的位置。在这里，它在`General Setup`子菜单中，在它下面是名为`Local version - append to kernel release` *的菜单项。*我们写为`General Setup / Local version - append to kernel release`。
*   **第三列**指定内核配置选项的名称为`CONFIG_<FOO>`。如果需要，您可以在菜单系统中进行搜索。在这个例子中，它被称为`CONFIG_LOCALVERSION`。
*   **第四列**显示了该内核配置选项的原始*值*以及我们希望您将其更改为的值(“新”值)。格式为*原值- >新值。*在我们的示例中，它是`(none) -> -llkd01`，这意味着`-EXTRAVERSION`字符串组件的原始值为空，我们希望您修改它，将其更改为值`-llkd01`。

另一方面，对于我们展示的几个项目，它可能不会立即显现出来——比如`n -> m`；这是什么意思？`n -> m`意味着您应该将原始值从`n`(未选择)更改为`m`(选择作为内核模块构建)。类似地，`y -> n`字符串表示将配置选项从开更改为关。

You can *search* for kernel config options within the `menuconfig` system UI by pressing the / key (just as with vi; we show more on this in the section that follows).

然后(实际上，在接下来的章节中)，我们将使用这些新的配置选项构建内核(和模块)，从其中启动，并验证前面的内核配置选项是否按照我们的要求进行了设置。

但是现在，你应该做你该做的:启动菜单用户界面(用通常的`make menuconfig`)，然后导航菜单系统，找到前面描述的相关内核配置选项，并根据需要编辑它，到前面表格中显示的第四列。

Note that, depending on the Linux distribution you're currently running and its kernel modules (we used `lsmod(8)` to generate an initial config, remember?), the actual values and defaults you see when configuring the kernel might differ from that of the *Ubuntu 18.04.3 LTS* distribution (running the 5.0.0-36-generic kernel), as we have used and shown previously.

在这里，为了保持讨论的理智和紧凑，我们将只显示设置上表中所示的第二个和第三个内核配置选项的完整的详细步骤(T0)。剩下的由你来编辑。我们走吧:

1.  将目录更改为内核源代码树的根目录(无论您在磁盘上的何处提取它):

```
cd ${LLKD_KSRC}
```

2.  基于前面描述的第三种方法(在*通过 localmodconfig 方法调整内核配置*部分)建立一个初始内核配置文件:

```
lsmod > /tmp/lsmod.now
make LSMOD=/tmp/lsmod.now localmodconfig
```

3.  运行用户界面:

```
make menuconfig
```

4.  一旦`menuconfig`用户界面加载完毕，进入`General Setup`菜单项。通常是 x86-64 上的第二项。使用键盘箭头键导航到它，并按下*回车*键进入它。
5.  您现在进入`General Setup`菜单项。按几次向下箭头键向下滚动菜单项。我们向下滚动到我们感兴趣的菜单–`Kernel .config support`–并突出显示它；屏幕应该是这样的:

![](Images/16adf547-a848-43af-8ba8-f17e90b971b3.png)

Figure 2.6 – Kernel configuration via make menuconfig; General setup / Kernel .config support For the 5.4.0 vanilla Linux kernel on the x86-64, `General Setup / Kernel .config support` is the 20<sup>th</sup> menu item from the top of the `General Setup` menu.

6.  一旦进入`Kernel .config support`菜单项，我们可以从其`<M>`前缀中看到(在前面的截图中)，它是一个三态菜单项，首先被设置为模块的选项`<M>`。
7.  保持该项目(`Kernel .config support`)高亮显示，使用右箭头键导航至底部工具栏上的`< Help >`按钮，并在按下`< Help >`按钮的同时按下*回车*键。屏幕现在应该是这样的:

![](Images/2e60495a-dea8-4035-85e5-c1087b20f220.png)

Figure 2.7 – Kernel configuration via make menuconfig; an example help screen

帮助屏幕信息非常丰富。事实上，一些内核配置帮助屏幕填充得非常好，而且实际上很有帮助。不幸的是，有些人不是。

8.  好的，接下来，按下`< Exit >`按钮上的*进入*，我们回到上一个画面。
9.  然后按空格键切换`Kernel .config support`菜单项(假设最初是这样:`<M>`；即，设置为模块)。按一次空格键会使用户界面项目显示如下:

```
<*> Kernel .config support
[ ]   Enable access to .config through /proc/config.gz (NEW)
```

请注意它是如何变成`<*>`的，这意味着这个特性将被内置到内核映像本身中(实际上，它将始终处于上的*)。现在，让我们这样做(当然，再次按下空格键会将其切换到关闭状态，`< >`，然后返回到原始的`<M>`状态)。*

10.  现在，项目处于`<*>`(是)状态，向下滚动到下一个菜单项`[*] Enable access to .config through /proc/config.gz`，并启用它(再次，通过按空格键)；屏幕现在应该像这样出现(我们只放大了相关部分):

![](Images/1705843f-80b5-475d-9ae8-1d8882f0d87b.png)

Figure 2.8 – Kernel configuration via make menuconfig: toggling a Boolean config option to the on state You can always use the right arrow key to go to `< Help >` and view the help screen for this item as well.

在这里，我们将不探究剩余的内核配置菜单；我将让您按照上表所示进行查找和设置。

11.  回到主菜单(主屏幕)，使用右箭头键导航至`< Exit >`按钮，并按下其上的*进入*。弹出一个对话框:

![](Images/30fe839c-5bac-4cac-b755-5a856778b673.png)

Figure 2.9 – Kernel configuration via make menuconfig: save dialog

很简单，不是吗？按下`< Yes >`按钮上的*进入*保存并退出。如果您选择`< No >`按钮，您将丢失所有配置更改(在此会话期间所做的更改)。或者，您可以按两次 *Esc* 键*来取消该对话框并继续进行内核配置。*

 *12.  保存并退出。在`< Yes >`按钮上按下*进入*。菜单系统 UI 现在保存新的内核配置，进程退出；我们又回到了控制台(外壳或终端窗口)提示。

但是新的内核配置保存在哪里呢？这一点很重要:内核配置被写入内核源码树根的一个简单的 ASCII 文本文件中，命名为 **`.config`** 。也就是保存在`${LLKD_KSRC}/.config`里。

如前所述，每个内核配置选项都与一个形式为`CONFIG_<FOO>`的配置变量相关联，其中`<FOO>`当然会被一个适当的名称替换。在内部，这些成为构建系统和内核源代码使用的*宏*。例如，考虑`Kernel .config support`选项:

```
$ grep IKCONFIG .config
CONFIG_IKCONFIG=y
CONFIG_IKCONFIG_PROC=y
$
```

啊哈！该配置现在反映了我们已经完成以下工作的事实:

*   打开`CONFIG_IKCONFIG`内核功能(`=y`表示它已打开，并将被内置到内核映像中)。
*   `/proc/config.gz`(伪)文件现在将可用，如`CONFIG_IKCONFIG_PROC=y`。

Caution*:* it's best to NOT attempt to edit the `.config` file manually ("by hand"). There are several inter-dependencies you may not be aware of; always use the kbuild menu system (we suggest via `make menuconfig`) to edit it.

事实上，在我们到目前为止使用 kbuild 系统的快速冒险中，引擎盖下已经发生了很多事情。下一节将对此进行一些研究，在菜单系统中进行搜索，并清晰地可视化原始(或旧的)和新的内核配置文件之间的差异。

## 关于 kbuild 的更多信息

通过`make menuconfig`或其他方法在内核源代码树的根中创建或编辑`.config`文件并不是 kbuild 系统如何使用配置的最后一步。不，它现在继续在内部调用一个名为`syncconfig`的目标，这个目标之前(误)名为`silentoldconfig`。这个目标让 kbuild 生成一些头文件，这些头文件将在构建内核的设置中进一步使用。这些文件包括`include/config`下的一些元头文件，以及`include/generated/autoconf.h`头文件，该文件将内核配置存储为 C 宏，从而使内核 Makefile 和内核代码能够根据内核功能是否可用来做出决定。

接下来，如果您正在寻找一个特定的内核配置选项，但是发现它有困难怎么办？没问题，`menuconfig` UI 系统有`Search Configuration Parameter` 功能。就像著名的`vi(1)`编辑器一样，按`/`(正斜杠)键弹出一个搜索对话框，然后输入您的搜索词，前面有或没有`CONFIG_`，并选择`< Ok >`按钮让它继续。

以下几个截图显示了搜索对话框和结果对话框(例如，我们搜索了术语`vbox`):

![](Images/b09a514c-3cda-42c7-81cd-ef2c0e7b3a0f.png)

Figure 2.10 – Kernel configuration via make menuconfig: searching for a config parameter

前面搜索的结果对话框很有趣。它揭示了关于配置选项的几条信息:

*   配置指令(只需在`Symbol:`中显示的内容前加上`CONFIG_`)
*   配置的类型(布尔、三态、字母数字等)

*   提示字符串
*   重要的是，它在菜单系统中的位置(所以你可以找到它)
*   它的内部依赖关系，如果有的话
*   任何它自动选择(打开)的配置选项，如果它本身被选中的话

以下是结果对话框的屏幕截图:

![](Images/900acdf5-16fa-47ef-a5a8-f021ad5d599c.png)

Figure 2.11 – Kernel configuration via make menuconfig: the result dialog from the preceding search

所有这些信息都存在于 kbuild 系统用来构建菜单系统 UI 的 ASCII 文本文件中——这个文件被称为`Kconfig`(实际上有好几个)。它的位置也显示出来了(在`Defined at ...`行)。

### 查找配置中的差异

在`.config`内核配置文件将要被写入的时刻，kbuild 系统检查它是否已经存在，如果存在，它用名称`.config.old`备份它。知道了这一点，我们就能区分两者，看到我们所做的改变。然而，用你典型的`diff(1)`工具来做这件事，会使差异很难解释。内核提供了一个更好的方法，一个基于控制台的脚本，专门做这一点。`scripts/diffconfig`脚本(在内核源代码树中)对此非常有用。要了解原因，让我们先运行它的帮助屏幕:

```
$ scripts/diffconfig --help
Usage: diffconfig [-h] [-m] [<config1> <config2>]

Diffconfig is a simple utility for comparing two .config files.
Using standard diff to compare .config files often includes extraneous and
distracting information. This utility produces sorted output with only the
changes in configuration values between the two files.

Added and removed items are shown with a leading plus or minus, respectively.
Changed items show the old and new values on a single line.
[...]
```

现在，我们尝试一下:

```
$ scripts/diffconfig .config.old .config
-AX25 n
-DEFAULT_SECURITY_APPARMOR y
-DEFAULT_SECURITY_SELINUX n
-DEFAULT_SECURITY_SMACK n
[...]
-SIGNATURE y
 DEBUG_STACK_USAGE n -> y
 DEFAULT_SECURITY_DAC n -> y
 FS_DAX y -> n
 HAMRADIO y -> n
 IKCONFIG m -> y
 IKCONFIG_PROC n -> y
 LOCALVERSION "" -> "-llkd01"
 MSDOS_FS n -> m
 PROFILING y -> n
 SECURITY y -> n
 UIO n -> m
+UIO_AEC n
 VBOXGUEST n -> m
[...]
$ 
```

如果您如上表所示修改了内核配置更改，那么您应该会通过内核的`diffconfig`脚本看到类似于前面代码块所示的输出。它清楚地向我们展示了我们究竟更改了哪些内核配置选项以及如何更改的。

在我们结束之前，先简要说明一些重要的事情:*内核安全性*。虽然用户空间安全强化技术有了很大发展，但内核空间安全强化技术实际上正在迎头赶上。内核配置选项的仔细配置在确定给定 Linux 内核的安全状态方面确实起着关键作用；问题是，有太多的选择(实际上是意见)，以至于通常很难(交叉)检查什么是安全方面的好主意，什么不是。亚历山大·波波夫写了一个非常有用的 Python 脚本名为`kconfig-hardened-check`；可以运行它来检查给定的内核配置(通过通常的配置文件)并将其与一组预定的强化首选项(来自各种 Linux 内核安全项目:众所周知的**内核自我保护项目** ( **KSPP** )、最后一个公共 grsecurity 补丁、CLIP OS 和安全锁定 LSM)进行比较。在[https://github.com/a13xp0p0v/kconfig-hardened-check](https://github.com/a13xp0p0v/kconfig-hardened-check)查找`kconfig-hardened-check` GitHub 资源库并试用！

好吧。您现在已经完成了 Linux 内核构建的前三个步骤，这是一件了不起的事情。(当然，我们将在下一章完成构建过程中的其余四个步骤。)本章最后，我们将学习一项有用的技能——如何定制内核 UI 菜单。

# 定制内核菜单–添加我们自己的菜单项

因此，假设您已经开发了一个设备驱动程序、一个实验性的新调度类、一个定制的`debugfs`(调试文件系统)回调，或者一些其他很酷的内核特性。你将如何让团队中的其他人——或者你的客户——知道这个奇妙的新内核特性的存在，并允许他们选择它(作为一个内置的或者作为一个内核模块)，从而构建和利用它？答案是在内核配置菜单的适当位置插入*一个新的菜单项*。

要做到这一点，首先多了解一些各种`Kconfig*`文件及其所在位置是很有用的。我们来看看。

## Kconfig*文件

内核源码树根部的`Kconfig`文件用来填充`menuconfig` UI 的初始屏幕。如果你愿意，可以看看。它通过在内核源代码树的不同文件夹中获取各种其他`Kconfig`文件来工作。下表总结了更重要的`Kconfig*`文件以及它们在 kbuild 用户界面中提供的菜单:

| 菜单 | **它的 Kconfig 文件位置** |
| 主菜单，初始屏幕 | `Kconfig` |
| 常规设置+启用可加载模块支持 | `init/Kconfig` |
| 处理器类型和功能
+总线选项+二进制仿真
(特定于 arch 菜单标题上方是针对 x86 的；一般来说，Kconfig 文件在这里:`arch/<arch>/Kconfig`) | `arch/<arch>/Kconfig` |
| 动力管理 | `kernel/power/Kconfig` |
| 固件驱动程序 | `drivers/firmware/Kconfig` |
| 虚拟化 | `arch/<arch>/kvm/Kconfig` |
| 常规架构相关选项 | `arch/Kconfig` |
| 启用块层
+输入输出调度器 | `block/Kconfig` |
| 可执行文件格式 | `fs/Kconfig.binfmt` |
| 内存管理选项 | `mm/Kconfig` |
| 网络支持 | `net/Kconfig, net/*/Kconfig` |
| 设备驱动程序 | `drivers/Kconfig, drivers/*/Kconfig` |
| 文件系统 | `fs/Kconfig, fs/*/Kconfig` |
| 安全选项 | `security/Kconfig, security/*/Kconfig*` |
| 加密应用编程接口 | `crypto/Kconfig, crypto/*/Kconfig` |
| 库例程 | `lib/Kconfig, lib/*/Kconfig` |
| 内核黑客 | `lib/Kconfig.debug, lib/Kconfig.*` |

Table 2.5 – Kernel config menu items and the corresponding Kconfig* file defining them

通常，单个`Kconfig`文件驱动单个菜单。现在，让我们继续实际添加菜单项。

## 在 Kconfig 文件中创建新菜单项

作为一个简单的例子，让我们在`General Setup`菜单中添加我们自己的布尔虚拟配置选项。我们希望配置名是`CONFIG_LLKD_OPTION1`。从上表可以看出，要编辑的相关`Kconfig`文件是`init/Kconfig`文件，因为这是定义`General Setup`菜单的菜单元文件。

让我们开始吧:

1.  为了安全起见，请务必制作一份备份:

```
cp init/Kconfig init/Kconfig.orig
```

2.  现在，编辑`init/Kconfig`文件:

```
vi init/Kconfig
```

向下滚动到文件中的适当位置；在这里，我们选择在`CONFIG_LOCALVERSION_AUTO`之后插入我们的菜单项。下面的截图显示了我们的新条目:

![](Images/e2f684bd-62e5-44ba-825b-631f291b2deb.png)

Figure 2.12 – Editing init/Kconfig and inserting our own menu entry We have provided the preceding text as a patch to the original `init/Kconfig` file in our book's *GitHub* source tree. Find it under `ch2/Kconfig.patch`.

新项目以`config`关键字开始，后跟新`CONFIG_LLKD_OPTION1`配置变量的`FOO`部分。现在，请阅读我们在`Kconfig`文件中对该条目所做的声明。关于`Kconfig`语言/语法的更多细节在后面的*关于 Kconfig 语言*部分的一些细节中。

3.  保存文件并退出编辑器。
4.  (重新)配置内核。导航到我们的新菜单项并打开该功能(请注意，在下面的截图中，它是如何高亮显示并关闭【默认情况下的 T0】):

```
make menuconfig
[...]
```

输出如下:

![](Images/0d6de2ce-0e2c-456c-829f-58a5b07bcdce.png)

Figure 2.13 – Kernel configuration via make menuconfig showing our new menu entry

5.  打开(用空格键切换)，然后保存并退出菜单系统。

While there, try pressing the `< Help >` button. You should see the "help" we provided within the `Kconfig` file.

6.  检查是否选择了我们的功能:

```
$ grep "LLKD_OPTION1" .config
CONFIG_LLKD_OPTION1=y
$ grep "LLKD_OPTION1" include/generated/autoconf.h 
$  
```

我们发现在我们的`.config`文件中，它确实已经被设置为上的*，但是还没有！)在内核内部自动生成的头文件中。这将在我们构建内核时发生。*

7.  构建内核(不用担心；下一章将介绍构建内核的全部细节。如果你愿意的话，你可以先学习第 3 章、*从源代码构建 5.x Linux 内核–第 2 部分*，然后再回到这一点...):

```
make -j4
```

8.  完成后，重新检查`autoconf.h`标题是否存在新的配置选项:

```
$ grep "LLKD_OPTION1" include/generated/autoconf.h 
#define CONFIG_LLKD_OPTION1 1
```

成功了。是的，但是当处理一个实际的项目(或产品)时，我们通常需要进一步的步骤，在 Makefile 中设置与使用这个配置选项的代码相关的配置条目。

这里有一个简单的例子来说明这种情况。在内核的顶层(或无论哪个)Makefile 中，下面一行将确保我们自己的代码(下面是在`llkd_option1.c`源文件中)在构建时被编译到内核中。将此行添加到相关 Makefile 的末尾:

```
obj-${CONFIG_LLKD_OPTION1}  +=  llkd_option1.o
```

Don't stress about the fairly weird kernel Makefile syntax for now. The next few chapters will shed some light on this.

此外，您应该意识到，在一段内核代码中，完全相同的配置可以用作普通的 C 宏；例如，我们可以这样做:

```
#ifdef CONFIG_LLKD_OPTION1
    do_our_thing();
#endif
```

然而，非常值得注意的是，Linux 内核社区已经设计并严格遵守了某些严格的编码风格准则。在这种情况下，指南指出应尽可能避免条件编译，如果要求使用`Kconfig`符号作为条件，请这样做:

```
if (IS_ENABLED(CONFIG_LLKD_OPTION1)) {
    do_our_thing();
}
```

The Linux kernel *coding style guidelines* can be found here: [https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html). I urge you to refer to them often, and, of course, to follow them!

## 关于 Kconfig 语言的一些细节

到目前为止，我们对`Kconfig`语言的使用只是众所周知的冰山一角。事实上，kbuild 系统使用`Kconfig`语言(或语法)来表达和创建菜单，使用简单的 ASCII 文本指令。该语言包括菜单项、属性、(反向)依赖关系、可见性约束、帮助文本等。

The kernel documents the `Kconfig` language constructs and syntax here: [https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt). Do refer to this document for complete details.

下表给出了更常见的`Kconfig`结构的简要(且不完整)说明:

| **构建** | **表示** |
| `config <FOO>` | 在此指定(表单`CONFIG_FOO`的)菜单项名称；只需放入`FOO`部分。 |
| **菜单属性** |  |
| `bool ["<description>"]` | 将配置选项指定为*布尔型*；它在`.config`中的值要么是`Y`(内置在内核映像中)，要么不存在(将显示为注释掉的条目)。 |
| `tristate ["description>"]` | 将配置选项指定为*三态*；它在`.config`中的值要么是`Y`、`M`(作为内核模块构建)，要么不存在(将显示为注释掉的条目) |
| `int ["<description>"]` | 将配置选项指定为取*整数*值。 |
| `range x-y` | 整数范围从`x`到`y`。 |
| `default <value>` | 指定默认值；根据需要，使用`y`、`m`、`n`或其他。
 |
| `prompt "<description>"` | 描述内核配置的句子。 |
| `depends on "expr"` | 定义菜单项的依赖关系；可以有几种同`depends on FOO1 && FOO2 && (FOO3 &#124;&#124; FOO4)`类型的语法。 |
| `select <config> [if "expr"]` | 定义反向依赖关系。 |
| `help "help-text"` | 选择`< Help >`按钮时显示的文本。 |

Table 2.6 – Kconfig, a few constructs

为了帮助理解语法，下面是几个来自`lib/Kconfig.debug`(描述`Kernel Hacking`菜单项的文件-内核调试，用户界面的真实部分)的例子:

1.  我们将从一个简单的选项开始:

```
config DEBUG_INFO
    bool "Compile the kernel with debug info"
    depends on DEBUG_KERNEL && !COMPILE_TEST
    help
      If you say Y here the resulting kernel image will include
      debugging info resulting in a larger kernel image. [...]
```

2.  接下来，我们来看看`CONFIG_FRAME_WARN`选项。请注意`range`和条件默认值语法，如下所示:

```
config FRAME_WARN
    int "Warn for stack frames larger than (needs gcc 4.4)"
    range 0 8192
    default 3072 if KASAN_EXTRA
    default 2048 if GCC_PLUGIN_LATENT_ENTROPY
    default 1280 if (!64BIT && PARISC)
    default 1024 if (!64BIT && !PARISC)
    default 2048 if 64BIT
    help
      Tell gcc to warn at build time for stack frames larger than this.
      Setting this too low will cause a lot of warnings.
      Setting it to 0 disables the warning.
      Requires gcc 4.4
```

3.  接下来，`CONFIG_HAVE_DEBUG_STACKOVERFLOW`选项是一个简单的布尔值；不是开就是关。`CONFIG_DEBUG_STACKOVERFLOW`选项也是一个布尔值。请注意它如何依赖于另外两个选项，用布尔 AND ( `&&`)运算符分隔:

```
config HAVE_DEBUG_STACKOVERFLOW
        bool

config DEBUG_STACKOVERFLOW
        bool "Check for stack overflows"
        depends on DEBUG_KERNEL && HAVE_DEBUG_STACKOVERFLOW
        ---help---
          Say Y here if you want to check for overflows of kernel, IRQ
          and exception stacks (if your architecture uses them). This 
          option will show detailed messages if free stack space drops
          below a certain limit. [...]
```

好吧。这就完成了我们在内核配置中创建(或编辑)一个自定义菜单项的内容，实际上也是本章的内容。

# 摘要

在本章中，您首先学习了如何为自己获取一个 Linux 内核源代码树。然后，您理解了它的发行版(或版本)命名法，各种类型的 Linux 内核(`-next`树、`-rc`/主线树、稳定、LTS、SLTS 和发行版)，以及基本的内核开发工作流。一路上，你甚至可以快速浏览内核源代码树，这样它的布局就更清晰了。接下来，您看到了如何将压缩的内核源树提取到磁盘，关键是如何配置内核——这是这个过程中的一个关键步骤。此外，您还学习了如何定制内核菜单，向其中添加您自己的条目，以及一点关于 kbuild 系统及其使用的相关`Kconfig`文件等。

知道如何获取和配置 Linux 内核是一项有用的技能。我们刚刚开始这个漫长而激动人心的旅程。您将意识到，随着对内核内部、驱动程序和目标系统硬件的更多经验和知识，您根据项目目的微调内核的能力只会变得更好。

我们已经走到一半了；我建议你先消化这份材料，更重要的是——尝试本章中的步骤，做问题/练习，浏览*进一步阅读*部分。然后，在下一章中，让我们实际构建 5.4.0 内核并验证它！

# 问题

作为我们的总结，这里有一个问题列表，供您测试您对本章材料的知识:[https://github . com/packt publishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。你会在这本书的 GitHub repo 中找到一些问题的答案:[https://GitHub . com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions _ to _ assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。

# 进一步阅读

为了帮助您用有用的材料更深入地研究这个主题，我们在本书的 GitHub 存储库中的进一步阅读文档中提供了一个相当详细的在线参考资料和链接列表(有时甚至是书籍)。*进一步阅读*文档可在此处获得:[https://github . com/packt publishing/Linux-Kernel-Programming/blob/master/进一步阅读. md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md) 。****