# 零、前言

这本书的明确目的是帮助你以一种实用的、动手的方式学习 Linux 内核开发，以及必要的理论背景，让你对这个广阔而有趣的主题领域有一个全面的了解。它特意通过强大的**可加载内核模块** ( **LKM** )框架关注内核开发；绝大多数内核项目和产品，包括设备驱动程序开发，都是以这种方式完成的。

重点在于对 Linux 操作系统内部的实际操作和足够深入的理解。在这些方面，我们涵盖了从源代码构建 Linux 内核到理解和处理复杂主题(如内核内的同步)的所有内容。

为了引导你踏上这段激动人心的旅程，我们将这本书分为三个部分。第一部分涵盖了基础知识——设置内核开发所需的工作空间，从源代码构建内核，以及编写第一个内核模块。

下一部分，一个关键的部分，将帮助您理解重要和基本的内核内部 Linux 内核架构、任务结构、用户和内核模式堆栈。内存管理是一个关键而有趣的话题——我们用了整整三章的时间来讨论它(充分覆盖了内部，重要的是，如何准确地分配任何空闲的内核内存)。Linux 上 CPU 调度的工作细节和更深层次的细节完成了这一部分。

这本书的最后一部分讨论了更高级的内核同步主题——在 Linux 内核上进行专业设计和代码的必要性。我们用两个完整的章节来讨论其中的关键主题。

本书在编写时使用了最新的 5.4 **长期支持** ( **LTS** ) Linux 内核。这是一个将从 2019 年 11 月一直维护到 2025 年 12 月的内核(包括 bug 和安全修复)！这是一个关键点，确保这本书的内容在未来几年保持最新和有效！

我们非常相信实践方法:这本书的 GitHub 存储库中有超过 20 个内核模块(除了几个用户应用程序和 shell 脚本)，让学习变得生动起来，使它变得有趣、有趣和有用。

我们强烈建议您也利用本书的配套指南 *Linux 内核编程(第 2 部分)*。

这是一本优秀的面向行业的初学者指南，用于编写`misc`字符驱动程序、在外围芯片内存上执行 I/O 以及处理硬件中断。你可以免费得到这本书和你的副本，或者你也可以在 GitHub 知识库中找到这本书，网址是:[https://GitHub . com/PacktPublishing/Linux-Kernel-Programming/tree/master/Linux-Kernel-Programming-(Part-2)](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/Linux-Kernel-Programming-(Part-2))。

我们真的希望你能从这本书中学到东西并喜欢它。快乐阅读！

# 这本书是给谁的

这本书主要是为那些在 Linux 内核模块开发以及某种程度上 Linux 设备驱动程序开发的广阔舞台上开始旅程的人准备的。它也非常针对那些已经在研究 Linux 模块和/或驱动程序的人，他们希望对 Linux 内核体系结构、内存管理和同步有更深入、更好的理解。当你面对难以调试的现实情况时，这种关于底层操作系统的知识水平，以适当的结构化方式覆盖，将帮助你无止境。

# 这本书涵盖了什么

[第 1 章](01.html)、*内核工作区设置*，指导您设置成熟的 Linux 内核开发工作区(通常是作为完全虚拟化的客户系统)。您将学习如何在其上安装所有必需的软件包，包括交叉工具链。您还将了解其他几个开源项目，这些项目将有助于您成为专业的内核/驱动程序开发人员。完成本章后，您将准备好构建一个 Linux 内核，并开始编写和测试内核代码(通过可加载内核模块框架)。在我们看来，对你来说，以实际操作的方式使用这本书，尝试和试验代码是非常重要的。最好的学习方法是凭经验去做——根本不相信任何人的话，而是自己去尝试和体验。

[第 2 章](02.html)、*从源代码构建 5.x Linux 内核–第 1 部分*，是解释如何用源代码从头构建现代 Linux 内核的第一部分。在这一部分中，您将在内核源代码树中获得必要的背景信息——版本命名、不同的源代码树、内核源代码的布局。接下来，将向您详细展示如何将稳定的普通 Linux 内核源代码树下载到虚拟机上。然后，我们将学习一些关于内核源代码的布局，实际上，获得内核代码库的“10，000 英尺视图”。接下来是提取和配置 Linux 内核的实际工作。还显示了为内核配置创建和使用自定义菜单项。

[第 3 章](03.html)、*从源代码构建 5.x Linux 内核–第 2 部分*，是关于从源代码执行内核构建的第二部分。在这一部分中，您将继续上一章，现在实际构建内核，安装内核模块，了解什么是`initramfs` ( `initrd`)以及如何生成它，以及设置引导加载程序(对于 x86)。此外，作为一个有价值的附加组件，本章然后解释了如何为典型的嵌入式 ARM 目标交叉编译内核(使用流行的树莓 Pi 作为目标设备)。还提到了关于内核构建，甚至内核安全性(强化)的一些技巧和窍门。

[第 4 章](04.html)、*编写你的第一个内核模块——LKMs 第 1 部分*，是两部分的第一部分，这两部分涵盖了 Linux 内核开发的一个基本方面——LKM 框架，以及内核模块或设备驱动程序程序员如何被“模块用户”理解和使用。它涵盖了 Linux 内核架构的基础知识，然后非常详细地介绍了编写一个简单的“Hello，world”内核模块、编译、插入、检查和从内核空间中移除它所涉及的每一步。我们还详细介绍了通过无处不在的 printk API 进行内核日志记录。

[第 5 章](05.html)、*编写您的第一个内核模块——LKMs 第 2 部分*，是涵盖 LKM 框架的第二部分。在这里，我们从一些关键的东西开始——学习如何使用“更好的”Makefile，这将帮助您生成更健壮的代码(有几个代码检查、纠正、静态分析目标，等等)。然后，我们详细展示了成功交叉编译替代体系结构的内核模块的步骤，如何在内核中模拟“类库”代码(通过“链接”和模块堆叠方法)，定义和使用传递参数到内核模块。其他主题包括引导时模块的自动加载、重要的安全指南，以及一些关于内核文档和如何访问它的信息。几个示例内核模块使学习更加有趣。

[第 6 章](06.html)、*内核内部要素–进程和线程、*深入研究了一些基本的内核内部主题。我们从什么是进程和中断上下文中的执行，以及进程用户**虚拟地址空间** ( **VAS** )布局的最小但必需的覆盖范围开始。这为你搭建了舞台；然后，您将更深入地了解 Linux 内核架构，重点关注进程/线程任务结构的组织及其对应的堆栈——用户模式和内核模式。然后，我们将向您展示更多关于内核任务结构(一个“根”数据结构)的内容，以及如何从其中收集信息，甚至迭代各种(任务)列表。几个内核模块让这个话题变得生动起来。

[第 7 章](07.html)，*内存管理内部构件–要点，*这是一个关键章节，深入研究了 Linux 内存管理子系统的基本内部构件，达到了典型模块作者或驱动程序开发人员所需的详细程度。因此，这种覆盖本质上必然更具理论性；尽管如此，在这里获得的知识对于您(内核开发人员)来说是至关重要的，对于深入理解和使用适当的内核内存 API 以及在内核级别执行有意义的调试都是如此。我们介绍了虚拟机拆分(以及它在各种实际架构中的表现)，深入了解了用户增值服务(我们的 procmap 实用程序将会大开眼界)，以及内核部分(或内核增值服务)。然后，我们简要地研究了内存布局随机化的安全技术(ASLR)，并在本章的最后讨论了 Linux 中的物理内存组织。

[第 8 章](08.html)，*模块作者的内核内存分配第 1 部分，*用内核内存分配(显然也是解除分配)API 弄脏我们的手。您将首先了解 Linux 中的两个分配“层”——位于内核内存分配“引擎”之上的平板分配器和页面分配器(或 BSA)。我们将简要了解页面分配器算法及其“自由列表”数据结构的基础；在决定使用哪一层时，这些信息很有价值。接下来，我们直接进入学习这些关键 API 用法的实践工作。涵盖了 slab 分配器(或缓存)和主要内核分配器 APIs 即`kzalloc`/`kfree`—背后的思想。重要的是，使用这些通用 API 时的大小限制、缺点和注意事项也有详细介绍。另外，对驱动程序作者特别有用的是，我们介绍了内核的现代资源管理内存分配 API(T2 例程)。

[第 9 章](09.html)、*模块作者的内核内存分配第 2 部分*，在逻辑上比前一章更进一步。在这里，您将学习如何创建自定义的 slab 缓存(例如，对于自定义驱动程序的高频(de)分配很有用)，以及一些关于调试 slab 层内存分配的帮助。接下来，您将了解并使用`vmalloc()` API(和朋友)。非常重要的是，在介绍了内核内存(de)分配的许多 API 之后，您现在将了解如何根据您所处的现实环境选择合适的 API。本章以内核的**内存不足** ( **OOM** )“杀手级”框架的重要内容结束。通过按需分页技术，理解它还将导致对用户空间内存分配真正如何工作的更深入的理解。

[第 10 章](10.html)、*CPU 调度器-第 1 部分*，两章的第一部分，涵盖了 Linux 操作系统上 CPU 调度的理论和实践的有益结合。KSE 和可用内核调度策略等线程的最基本的必要理论背景是最初涉及的主题。接下来，我们将介绍关于 CPU 调度的足够多的内核内部细节，让您了解现代 Linux 操作系统上的调度是如何工作的。一路走来，你将学会如何用 perf 等强大的工具“可视化”PU 调度；还深入研究了线程调度属性(策略和实时优先级)。

[第 11 章](11.html)、*CPU 调度程序–第 2 部分，*关于 CPU 调度的第二部分，继续更深入地讲述这个主题。在这里，我们将进一步介绍用于 CPU 调度的可视化工具(利用强大的软件，如 LTTng 和 trace-cmd 实用程序)。接下来是 CPU 相似性掩码以及如何查询/设置它，在每个线程的基础上控制调度策略和优先级——如此强大的功能！深入研究。可以看到控制组(cggroups)的含义和重要性的概述，以及通过 cgroups v2 分配 CPU 带宽的有趣示例。你能像 RTOS 一样运行 Linux 吗？你的确可以！然后显示实际这样做的细节。我们在这一章的最后讨论了(调度)延迟以及如何测量它们。

[第 12 章](12.html)、*内核同步–第 1 部分*，首先涵盖了关于关键部分、原子性、锁在概念上实现了什么以及非常重要的是，所有这些的原因的关键概念。然后，当在 Linux 内核中工作时，我们将讨论并发问题；这让我们自然而然地转向重要的锁定准则、死锁的含义以及防止死锁的关键方法。两种最流行的内核锁定技术——互斥锁和自旋锁——以及几个(驱动程序)代码示例将被深入讨论。

[第 13 章](13.html)、*内核同步–第 2 部分*，继续内核同步之旅。在这里，您将了解键锁定优化——使用轻量级原子操作符和(最近的)refcount 操作符来安全地操作整数，使用 RMW 位操作符来安全地执行位操作，以及读写自旋锁的使用。还讨论了固有风险，如缓存“错误共享”。然后介绍了无锁编程技术的概述(重点是每 CPU 变量及其用法，以及示例)。接下来将讨论一个关键的主题——锁调试技术，包括使用内核强大的“lockdep”锁验证器。这一章的结尾是对记忆障碍的简要介绍(以及一个例子)。

# 充分利用这本书

为了充分利用这本书，我们希望您具备以下方面的知识和经验:

*   在命令行(Shell)上熟悉 Linux 系统。
*   C 编程语言。
*   这不是强制性的，但是对 Linux 系统编程概念和技术的经验会有很大帮助。

在[第 1 章](01.html)、*内核工作区设置*中，详细介绍了硬件和软件要求及其安装。重要的是你要详细阅读它，并遵循其中的说明。

此外，我们已经在这些平台上测试了本书中的所有代码(它也有自己的 GitHub 存储库):

*   x86_64 Ubuntu 18.04 LTS 来宾操作系统(运行在甲骨文虚拟桌面 6.1 上)
*   x86_64 Ubuntu 20.04.1 LTS 来宾操作系统(运行在甲骨文虚拟桌面 6.1 上)
*   x86_64 Ubuntu 20.04.1 LTS 本地操作系统
*   ARM 树莓 Pi 3B+(运行其“发行版”内核以及我们定制的 5.4 内核)；轻度测试
*   x86_64 CentOS 8 来宾操作系统(运行在 Oracle VirtualBox 6.1 上)；轻度测试

我们假设，当作为来宾(VM)运行 Linux 时，主机系统要么是 Windows 10 或更高版本(当然，即使是 Windows 7 也能工作)，要么是最近的 Linux 发行版(例如，Ubuntu 或 Fedora)，甚至是 macOS。

**如果您正在使用本书的数字版本，我们建议您自己键入代码，或者更好的是，通过 GitHub 存储库(下一节中提供的链接)访问代码。这样做将帮助您避免任何与复制和粘贴代码相关的潜在错误。**

我强烈建议你遵循*经验主义的方法:不要相信任何人的话，而是自己去尝试和体验。*因此，这本书给了你许多你可以而且必须亲自尝试的实践实验和内核代码示例；这将极大地帮助您取得真正的进步，并深入学习和理解 Linux 内核开发的各个方面。

## 下载示例代码文件

你可以在[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming)从 GitHub 下载这本书的示例代码文件。如果代码有更新，它将在现有的 GitHub 存储库中更新。

我们还有来自丰富的图书和视频目录的其他代码包，可在**[【https://github.com/PacktPublishing/】](https://github.com/PacktPublishing/)**获得。看看他们！

## 下载彩色图像

我们还提供了一个 PDF 文件，其中包含本书中使用的截图/图表的彩色图像。可以在这里下载:[http://www . packtpub . com/sites/default/files/downloads/9781789953435 _ color images . pdf](_ColorImages.pdf)。

## 使用的约定

本书通篇使用了许多文本约定。

`CodeInText`:表示文本中的码字、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟网址、用户输入和推特句柄。这里有一个例子:“应用编程接口返回一个 T2 类型的 KVA(因为它是一个地址位置)”

代码块设置如下:

```sh
static int __init miscdrv_init(void)
{
    int ret;
    struct device *dev;
```

当我们希望将您的注意力吸引到代码块的特定部分时，相关的行或项目以粗体显示:

```sh
#define pr_fmt(fmt) "%s:%s(): " fmt, KBUILD_MODNAME, __func__
[...]
#include <linux/miscdevice.h>
#include <linux/fs.h>             
[...]
```

任何命令行输入或输出都编写如下:

```sh
pi@raspberrypi:~ $ sudo cat /proc/iomem
```

**粗体**:表示一个新的术语、一个重要的单词或者你在屏幕上看到的单词。例如，菜单或对话框中的单词像这样出现在文本中。下面是一个示例:“从管理面板中选择系统信息。”

Warnings or important notes appear like this. Tips and tricks appear like this.

# 取得联系

我们随时欢迎读者的反馈。

**一般反馈**:如果你对这本书的任何方面有疑问，在你的信息主题中提到书名，发邮件给我们`customercare@packtpub.com`。

**勘误表**:虽然我们已经尽了最大的努力来保证内容的准确性，但是错误还是会发生。如果你在这本书里发现了一个错误，如果你能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择您的图书，点击勘误表提交链接，并输入详细信息。

**盗版**:如果您在互联网上遇到任何形式的我们作品的非法拷贝，如果您能提供我们的位置地址或网站名称，我们将不胜感激。请通过`copyright@packt.com`联系我们，并提供材料链接。

**如果你有兴趣成为一名作者**:如果有一个你有专长的话题，你有兴趣写或者投稿一本书，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

## 复习

请留下评论。一旦你阅读并使用了这本书，为什么不在你购买它的网站上留下评论呢？然后，潜在的读者可以看到并使用您不带偏见的意见来做出购买决定，我们在 Packt 可以了解您对我们产品的看法，我们的作者可以看到您对他们的书的反馈。谢谢大家！

更多关于 Packt 的信息，请访问[packt.com](http://www.packt.com/)。