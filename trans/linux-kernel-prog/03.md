# 三、从源码构建 5.x Linux 内核——第二部分

这一章延续了前一章的内容。在前一章中，在*从源代码构建内核的步骤*部分*、*中，我们介绍了构建内核的前三个步骤。在那里，你学会了如何下载并提取内核源码树甚至`git clone`一个(*步骤 1* 和 *2* )。然后，我们开始理解内核源代码树布局，以及非常重要的是，正确到达配置内核的起点的各种方法(*步骤 3* )。我们甚至在内核配置菜单中添加了一个自定义菜单项。

在这一章中，我们继续探索如何构建内核，涵盖了实际构建内核的其余四个步骤。首先，当然，我们构建它(*第 4 步*)。然后，您将看到如何正确安装作为构建的一部分生成的内核模块(*步骤 5* )。接下来，我们运行一个简单的命令来设置 GRUB 引导加载程序并生成`initramfs`(或`initrd`)图像(*第 6 步*)。还讨论了使用`initramfs`图像的动机以及如何使用。接下来将介绍配置 GRUB 引导加载程序(适用于 x86)的一些细节(*第 7 步*)。

本章结束时，我们将使用新的内核映像引导系统，并验证它是否如预期那样构建。然后，我们将通过学习如何*交叉编译*一个用于国外架构的 Linux 内核(也就是 ARM，讨论中的板是众所周知的树莓 Pi)来结束。

简而言之，这些是涵盖的领域:

*   步骤 4–构建内核映像和模块
*   步骤 5–安装内核模块

*   步骤 6–生成 initramfs 映像和引导加载程序设置
*   理解 initramfs 框架
*   步骤 7–定制 GRUB 引导加载程序

*   验证我们新内核的配置
*   树莓皮的内核构建
*   内核构建的其他技巧

# 技术要求

在我们开始之前，我假设您已经下载、提取(如果需要)并配置了内核，从而准备好了`.config`文件。如果您还没有这样做，请参考上一章了解具体是如何做到的。我们现在可以开始建造了。

# 步骤 4–构建内核映像和模块

从最终用户的角度执行构建实际上非常简单。在最简单的形式中，只需确保您位于已配置内核源代码树的根目录中，然后键入`make`。就是这样——内核映像和任何内核模块(在嵌入式系统上，可能是一个**设备树 Blob** ( **DTB** )二进制文件)将被构建。去喝杯咖啡！第一次，可能需要一段时间。

当然还有各种`Makefile`目标我们可以传递给`make`。命令行上快速发出的`make help`命令透露了不少。请记住，事实上，我们之前使用这个来查看所有可能的配置目标。在这里，我们使用它来查看`all`目标默认构建的内容:

```sh
$ cd ${LLKD_KSRC}     # the env var LLKD_KSRC holds the 'root' of our 
                      # 5.4 kernel source tree
$ make help
[...]
Other generic targets:
  all - Build all targets marked with [*]
* vmlinux - Build the bare kernel
* modules - Build all modules
[...]
Architecture specific targets (x86):
* bzImage - Compressed kernel image (arch/x86/boot/bzImage)
[...]
$ 
```

好的，那么执行`make all`会得到前面的三个目标，前缀为`*`的目标；他们是什么意思？

*   `vmlinux`实际上匹配未压缩内核映像的名称。
*   `modules`目标意味着所有标记为`m`(用于模块)的内核配置选项将被构建为内核源树中的内核模块(`.ko`文件)(关于内核模块到底是什么以及如何编程的细节是下面两章的主题)。
*   `bzImage`是特定于架构的。在 x86[-64]系统上，这是压缩内核映像的名称——引导加载程序将实际加载到内存中、在内存中解压缩并引导到的映像；实际上，内核映像文件。

那么，一个常见问题:如果`bzImage`是我们用来引导和初始化系统的实际内核，那么`vmlinux`是干什么用的？注意`vmlinux`是未压缩的内核镜像。它可能很大(甚至非常大，因为在调试构建期间生成了内核符号)。虽然我们从不通过`vmlinux`启动，但它仍然很重要。出于内核调试的目的，一定要保留它(不幸的是，这超出了本书的范围)。

With the kbuild system, just running a `make` command equates to `make all`.

内核代码库非常庞大。目前的估计是 2000 万行源代码 ( **SLOC** )因此，构建内核确实是一项非常消耗内存和 CPU 的工作。的确，有些人把内核构建作为压力测试！现代`make(1)`实用程序功能强大，支持多进程。我们可以请求它产生多个进程来并行处理构建的不同(不相关的)部分，从而提高吞吐量并缩短构建时间。相关选项是`-j'n'`，其中`n`是并行产生和运行的任务数量上限。用于确定这一点的启发式方法(经验法则)如下:

```sh
n = num-CPU-cores * factor;
```

这里，`factor`为 2(或者在拥有数百个 CPU 内核的非常高端的系统上为 1.5)。此外，在技术上，我们要求内核具有内部“线程”或使用**同步多线程**(**SMT**)—英特尔称之为*超线程*—这样的启发才会有用。

More details on parallelized `make` and how it works can be found in the man page of `make(1)` (invoked with `man 1 make`) in the `PARALLEL MAKE AND THE JOBSERVER` section.

另一个常见问题:你的系统上有多少个中央处理器内核*？有几种方法可以确定这一点，一个简单的方法是使用`nproc(1)`实用程序:*

```sh
$ nproc
2 
```

A quick word regarding `nproc(1)` and related utilities:
a) Performing `strace(1)` on `nproc(1)` reveals that it works by essentially using the `sched_getaffinity(2)` system call. We shall mention more on this and related system calls in [Chapter 9](10.html), *The CPU Scheduler – Part 1*, and [Chapter 10](11.html), *The CPU Scheduler – Part 2*, on CPU scheduling.
b) FYI, the `lscpu(1)` utility yields the number of cores as well as additional useful CPU info. For example, it shows whether it's running on a **Virtual Machine** (**VM**) (as does the `virt-what` script). Try it out on your Linux system.

显然，我们的来宾虚拟机已经配置了两个 CPU 内核，所以让我们保留`n=2*2=4`。所以，我们开始构建内核。以下输出来自我们值得信赖的 x86_64 Ubuntu 18.04 LTS 来宾系统，该系统配置有 2 GB 内存和两个中央处理器内核。

Remember, the kernel must first be *configured.* For details, refer to [Chapter 2](02.html), *Building the 5.x Linux Kernel from Source – Part 1*.

同样，当您开始时，内核构建完全有可能发出警告，尽管在这种情况下不是致命的:

```sh
$ time make -j4
scripts/kconfig/conf --syncconfig Kconfig
 UPD include/config/kernel.release
warning: Cannot use CONFIG_STACK_VALIDATION=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel
[...]
```

因此，为了解决这个问题，我们用 *Ctrl* + *C* 中断构建，然后按照输出的建议安装`libelf-dev`包。在我们的 Ubuntu 盒子上，`sudo apt install libelf-dev`就足够了。如果您遵循第 1 章、*内核工作空间设置*中的详细设置，这将不会发生。重试，它现在起作用了！为了让您对此有所了解，我们展示了以下构建输出的小片段。不过，真的，最好还是自己去尝试一下:

Precisely because the kernel build is very CPU- and RAM-intensive, carrying this out on a guest VM is going to be a lot slower than on a native Linux system. It helps to conserve RAM by at least booting your guest at run-level 3 (multiuser with networking, no GUI): [https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/](https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/).

```sh
$ cd ${LLKD_KSRC} $ time make -j4 scripts/kconfig/conf --syncconfig Kconfig SYSHDR arch/x86/include/generated/asm/unistd_32_ia32.h
 SYSTBL arch/x86/include/generated/asm/syscalls_32.h
[...]
  DESCEND objtool
  HOSTCC /home/llkd/kernels/linux-5.4/tools/objtool/fixdep.o
  HOSTLD /home/llkd/kernels/linux-5.4/tools/objtool/fixdep-in.o
  LINK /home/llkd/kernels/linux-5.4/tools/objtool/fixdep
[...]

[...]
  LD      vmlinux.o
  MODPOST vmlinux.o
  MODINFO modules.builtin.modinfo
  LD      .tmp_vmlinux1
  KSYM    .tmp_kallsyms1.o
  LD      .tmp_vmlinux2
  KSYM    .tmp_kallsyms2.o
 LD      vmlinux
  SORTEX  vmlinux
  SYSMAP  System.map
  Building modules, stage 2.
 MODPOST 59 modules
  CC      arch/x86/boot/a20.o
[...]
  LD      arch/x86/boot/setup.elf
  OBJCOPY arch/x86/boot/setup.bin
  BUILD   arch/x86/boot/bzImage
Setup is 17724 bytes (padded to 17920 bytes).
System is 8385 kB
CRC 6f010e63
  CC [M]  drivers/hid/hid.mod.o
Kernel: arch/x86/boot/bzImage is ready  (#1)
```

好了，内核映像(这里叫做`bzImage`)和`vmlinux`文件已经通过将生成的各种对象文件拼接在一起成功构建，正如前面的输出中所看到的——前面的块中的最后一行证实了这一事实。但是等等，建造还没有完成。kbuild 系统现在继续完成所有内核模块的构建；输出的最后一部分如下所示:

```sh
[...]
  CC [M]  drivers/hid/usbhid/usbhid.mod.o
  CC [M]  drivers/i2c/algos/i2c-algo-bit.mod.o
[...]
  LD [M] sound/pci/snd-intel8x0.ko
  LD [M] sound/soundcore.ko

real     17m31.980s
user     23m58.451s
sys      3m22.280s
$
```

整个过程似乎总共花了大约 17.5 分钟。`time(1)`实用程序为我们提供了一个(非常)粗粒度的想法，即跟随它的命令所花费的时间。

If you'd like accurate CPU profiling, learn to use the powerful `perf(1)` utility. Here, you can try it out with the `perf stat make -j4` command. I suggest you try this out on a distro kernel as otherwise, `perf` itself will have to be manually built for your custom kernel.

同样，在前面的输出中，`Kernel: arch/x86/boot/bzImage is ready (#1)`、`#1`暗示这是这个内核的第一次构建。这个数字会在后续的构建中自动递增，并在你启动到新内核并执行`uname -a`时显示出来。

As we're doing a parallelized build (via `make -j4`, implying four processes performing the build in parallel), all the build processes still write to the same `stdout` location – the terminal window. Hence, it can happen that the output is out of order or mixed up.

构建应该干净地运行，没有任何错误或警告。嗯，有时会看到编译器警告，但我们会愉快地忽略它们。如果在此步骤中遇到编译器错误，从而导致构建失败，该怎么办？我们该如何礼貌地表达呢？哦，我们不能——这很可能是你的错，而不是内核社区的错。请检查并重新检查每一步，如果所有其他步骤都失败，请使用`make mrproper`命令从头开始重做！通常，构建内核的失败意味着内核配置错误(随机选择的可能冲突的配置)、工具链的过时版本或不正确的补丁等等。

假设它进行得很顺利，实际上也应该如此，当这个步骤终止时，kbuild 系统已经生成了三个关键文件(在许多文件中)。

在内核源代码树的根中，我们有以下内容:

*   未压缩的内核镜像文件`vmlinux`(仅用于调试)
*   符号-地址映射文件，`System.map`
*   压缩的可启动内核镜像文件`bzImage`(见以下输出)

我们去看看吧！我们通过将`-h`选项传递给`ls(1)`，使输出(特别是文件大小)更具可读性:

```sh
$ ls -lh vmlinux System.map
-rw-rw-r-- 1 llkd llkd 4.1M Jan 17 12:27 System.map
-rwxrwxr-x 1 llkd llkd 591M Jan 17 12:27 vmlinux
$ file ./vmlinux
./vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=<...>, with debug_info, not stripped
```

如你所见，`vmlinux`文件相当大。这是因为它包含所有内核符号以及编码到其中的额外调试信息。(仅供参考，`vmlinux`和`System.map`文件用于内核调试上下文；把他们留在身边。)有用的`file(1)`实用程序向我们展示了关于这个图像文件的更多细节。引导加载程序加载并引导到的实际内核映像文件将始终位于`arch/<arch>/boot/`的通用位置；因此，对于 x86 体系结构，我们有以下内容:

```sh
$ ls -l arch/x86/boot/bzImage -rw-rw-r-- 1 llkd llkd 8604032 Jan 17 12:27 arch/x86/boot/bzImage$ file arch/x86/boot/bzImage
arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 5.4.0-llkd01 (llkd@llkd-vbox) #1 SMP Thu [...], RO-rootFS, swap_dev 0x8, Normal VGA
```

x86_64 的压缩内核映像版本`5.4.0-llkd01`大小略大于 8 MB。`file(1)`实用程序再次清楚地揭示了它确实是 x86 体系结构的 Linux 内核引导映像。

The kernel documents several tweaks and switches that can be performed during the kernel build by setting various environment variables. This documentation can be found within the kernel source tree at `Documentation/kbuild/kbuild.rst`. We shall in fact use the `INSTALL_MOD_PATH`, `ARCH`, and `CROSS_COMPILE` environment variables in the material that follows.

太好了。我们的内核映像和模块已经准备好了！在我们安装内核模块作为下一步的一部分时，请继续阅读。

# 步骤 5–安装内核模块

在上一步中，所有标记为`m`的内核配置选项实际上都已经构建好了。正如您将了解到的，这还不够:它们现在必须安装到系统上的已知位置。本节涵盖这些细节。

## 在内核源代码中定位内核模块

为了查看上一步——内核构建——刚刚生成的内核模块，让我们在内核源文件夹中执行一个快速`find(1)`命令。理解使用的命名约定，内核模块文件名以`.ko`结尾:

```sh
$ cd ${LLKD_KSRC}
$ find . -name "*.ko"
./arch/x86/events/intel/intel-rapl-perf.ko
./arch/x86/crypto/crc32-pclmul.ko
./arch/x86/crypto/ghash-clmulni-intel.ko
[...]
./net/ipv4/netfilter/ip_tables.ko
./net/sched/sch_fq_codel.ko
$ find . -name "*.ko" | wc -l
59 
```

从前面的输出中我们可以看到，在这个特定的构建中，总共有 59 个内核模块被构建(为了简洁起见，实际的`find`输出在前面的块中被截断了)。

现在，回想一下我在[第 2 章](02.html)、*中要求您在 make menuconfig UI* 部分的*示例用法中从源代码构建 5.x Linux 内核的练习。在*表 2.4* 中，最后一列指定了我们所做的更改类型。寻找`n -> m`(或`y -> m`)变化，这意味着我们正在将该特定特性配置为内核模块。在那里，我们可以看到这包括以下特征:*

*   VirtualBox 支持，`n -> m`
*   **用户空间输入输出** ( **UIO** )司机，`n -> m`；和一个通用 IRQ 处理的 UIO 平台驱动程序`n -> m`
*   微软操作系统文件系统支持，`n -> m`

由于这些特性被要求作为模块构建，它们不会被编码在`vmlinux`或`bzImage`内核映像文件中。不，它们将作为独立的(嗯，有点像)*内核模块*存在。让我们在内核源代码树中寻找前面特性的内核模块(用一点脚本语言显示它们的路径名和大小):

```sh
$ find . -name "*.ko" -ls | egrep -i "vbox|msdos|uio" | awk '{printf "%-40s %9d\n", $11, $7}'
./fs/fat/msdos.ko                           361896
./drivers/virt/vboxguest/vboxguest.ko       948752
./drivers/gpu/drm/vboxvideo/vboxvideo.ko   3279528
./drivers/uio/uio.ko                        408136
./drivers/uio/uio_pdrv_genirq.ko            324568
$ 
```

好的，很好，二进制内核模块确实是在内核源代码树中生成的。但仅此还不够。为什么呢？它们需要被*安装到根文件系统中的一个众所周知的位置，以便在启动时，系统*可以实际找到它们并将它们加载到内核内存中。这就是为什么我们需要*安装*内核模块。“根文件系统中众所周知的位置”是 **`/lib/modules/$(uname -r)/`** ，其中`$(uname -r)`当然产生内核版本号。**

## 安装内核模块

执行内核模块安装很简单；(构建步骤后)只需调用`modules_install` Makefile 目标。让我们这样做:

```sh
$ cd ${LLKD_KSRC} $ sudo make modules_install [sudo] password for llkd: 
  INSTALL arch/x86/crypto/aesni-intel.ko
  INSTALL arch/x86/crypto/crc32-pclmul.ko
  INSTALL arch/x86/crypto/crct10dif-pclmul.ko
[...]
  INSTALL sound/pci/snd-intel8x0.ko
  INSTALL sound/soundcore.ko
  DEPMOD 5.4.0-llkd01
$ 
```

请注意，我们使用`sudo(8)`以 root (超级用户)身份执行安装*。这是必需的，因为默认安装位置(在`/lib/modules/`下)只有根可写。一旦内核模块已经准备好并被复制(在前面的输出块中显示为`INSTALL`的工作)，kbuild 系统运行一个名为`depmod(8)`的实用程序。它的工作本质上是解决内核模块之间的依赖关系，并将它们(如果存在的话)编码成一些元文件(更多细节请参考`depmod(8)`的手册页:[https://linux.die.net/man/8/depmod](https://linux.die.net/man/8/depmod))。*

现在让我们看看模块安装步骤的结果:

```sh
$ uname -r
5.0.0-36-generic        # this is the 'distro' kernel (for Ubuntu 18.04.3 LTS) we're running on
$ ls /lib/modules/
5.0.0-23-generic 5.0.0-36-generic 5.4.0-llkd01
$ 
```

在前面的代码中，我们可以看到，对于我们可以引导系统进入的每个(Linux)内核，在`/lib/modules/`下都有一个文件夹，正如预期的那样，它的名字是内核版本。让我们看看感兴趣的文件夹——我们的新内核(`5.4.0-llkd01`)。在那里，在`kernel/`子目录下的不同目录中，有刚刚安装的内核模块:

```sh
$ ls /lib/modules/5.4.0-llkd01/kernel/
arch/  crypto/  drivers/  fs/  net/  sound/
```

Incidentally, the `/lib/modules/<kernel-ver>/modules.builtin` file has the list of all installed kernel modules (under `/lib/modules/<kernel-ver>/kernel/`).

让我们在这里搜索前面提到的内核模块:

```sh
$ find /lib/modules/5.4.0-llkd01/kernel/ -name "*.ko" | egrep "vboxguest|msdos|uio"
/lib/modules/5.4.0-llkd01/kernel/fs/fat/msdos.ko
/lib/modules/5.4.0-llkd01/kernel/drivers/virt/vboxguest/vboxguest.ko
/lib/modules/5.4.0-llkd01/kernel/drivers/uio/uio.ko
/lib/modules/5.4.0-llkd01/kernel/drivers/uio/uio_pdrv_genirq.ko
$ 
```

他们都出现了。太棒了！

最后一个关键点:在内核构建期间，我们可以将内核模块安装到我们*指定的位置，覆盖(默认)`/lib/modules/<kernel-ver>`位置。这是通过将`INSTALL_MOD_PATH`的环境变量设置到所需位置来完成的；例如，执行以下操作:*

```sh
export STG_MYKMODS=../staging/rootfs/my_kernel_modules
make INSTALL_MOD_PATH=${STG_MYKMODS} modules_install
```

这样，我们就把所有的内核模块都安装到`${STG_MYKMODS}/`文件夹中了。请注意，如果`INSTALL_MOD_PATH`指的是不需要*根*进行书写的位置，那么`sudo`可能是不需要的。

This technique – overriding the *kernel modules' install location* – can be especially useful when building a Linux kernel and kernel modules for an embedded target. Clearly, we must definitely *not* overwrite the host system's kernel modules with that of the embedded target's; that could be disastrous!

下一步是生成所谓的`initramfs`(或`initrd`)映像并设置引导加载程序。我们还需要清楚地了解这个`initramfs`形象到底是什么，以及使用它背后的动机。下一节之后的章节将深入探讨这些细节。

# 步骤 6–生成 initramfs 映像和引导加载程序设置

首先，请注意，此讨论高度偏向 x86[_64]架构。对于典型的 x86 桌面或服务器内核构建过程，此步骤在内部分为两个不同的部分:

*   生成`initramfs`(以前称为`initrd`)图像
*   新内核映像的引导加载程序设置

在这里的内核构建过程中，它被封装到单个步骤中的原因是，在 x86 体系结构上，便利脚本执行这两个任务，给出了单个步骤的外观。

Wondering what exactly this `initramfs` (or `initrd`) image file is? Please see the following *Understanding the initramfs framework* section for details. We'll get there soon.

现在，让我们继续生成 **initramfs** (简称**初始 ram 文件系统**)镜像文件，并更新引导加载程序。在 x86[_64] Ubuntu 上执行此操作只需一个简单的步骤:

```sh
$ sudo make install sh ./arch/x86/boot/install.sh 5.4.0-llkd01 arch/x86/boot/bzImage \
  System.map "/boot"
run-parts: executing /etc/kernel/postinst.d/apt-auto-removal 5.4.0-llkd01 /boot/vmlinuz-5.4.0-llkd01
run-parts: executing /etc/kernel/postinst.d/initramfs-tools 5.4.0-llkd01 /boot/vmlinuz-5.4.0-llkd01
update-initramfs: Generating /boot/initrd.img-5.4.0-llkd01
[...]
run-parts: executing /etc/kernel/postinst.d/zz-update-grub 5.4.0-llkd01 /boot/vmlinuz-5.4.0-llkd01
Sourcing file `/etc/default/grub'
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-5.4.0-llkd01
Found initrd image: /boot/initrd.img-5.4.0-llkd01
[...]
Found linux image: /boot/vmlinuz-5.0.0-36-generic
Found initrd image: /boot/initrd.img-5.0.0-36-generic
[...]
done
$
```

请注意，我们再次在`make install`命令前加上`sudo(8)`。很明显，这是因为我们需要*根*权限来写相关的文件和文件夹。

就这样，我们完成了:一个全新的 5.4 内核，以及所有请求的内核模块和`initramfs`映像已经生成，并且(GRUB)引导加载程序已经更新。剩下的就是重新启动系统，在启动时选择新的内核映像(从引导加载程序菜单屏幕)，启动，登录，并验证一切正常。

## 在 Fedora 30 及更高版本上生成 initramfs 映像

不幸的是，在 Fedora 30 和更高版本上，生成`initramfs`图像似乎不像前面部分中的 Ubuntu 那样容易。有些人建议通过`ARCH`环境变量明确指定架构。看一看:

```sh
$ sudo make ARCH=x86_64 install
sh ./arch/x86/boot/install.sh 5.4.0-llkd01 arch/x86/boot/bzImage \
System.map "/boot"
Cannot find LILO.
$
```

它失败了！想知道为什么吗？这里就不赘述了，不过这个链接应该能帮到你:[https://discussion . fedoraproject . org/t/installing-manual-build-kernel-in-system-with-grub 2/1895](https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895)。为了帮助纠正这种情况，以下是我在 Fedora 31 VM 上做的事情(是的，它成功了！):

1.  手动创建`initramfs`图像:

```sh
 sudo mkinitrd /boot/initramfs-5.4.0-llkd01.img 5.4.0-llkd01
```

2.  确保安装`grubby`包装:

```sh
sudo dnf install grubby-deprecated-8.40-36.fc31.x86_64
```

Pressing the *Tab* key twice after typing `grubby-` results in the full package name being auto-completed.

3.  (重新)运行`make install`命令:

```sh
$ sudo make ARCH=x86_64 install
 sh ./arch/x86/boot/install.sh 5.4.0-llkd01 arch/x86/boot/bzImage \
 System.map "/boot"
 grubby fatal error: unable to find a suitable template
 grubby fatal error: unable to find a suitable template
 grubby: doing this would leave no kernel entries. Not writing out new config.
 $
```

虽然`make install`命令似乎失败了，但它已经足够成功了。让我们来看看`/boot`目录的内容来验证这一点:

```sh
 $ ls -lht /boot
 total 204M
 -rw-------. 1 root root  44M Mar 26 13:08 initramfs-5.4.0-llkd01.img
 lrwxrwxrwx. 1 root root   29 Mar 26 13:07 System.map -> /boot/System.map-5.4.0-llkd01
 lrwxrwxrwx. 1 root root   26 Mar 26 13:07 vmlinuz -> /boot/vmlinuz-5.4.0-llkd01
 -rw-r--r--. 1 root root 4.1M Mar 26 13:07 System.map-5.4.0-llkd01
 -rw-r--r--. 1 root root 9.0M Mar 26 13:07 vmlinuz-5.4.0-llkd01
[...]
```

事实上，`initramfs`图像、`System.map`文件和`vmlinuz`(以及所需的符号链接)似乎已经设置好了！重新启动，从 GRUB 菜单中选择新内核，并验证它是否工作。

在这一步中，我们生成了`initramfs`图像。问题是，当我们这样做的时候， *kbuild* 系统在引擎盖下做了什么？请继续阅读了解详情。

## 生成 initramfs 映像–在引擎盖下

回想一下上一节中`sudo make install`命令执行时您将首先看到的内容(为方便起见，复制如下):

```sh
$ sudo make install sh ./arch/x86/boot/install.sh 5.4.0-llkd01 arch/x86/boot/bzImage \
 System.map "/boot"
```

很明显，这是一个正在执行的脚本。在内部，作为其工作的一部分，它将以下文件复制到`/boot`文件夹中，名称格式通常为`<filename>-$(uname -r)`:

```sh
System.map-5.4.0-llkd01, initrd.img-5.4.0-llkd01, vmlinuz-5.4.0-llkd01, config-5.4.0-llkd01
```

也建立了`initramfs`图像。一个名为`update-initramfs`的Shell脚本执行这个任务(它本身是另一个名为`mkinitramfs(8)`的脚本的便利包装器，该脚本执行实际工作)。构建完成后，`initramfs`图像也被复制到`/boot`目录中，如前面输出片段中的`initrd.img-5.4.0-llkd01`所示。

如果复制到`/boot`的文件已经存在，则备份为`<filename>-$(uname -r).old`。名为`vmlinuz-<kernel-ver>`的文件是`arch/x86/boot/bzImage`文件的副本。换句话说，它是压缩的内核映像——引导加载程序将被配置为加载到内存中、解压缩并跳转到其入口点的映像文件，从而将控制权移交给内核！

Why the names `vmlinux` (recall, this is the uncompressed kernel image file stored in the root of the kernel source tree) and `vmlinuz`? It's an old Unix convention that the Linux OS is quite happy to follow: on many Unix flavors, the kernel was called `vmunix`, so Linux calls it `vmlinux` and the compressed one `vmlinuz`; the `z` in `vmlinuz` is to hint at the (by default) `gzip(1)` compression.

此外，位于`/boot/grub/grub.cfg`的 GRUB 引导加载程序配置文件被更新，以反映一个新内核现在可用于引导的事实。

同样，值得强调的是，所有这些都是*非常特定于架构的*。前面的讨论是关于在 Ubuntu Linux x86[-64]系统上构建内核的。虽然概念上相似，但内核映像文件名的细节、它们的位置，尤其是引导加载程序，在不同的体系结构上有所不同。

如果你愿意的话，你可以跳到*定制 GRUB 引导加载程序*部分*。*如果你好奇(我希望如此)，请继续阅读。在下一节中，我们将更详细地描述`initramfs` */* `inird`框架的*如何*和*为什么*。

# 理解 initramfs 框架

仍然有一点神秘！*这个`initramfs`或者`initrd`形象到底是为了什么？为什么会在那里？*

首先，使用这个特性是一种选择——配置指令被称为`CONFIG_BLK_DEV_INITRD`。它打开，因此默认设置为`y`。简而言之，对于事先不知道某些事情的系统，例如引导磁盘主机适配器或控制器类型(SCSI、RAID 等)，根文件系统被格式化为的确切文件系统类型(是`ext2`、`ext3`、`ext4`、`btrfs`、`reiserfs`、`f2fs`还是另一个？)，或者对于那些总是将这些功能构建为内核模块的系统，我们需要`initramfs`功能。到底为什么会在一瞬间变得清晰。此外，如前所述，`initrd`现在被认为是一个更老的术语。如今，我们更多地使用术语`initramfs`来代替它。

## 为什么是 initramfs 框架？

`initramfs`框架本质上是一种介于早期内核引导和用户模式之间的中间人。它允许我们在挂载实际的根文件系统之前运行用户空间应用(或脚本)。这在许多情况下都很有用，下面的列表详细介绍了其中的一些情况。关键是`initramfs`允许我们运行内核在启动时无法正常运行的用户模式应用。

实际上，在各种用途中，这个框架允许我们做以下事情:

*   设置控制台字体。
*   自定义键盘布局设置。
*   在控制台设备上打印自定义欢迎消息。
*   接受密码(对于加密磁盘)。
*   根据需要加载内核模块。
*   如果出现故障，生成一个“救援”Shell。
*   还有更多！

想象一下，您正在构建和维护一个新的 Linux 发行版。现在，在安装时，您的发行版的最终用户可能会决定用`reiserfs`文件系统格式化他们的 SCSI 磁盘(仅供参考，这是内核中最早的通用日志文件系统)。问题是，您无法提前知道最终用户会做出什么样的选择，它可能是任何数量的文件系统之一。因此，您决定预构建并提供大量的内核模块，这些模块将满足几乎所有的可能性。好的，当安装完成并且用户的系统启动时，在这种情况下，内核将需要`reiserfs.ko`内核模块来成功安装根文件系统，从而继续系统启动。

![](Images/b48ca480-e208-45e4-b413-e7a0a09dcac5.png)

Figure 3.1 – The root filesystem's on the disk and yet to be mounted, kernel image is in RAM

但是等等，想想看，我们现在有一个经典的*先有鸡还是先有蛋的问题*:为了让内核挂载根文件系统，它需要`reiserfs.ko`内核模块文件加载到内存中(因为它包含能够使用文件系统的必要代码)。*但是*，该文件本身嵌入在`reiserfs`根文件系统中；准确地说，在`/lib/modules/<kernel-ver>/kernel/fs/reiserfs/`目录之内！(见图 3.1)。`initramfs`框架的主要目的之一就是解决这个先有鸡还是先有蛋的问题。

`initramfs`图像文件是压缩的`cpio`档案(`cpio`是`tar(1)`使用的平面文件格式)。正如我们在上一节看到的那样，`update-initramfs`脚本在内部调用`mkinitramfs`脚本(至少在 Ubuntu 上是这样的)。这些脚本构建了一个最小的根文件系统，包含内核模块以及支持基础设施，例如简单的`cpio`文件格式的`/etc`和`/lib`文件夹，然后通常进行 gzip 压缩。这就形成了所谓的`initramfs`(或`initrd`)图像文件，正如我们之前看到的，它将被放置在`/boot/initrd.img-<kernel-ver>`中。那有什么帮助呢？

在启动时，如果我们使用`initramfs`功能，作为其工作的一部分，引导加载程序将把`initramfs`图像文件加载到内存中。接下来，当内核本身在系统上运行时，它检测到一个`initramfs`映像的存在，解压缩它，并使用它的内容(通过脚本)，将所需的内核模块加载到内存中(图 3.2):

![](Images/98cb4ded-7d3d-452d-9fb8-f4ddc98309bf.png)

Figure 3.2 – The initramfs image serves as a middle-man between early kernel and actual root filesystem availability

关于引导过程(在 x86 上)和 initramfs 映像的更多细节可以在以下部分中找到。

## 了解 x86 上引导过程的基本知识

在以下列表中，我们简要概述了 x86[_64]台式机(或笔记本电脑)、工作站或服务器上的典型引导过程:

1.  提前启动、开机自检、BIOS 初始化——基本输入输出系统 *(* 简称**；本质上，x86 上的*固件*将第一个可引导磁盘的第一个扇区加载到内存中，并跳转到其入口点。这就形成了通常所说的*第一阶段*引导加载程序，其主要工作是将*第二阶段(更大)引导加载程序*代码加载到内存中并跳转到内存。**
***   现在，第二阶段引导加载程序代码开始控制。其主要工作是*将实际的(第三阶段)GRUB 引导加载程序*加载到内存中并跳转到其入口点(GRUB 通常是 x86[-64]系统上使用的引导加载程序)*   (GRUB)引导加载程序将被传递压缩的内核映像文件(`/boot/vmlinuz-<kernel-ver>`)以及压缩的`initramfs`映像文件(`/boot/initrd.img-<kernel-ver>`)作为参数。引导加载程序将(简单地)执行以下操作:**

 **4.  现在拥有机器控制权的 Linux 内核将初始化硬件和软件环境。它没有假设引导加载程序执行的早期工作。
5.  完成大部分硬件和软件初始化后，它会注意到`initramfs`功能已打开(`CONFIG_BLK_DEV_INITRD=y`)。因此，它将在内存中定位(如果需要，解压缩)T2(T3)图像(见图 3.2)。
6.  然后它将把它作为临时根文件系统安装在内存中，在`RAMdisk`内。
7.  我们现在在内存中建立了一个基本的、最小的根文件系统。因此，`initrd`启动脚本现在运行，执行将所需内核模块加载到内存中的任务(实际上，加载根文件系统驱动程序，在我们的场景中，包括`reiserfs.ko`内核模块；同样，参见图 3.2)。

8.  内核然后执行*枢轴根、* *卸载*`initrd`临时根文件系统，释放其内存，并*装载真正的根文件系统；*现在可以了，因为提供文件系统支持的内核模块确实可用。
9.  一旦(实际的)根文件系统成功装载，系统初始化就可以继续了。内核继续，最终调用第一个用户空间进程，通常是`/sbin/init` PID `1`。
10.  *SysV* *init* 框架现在开始初始化系统，按照配置启动系统服务。

A couple of things to note:
(a) On modern Linux systems, the traditional (read: old) SysV *init* framework has largely been replaced with a modern optimized framework called **systemd**. Thus, on many (if not most) modern Linux systems, including embedded ones, the traditional `/sbin/init` has been replaced with `systemd` (or is a symbolic link to its executable file). Find out more about *systemd* in the *Further reading* section at the end of this chapter.

(b) FYI, the generation of the root filesystem itself is not covered in this book; as one simple example, I suggest you look at the code of the SEALS project (at [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals)) that I mentioned in [Chapter 1](01.html), *Kernel Workspace Setup*; it has script that generates a very minimal, or "skeleton", root filesystem from scratch.

现在您已经理解了`initrd` / `initramfs`背后的动机，我们将在下一节通过对`initramfs`进行更深入的研究来完成这一节。一定要继续读下去！

## 关于 initramfs 框架的更多信息

框架帮助的另一个地方是调出磁盘加密的计算机*。在引导过程的早期，内核必须向用户查询密码，如果正确，就继续挂载磁盘，等等。但是，想想看:我们如何运行一个 C 程序可执行文件，也就是说，在没有 C 运行时环境的情况下请求一个密码——一个包含库、加载程序、所需内核模块(可能用于加密支持)等的根文件系统？*

 *记住，内核*本身*还没有完成初始化；用户空间应用如何运行？同样，`initramfs`框架通过在内存中建立一个包含库、加载器、内核模块等所需根文件系统的临时用户空间运行时环境来解决这个问题。

我们能核实一下吗？是的，我们可以！让我们来看一下`initramfs`图像文件。Ubuntu 上的`lsinitramfs(8)`脚本正好服务于这个目的(在 Fedora 上，相当于被称为`lsinitrd`):

```sh
$ lsinitramfs /boot/initrd.img-5.4.0-llkd01 | wc -l
334
$ lsinitramfs /boot/initrd.img-5.4.0-llkd01
.
kernel
kernel/x86
[...]
lib
lib/systemd
lib/systemd/network
lib/systemd/network/99-default.link
lib/systemd/systemd-udevd
[...]
lib/modules/5.4.0-llkd01/kernel/drivers/net/ethernet/intel/e1000/e1000.ko
lib/modules/5.4.0-llkd01/modules.dep
[...]
lib/x86_64-linux-gnu/libc-2.27.so
[...]
lib/x86_64-linux-gnu/libaudit.so.1
lib/x86_64-linux-gnu/ld-2.27.so
lib/x86_64-linux-gnu/libpthread.so.0
[...]
etc/udev/udev.conf
etc/fstab
etc/modprobe.d
[...]
bin/dmesg
bin/date
bin/udevadm
bin/reboot
[...]
sbin/fsck.ext4
sbin/dmsetup
sbin/blkid
sbin/modprobe
[...]
scripts/local-premount/resume
scripts/local-premount/ntfs_3g
$
```

这里面有相当多的内容:我们截断输出以显示一些精选片段。很明显，我们可以看到一个最小的*根文件系统，支持所需的运行时库、内核模块、`/etc`、`/bin`和`/sbin`目录以及它们的实用程序。*

*The details of constructing the `initramfs` (or `initrd`) image goes beyond what we wish to cover here. I suggest you peek into these scripts to reveal their inner workings (on Ubuntu): `/usr/sbin/update-initramfs`, a wrapper script over the `/usr/sbin/mkinitramfs` shell script. Do see the *Further reading* section for more.

此外，现代系统的特点是有时被称为混合的`initramfs`:一个`initramfs`图像，它由一个附加在常规或主`ramfs`图像前面的早期`ramfs`图像组成。现实是，我们需要特殊的工具来解压/打包(解压缩/压缩)这些图像。Ubuntu 分别提供了`unmkinitramfs(8)`和`mkinitramfs(8)`脚本来执行这些操作。

作为一个快速的实验，让我们将全新的`initramfs`图像(上一节生成的图像)解压到一个临时目录中。同样，这已经在我们的 Ubuntu 18.04 LTS 来宾虚拟机上执行过了。使用`tree(1)`查看其截断的输出以提高可读性:

```sh
$ TMPDIR=$(mktemp -d)
$ unmkinitramfs /boot/initrd.img-5.4.0-llkd01 ${TMPDIR}
$ tree ${TMPDIR} | less
/tmp/tmp.T53zY3gR91
├── early
│   └── kernel
│       └── x86
│           └── microcode
│               └── AuthenticAMD.bin
└── main
    ├── bin
    │   ├── [
    │   ├── [[
    │   ├── acpid
    │   ├── ash
    │   ├── awk
[...]
  ├── etc
    │   ├── console-setup
    │   │   ├── cached_UTF-8_del.kmap.gz
[...]
   ├── init
   ├── lib
[...]
    │   ├── modules
    │   │   └── 5.4.0-llkd01
    │   │   ├── kernel
    │   │   │   └── drivers
[...]
    ├── scripts
    │   ├── functions
    │   ├── init-bottom
[...]
    └── var
        └── lib
            └── dhcp
$ 
```

我们的(相当长的！)讨论`initramfs`框架和 x86 上引导过程的基础。好消息是，现在有了这些知识，你可以根据需要通过调整`initramfs`图像来进一步定制你的产品——这是一项重要的技能！

作为一个例子(如前所述)，由于*安全性*是现代系统的一个关键因素，能够在块级别加密磁盘是一个强大的安全功能；这样做非常需要调整`initramfs`图像。(同样，由于这超出了本书的范围，请参考本章末尾的*进一步阅读*部分，以获得关于此方面和其他方面的文章的有用链接。)

现在，让我们通过对(x86) GRUB 引导加载程序的引导脚本进行一些简单的定制来完成内核构建。

# 步骤 7–定制 GRUB 引导加载程序

我们现在已经完成了第 1 步到第 6 步*，如第 2 章、*从源代码构建 5.x Linux 内核–第 1 部分*、从源代码构建 *内核的*步骤*部分所述。我们可以重启系统；当然，一定要先关闭你所有的应用和文件。然而，默认情况下，现代的**GRUB**(**GRand Unified****boot loader**)boot loader 甚至不会在重启时向我们显示任何菜单；默认情况下，它将引导到新构建的内核中(请记住，在这里，我们只针对运行 Ubuntu 的 x86[_64]系统描述了这个过程*)。***

**On x86[_64] you can always get to the GRUB menu during early system boot. Just ensure you keep the *Shift* key pressed down during boot.

如果我们希望在每次引导系统时都能看到并自定义 GRUB 菜单，从而允许我们选择一个备用的内核/操作系统进行引导，会怎么样？这在开发过程中通常非常有用，所以让我们来看看如何做到这一点。

## 定制 GRUB–基础

定制 GRUB 非常容易。请注意以下几点:

*   以下步骤将在“目标”系统本身上执行(不在主机上)；在我们的例子中，是 Ubuntu 18.04 来宾 VM。
*   这已经在我们的 Ubuntu 18.04 LTS 来宾系统上进行了测试和验证。

以下是我们定制的一系列快速步骤:

1.  为了安全起见，我们保留一份 GRUB 引导加载程序配置文件的备份:

```sh
sudo cp /etc/default/grub /etc/default/grub.orig

```

The `/etc/default/grub` file is the user-configuration file in question. Before editing it, we make a backup to be safe. This is always a good idea.

2.  编辑一下。您可以使用`vi(1)`或您选择的编辑器:

```sh
sudo vi /etc/default/grub 
```

3.  要在引导时始终显示 GRUB 提示，请插入以下行:

```sh
GRUB_HIDDEN_TIMEOUT_QUIET=false
```

On some Linux distros, you might instead have the `GRUB_TIMEOUT_STYLE=hidden` directive; simply change it to `GRUB_TIMEOUT_STYLE=menu` to achieve the same effect.

4.  根据需要设置启动默认操作系统的超时时间(秒)；默认为`10`秒；请参见以下示例:

```sh
GRUB_TIMEOUT=3
```

将前面的超时值设置为以下值将产生以下结果:

*   `0`:立即开机，不显示菜单。
*   `-1`:无限期等待。

此外，如果存在`GRUB_HIDDEN_TIMEOUT`指令，只需指出:

```sh
#GRUB_HIDDEN_TIMEOUT=1
```

5.  最后，以*根*的身份运行`update-grub(8)`程序，使您的更改生效:

```sh
sudo update-grub
```

前面的命令通常会导致`initramfs`图像被刷新(重新生成)。完成后，您就可以重新启动系统了。不过，等一下！下一节将向您展示如何修改 GRUB 的配置，使其默认引导到您选择的内核中。

## 选择要启动的默认内核

GRUB 默认内核被预设为数字零(通过`GRUB_DEFAULT=0`指令)。这将确保“第一个内核”——最近添加的内核——默认启动(超时时)。这可能不是我们想要的；作为一个真实的例子，在我们的 Ubuntu 18.04.3 LTS 来宾 VM 上，我们将它设置为默认的 Ubuntu *发行版内核*，就像前面一样，编辑`/etc/default/grub`文件(当然是作为根文件)如下:

```sh
GRUB_DEFAULT="Advanced options for Ubuntu>Ubuntu, with Linux 5.0.0-36-generic"
```

Of course, this implies that if your distro is updated or upgraded, you must again manually change the preceding line to reflect the new distro kernel that you wish to boot into by default, and then run `sudo update-grub`.

对，我们新编辑的 GRUB 配置文件如下所示:

```sh
$ cat /etc/default/grub
[...]
#GRUB_DEFAULT=0
GRUB_DEFAULT="Advanced options for Ubuntu>Ubuntu, with Linux 5.0.0-36-generic"
#GRUB_TIMEOUT_STYLE=hidden
GRUB_HIDDEN_TIMEOUT_QUIET=false
GRUB_TIMEOUT=3
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""
[...] 
```

与上一节一样，不要忘记:如果您在此处进行了任何更改，请运行`sudo update-grub`命令以使您的更改生效。

Additional points to note:
a) In addition, you can add "pretty" tweaks, such as changing the background image (or color) via the `BACKGROUND_IMAGE="<img_file>"` directive.
b) On Fedora, the GRUB bootloader config file is a bit different; run this command to show the GRUB menu at every boot:
`sudo grub2-editenv - unset menu_auto_hide` The details can be found in the *Fedora wiki: Changes/HiddenGrubMenu*: [https://fedoraproject.org/wiki/Changes/HiddenGrubMenu](https://fedoraproject.org/wiki/Changes/HiddenGrubMenu).
c) Unfortunately, GRUB2 (the latest version is now 2) seems to be implemented differently on pretty much every Linux distro, leading to incompatibilities when trying to tune it in one given manner.

现在让我们重新启动来宾系统，进入 GRUB 菜单，并启动我们的新内核。

全部完成！让我们(终于！)重新启动系统:

```sh
$ sudo reboot
[sudo] password for llkd: 
```

一旦系统完成关机过程并重新启动，您应该很快就会看到 GRUB 引导加载程序菜单(下面的部分也显示了几个截图)。一定要按键盘上的任何一个键来打断它！

Though always possible, I recommend you don't delete the original distro kernel image(s) (and associated `initrd`, `System.map` files, and so on). What if your brand-new kernel fails to boot? (*If it can happen to the Titanic...*) By keeping our original images, we thus have a fallback option: boot from the original distro kernel, fix our issue(s), and retry.

As a worst-case scenario, what if all other kernels/`initrd` images have been deleted and your single new kernel fails to boot successfully? Well, you can always boot into a *recovery mode* Linux via a USB pen drive; a bit of googling regarding this will yield many links and video tutorials.

## 通过 GNU GRUB 引导加载程序引导我们的虚拟机

现在，我们的来宾虚拟机(使用 *Oracle VirtualBox 虚拟机管理程序*)即将上线；一旦它的(模拟的)BIOS 例程完成，GNU GRUB 引导加载程序屏幕首先出现。这是因为我们有意将`GRUB_HIDDEN_TIMEOUT_QUIET` GRUB 配置指令更改为`false`的值。请参见下面的截图(图 3.3)。截图中看到的特殊样式是 Ubuntu 发行版如何定制的:

![](Images/9a8b91db-e737-4c3b-a497-41138280e0a4.png)

Figure 3.3 – The GRUB2 bootloader – paused on system startup

现在让我们直接启动我们的虚拟机:

1.  按任意键盘键(除了*回车)*确保一旦超时(回想一下，我们设置为 3 秒)到期，默认内核不会启动。
2.  如果还没有，滚动到`Advanced options for Ubuntu`菜单，高亮显示，按*回车。*
3.  现在，您将看到一个菜单，与下面的截图相似，但可能不完全相同(图 3.4)。对于 GRUB 检测到并可以引导到的每个内核，显示了两行——一行用于内核本身，一行用于同一内核的特殊恢复模式引导选项:

![](Images/b4d2a648-4e20-4ca2-ae63-a8e2caa71bc8.png)

Figure 3.4 – The GRUB2 bootloader showing available kernels to boot from

请注意，默认情况下将启动的内核(在我们的例子中是`5.0.0-36-generic`内核)在默认情况下是用星号(`*`)突出显示的。

The preceding screenshot shows a few "extra" line items. This is because, at the time of taking this screenshot, I had updated the VM and hence a few newer kernels were installed as well. We can spot the `5.0.0-37-generic` and `5.3.0-26-generic` kernels. No matter; we ignore them here.

4.  不管是哪种情况，只需滚动到感兴趣的条目，即`5.4.0-llkd01`内核条目。这里，它是 GRUB 菜单的第一行(因为它是可引导操作系统 GRUB 菜单的最新添加):`Ubuntu, with Linux 5.4.0-llkd01`。
5.  突出显示上述菜单项后，按*进入*，瞧！引导加载器将继续工作，将内核镜像和`initrd`镜像解压缩加载到 RAM 中，并跳转到 Linux 内核的入口点，从而将控制权移交给 Linux！

没错，如果一切顺利，你将会启动全新的 5.4.0 Linux 内核！祝贺你出色地完成了任务。同样，您总是可以做得更多——下面的部分向您展示了如何在运行时(引导时)进一步编辑和定制 GRUB 的配置。同样，这个技能时不时会派上用场——比如*忘记了根密码？*确实可以，其实你可以用这个手法*绕过它*！请继续阅读，了解具体方法。

## 尝试 GRUB 提示符

你可以做进一步的实验；在`Ubuntu, with Linux 5.4.0-llkd01`内核的菜单条目中，不要仅仅按下*进入*，确保这一行高亮显示并按下`e`键(用于编辑)。我们现在将进入 GRUB 的*编辑屏幕*，在这里我们可以自由更改任何我们喜欢的值。下面是按下 *e* 键后的截图:

![](Images/1dc4a4b5-e6bb-4a2e-9ba8-e17968a7436b.png)

Figure 3.5 – The GRUB2 bootloader – detail on the custom 5.4.0-llkd01 kernel

截图是向下滚动几行后拍摄的；仔细看，您可以在编辑框底部第三行的开头找到光标(类似下划线的“ **`_`** ”)。这是至关重要的线；它以适当缩进的关键字`linux`开始。它指定了通过 GRUB 引导加载程序传递给 Linux 内核的*内核参数列表*。

试着在这里尝试一下。举个简单的例子，从这个条目中删除单词`quiet`和`splash`，然后按 *Ctrl* + *X* 或 *F10* 开机。这次，漂亮的 Ubuntu 闪屏没有出现；当所有内核消息闪过时，您直接在控制台中看到它们。

一个常见的问题:如果我们忘记了密码，因此无法登录，该怎么办？有几种方法可以解决这个问题。一种是通过 bootloader:像我们之前做的那样引导到 GRUB 菜单，进入相关的菜单项，按 *e* 编辑，向下滚动到以`linux`开头的行，在这个条目的末尾追加`single`这个词(或者只是数字`1`，这样看起来是这样的:

```sh
               linux       /boot/vmlinuz-5.0.0-36-generic \ root=UUID=<...> ro quiet splash single
```

现在，当你启动时，内核启动到单用户模式，并给你，永远感激的用户，*一个带根访问的Shell*。只需运行`passwd <username>`命令即可更改您的密码。

The precise procedure to boot into single-user mode varies with the distro. Exactly what to edit in the GRUB2 menu is a bit different on Red Hat/Fedora/CentOS. See the *Further reading* section for a link on how to set it for these systems.

这教会了我们一些关于*安全*的东西，不是吗？当在没有密码的情况下可以访问引导加载程序菜单(甚至是 BIOS)时，系统被认为是不安全的！事实上，在高度安全的环境中，即使是对控制台设备的物理访问也必须受到限制。

现在，您已经学会了如何定制 GRUB 引导加载程序，并且，我期望，已经引导到您的新鲜的 5.4 Linux 内核！我们不要只是假设；让我们验证内核确实按照我们的计划进行了配置。

# 验证我们新内核的配置

好了，回到我们的讨论:我们现在已经启动了新构建的内核。但是坚持住，让我们不要盲目地假设事情，让我们实际验证一切已经按照计划进行。*经验方法*总是最好的:

```sh
$ uname -r
5.4.0-llkd01
```

事实上，我们现在正在我们刚刚构建的 **5.4.0** Linux 内核上运行 Ubuntu 18.04.3 LTS！

回想一下我们要编辑的内核配置表，来自[第 2 章](02.html)、*从源代码构建 5.x Linux 内核–第 1 部分*，在*表 2.4* 中。我们应该逐行检查我们更改的每个配置是否已经生效。让我们列出其中一些，从相关的`CONFIG_'FOO'`名称开始，如下所示:

*   `CONFIG_LOCALVERSION`:`uname -r`前面的输出清晰地显示了内核版本的`localversion`(或`-EXTRAVERSION`)部分已经被设置为我们想要的:`-llkd01`字符串。
*   `CONFIG_IKCONFIG`:让我们可以看到当前的内核配置细节。让我们检查一下。回想一下，您要将`LLKD_KSRC`环境变量设置到您的 5.4 内核源代码树目录的根位置:

```sh
$ ${LLKD_KSRC}/scripts/extract-ikconfig /boot/vmlinuz-5.4.0-llkd01
#
# Automatically generated file; DO NOT EDIT.
# Linux/x86 5.4.0 Kernel Configuration
[...]
CONFIG_IRQ_WORK=y
[...]
```

有效！我们可以通过`scripts/extract-ikconfig`脚本看到整个内核配置。我们将使用这个脚本来`grep(1)`我们在前面提到的*表 2.4* 中更改的配置指令的剩余部分:

```sh
$ scripts/extract-ikconfig /boot/vmlinuz-5.4.0-llkd01 | egrep "IKCONFIG|HAMRADIO|PROFILING|VBOXGUEST|UIO|MSDOS_FS|SECURITY|DEBUG_STACK_USAGE"
CONFIG_IKCONFIG=y
CONFIG_IKCONFIG_PROC=y
# CONFIG_PROFILING is not set
# CONFIG_HAMRADIO is not set
CONFIG_UIO=m
# CONFIG_UIO_CIF is not set
CONFIG_UIO_PDRV_GENIRQ=m
# CONFIG_UIO_DMEM_GENIRQ is not set
[...]
CONFIG_VBOXGUEST=m
CONFIG_EXT4_FS_SECURITY=y
CONFIG_MSDOS_FS=m
# CONFIG_SECURITY_DMESG_RESTRICT is not set
# CONFIG_SECURITY is not set
CONFIG_SECURITYFS=y
CONFIG_DEFAULT_SECURITY_DAC=y
CONFIG_DEBUG_STACK_USAGE=y
$ 
```

仔细查看前面的输出，我们可以看到我们得到了我们想要的东西。我们新内核的配置设置与[第 2 章](02.html)、*从源代码构建 5.x Linux 内核–第 1 部分*、*表 2.4* 中预期的设置完全匹配；太好了。

或者，由于我们启用了`CONFIG_IKCONFIG_PROC`选项，我们可以通过(压缩的)`proc`文件系统条目`/proc/config.gz`查找内核配置来实现相同的验证，如下所示:

```sh
gunzip -c /proc/config.gz | egrep \ "IKCONFIG|HAMRADIO|PROFILING|VBOXGUEST|UIO|MSDOS_FS|SECURITY|DEBUG_STACK_USAGE"
```

所以，内核构建完成了！太棒了。我敦促您参考第 2 章、*从源代码构建 5.x Linux 内核–第 1 部分*，在*从源代码构建内核的步骤*部分*、*再次查看整个过程的步骤的高级概述。我们用一个有趣的树莓 Pi 设备内核的*交叉编译*和一些剩余的提示来结束这一章。

# 树莓皮的内核构建

基于 ARM 的树莓 Pi 是一款受欢迎且相对便宜的**单板计算机** ( **SBC** )进行实验和原型制作。业余爱好者和修补者发现尝试和学习如何使用嵌入式 Linux 非常有用，尤其是因为它有强大的社区支持(有许多 T4 论坛)和良好的支持:

![](Images/f2a2d45c-8cb6-47c9-a4c7-d6a1cca4f57c.png)

Figure 3.6 – A Raspberry Pi 3 Model B+ device (note that the USB-to-serial cable seen in the photo does not come with it)

有两种方法可以为目标设备构建内核:

*   在功能强大的主机系统上构建内核，通常是运行 Linux 发行版的英特尔/AMD x86_64(或 Mac)台式机或笔记本电脑。
*   在目标设备本身上执行构建。

我们将遵循第一种方法——它要快得多，并且被认为是执行嵌入式 Linux 开发的正确方法。

我们将假设(像往常一样)我们正在运行我们的 Ubuntu 18.04 LTS 客户虚拟机。所以，好好想想；现在，主机系统实际上是来宾 Linux VM！此外，我们的目标是为 ARM 32 位架构构建内核，而不是 64 位。

Performing large downloads and kernel build operations on a guest VM isn't really ideal. Depending on the power and RAM of the host and guest, it will take a while. It could end up being twice as slow as building on a native Linux box. Nevertheless, assuming you have set aside sufficient disk space in the guest (and of course the host actually has this space available), this procedure works.

我们将不得不使用 *x86_64 到 ARM (32 位)交叉编译器*为树莓 Pi 目标构建内核或任何组件。这意味着安装一个合适的**交叉工具链**来执行构建。

在接下来的几节中，我们将工作分为三个独立的步骤:

1.  为我们自己获取一个适合设备的内核源代码树
2.  学习如何安装合适的交叉工具链
3.  配置和构建内核

让我们开始吧！

## 步骤 1–克隆内核源树

我们为内核源代码树和跨工具链任意选择一个*暂存文件夹*(构建发生的地方)，并将其分配给一个环境变量(以免硬编码):

1.  设置您的工作区。我们将一个环境变量设置为`RPI_STG`(不要求环境变量使用完全相同的名称；只需选择一个听起来合理的名字并坚持使用)到暂存文件夹的位置——我们将执行工作的地方。请随意使用适合您系统的值:

```sh
export RPI_STG=~/rpi_work
mkdir -p ${RPI_STG}/kernel_rpi ${RPI_STG}/rpi_tools
```

Do ensure you have sufficient disk space available: the kernel source tree takes approximately 900 MB, and the toolchain around 1.5 GB. You'll require at least another gigabyte for working space.

2.  下载树莓皮内核源码树(我们从官方源码，树莓皮内核树 GitHub 资源库克隆而来，这里:[https://github.com/raspberrypi/linux/](https://github.com/raspberrypi/linux/)):

```sh
cd ${RPI_STG}/kernel_rpi
git clone --depth=1 --branch rpi-5.4.y https://github.com/raspberrypi/linux.git
```

内核源树被克隆到名为`linux/`的目录下(即`${RPI_WORK}/kernel_rpi/linux`下)。请注意，在前面的代码中，我们有以下内容:

*   我们选择的特定树莓皮内核树分支是*而不是*最新的一个(在撰写本文时，最新的是 5.11 系列)，它是 5.4 内核；这完全没问题(这是一个 LTS 内核，也匹配我们的 x86 内核！).
*   我们将设置为`1`的`--depth`参数传递给`git clone`，以减少下载和解压缩负载。

现在安装了树莓 Pi 内核源码。让我们简单验证一下:

```sh
$ cd ${RPI_STG}/kernel_rpi/linux ; head -n5 Makefile
# SPDX-License-Identifier: GPL-2.0
VERSION = 5
PATCHLEVEL = 4
SUBLEVEL = 51
EXTRAVERSION =
```

好了，是 5.4.51 树莓 Pi 内核端口(我们在 x86_64 上使用的内核版本是 5.4.0 版本；轻微的变化是可以的)。

## 步骤 2–安装交叉工具链

现在是时候在您的主机系统上安装一个*跨工具链*了，它适合执行实际的构建。问题是，有几个可用的工作工具链...在这里，我将展示获取和安装工具链的两种方法。第一种方法最简单，通常也足够了，而第二种方法安装了更复杂的版本。

### 第一种方法-通过 apt 打包安装

这真的很简单，效果很好；一定要经常使用这种方法:

```sh
sudo apt install ​crossbuild-essential-armhf
```

工具通常安装在`/usr/bin/`下，因此已经是`PATH`的一部分；你可以简单地使用它们。例如，查看 ARM-32 `gcc`编译器的位置和版本如下:

```sh
$ which arm-linux-gnueabihf-gcc
/usr/bin/arm-linux-gnueabihf-gcc
$ arm-linux-gnueabihf-gcc --version |head -n1
arm-linux-gnueabihf-gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
```

另外，一定要记住:这个工具链适合于为 ARM 32 位架构构建内核，而不是 64 位架构。如果这是你的意图(为 64 位构建，我们在这里不涉及)，你将需要安装一个带有`sudo apt install ​crossbuild-essential-arm64`的 x86_64 到 ARM64 工具链。

### 第二种方法——通过源回购进行安装

这是一种更精细的方法。在这里，我们从树莓皮的 GitHub 报告中克隆工具链:

1.  下载工具链。让我们把它放在树莓皮暂存目录中名为`rpi_tools`的文件夹下:

```sh
cd ${RPI_STG}/rpi_tools
git clone https://github.com/raspberrypi/tools
```

2.  更新`PATH`环境变量，使其包含工具链二进制文件:

```sh
export PATH=${PATH}:${RPI_STG}/rpi_tools/tools/arm-bcm2708/arm-linux-gnueabihf/bin/

```

Setting the `PATH` environment variable (as shown in the preceding code) is required. However, it's only valid for the current shell session. Make it permanent by putting the preceding line into a startup script (typically your `${HOME}/.bashrc` file or equivalent).

如前所述，也可以使用替代工具链。例如，在 ARM 开发者网站[https://developer . ARM . com/tools-and-software/open-source-software/developer-tools/GNU-tool chain/GNU-A/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads)上可以找到几个用于 ARM 开发的工具链(用于 A-profile 处理器)。

## 步骤 3–配置和构建内核

让我们配置内核(针对树莓 Pi 2、Pi 3 和 Pi 3[B]+)。在我们开始之前，记住以下几点非常重要:

*   **`ARCH`** 环境变量设置为软件交叉编译的 CPU(架构)(即编译后的代码将在该 CPU 上运行)。将`ARCH`设置为的值是内核源代码树中`arch/`目录下的目录名。例如，将 ARM32 的`ARCH`设置为`arm`，ARM64 的`arm64`，PowerPC 的`powerpc`，OpenRISC 处理器的`openrisc`。
*   **`CROSS_COMPILE`** 环境变量设置为交叉编译器(toolchain)前缀。本质上，它是工具链中每个实用程序前面的前几个常见字母。在我们下面的例子中，所有的工具链实用程序(C 编译器`gcc`、链接器、C++、`objdump`等等)都以`arm-linux-gnueabihf-`开头，所以这就是我们设置的`CROSS_COMPILE`。`Makefile`将始终调用实用程序作为`${CROSS_COMPILE}<utility>`，因此调用正确的工具链可执行文件。这确实意味着 toolchain 目录应该在`PATH`变量中(正如我们在前面部分提到的)。

好，让我们构建内核:

```sh
cd ${RPI_STG}/kernel_rpi/linux
make mrproper
KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig
```

关于配置目标的快速解释，`bcm2709_defconfig`:这个要点在[第二章](02.html)*从源代码构建 5.x Linux 内核–第 1 部分*中提到过。我们必须确保使用一个合适的特定于主板的内核配置文件作为起点。这里，这是树莓 Pi 2、Pi 3、Pi 3+和计算模块 3 设备上 Broadcom SoC 的正确内核配置文件。指定的`bcm2709_defconfig`配置目标导致解析`arch/arm/configs/bcm2709_defconfig`文件的内容。(树莓 Pi 网站将此记录为树莓 Pi 2、Pi 3、Pi 3+和计算模块 3 默认构建配置的`bcm2709_defconfig`。重要提示:如果您正在为另一种类型的树莓 Pi 设备构建内核，请参见[https://www . raspberrypi . org/documentation/Linux/kernel/building . MD](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。)

仅供参考，`kernel7`值如此，是因为处理器基于 ARMv7(实际上，从树莓 Pi 3 开始，SoC 是 64 位 ARMv8，兼容在 32 位 ARMv7 模式下运行；这里，当我们为 ARM32 (AArch32)构建 32 位内核时，我们指定`KERNEL=kernel7`。

The variety of SoCs, their packaging, and their resulting naming creates a good deal of confusion; this link might help: [https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835](https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835).

如果需要对内核配置进行任何进一步的定制，您可以使用以下内容:

```sh
make ARCH=arm menuconfig
```

如果没有，跳过这一步继续。使用以下内容构建(交叉编译)内核、内核模块和 DTB:

```sh
make -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs
```

(根据您的构建主机适当调整`-jn`)。一旦构建成功完成，我们可以看到已经生成了以下文件:

```sh
$ ls -lh vmlinux System.map arch/arm/boot/zImage
-rwxrwxr-x 1 llkd llkd  5.3M Jul 23 12:58 arch/arm/boot/zImage
-rw-rw-r-- 1 llkd llkd  2.5M Jul 23 12:58 System.map
-rwxrwxr-x 1 llkd llkd   16M Jul 23 12:58 vmlinux
$ 
```

在这里，我们的目的只是展示一个 Linux 内核如何被配置和构建为一个架构，而不是编译它的主机系统，或者换句话说，交叉编译。关于将内核映像(和 DTB 文件)放在 microSD 卡上的血淋淋的细节就不再赘述了。我建议您参考树莓皮内核构建的完整文档，可以在这里找到:[https://www . raspberrypi . org/documents/Linux/kernel/building . MD](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。

然而，这里有一个在树莓皮 3[B+]上尝试你的新内核的快速提示:

1.  安装 microSD 卡。它通常会有一个 Raspbian 发行版和两个分区`boot`和`rootfs`，分别对应于`mmcblk0p1`和`mmcblk0p2`分区。

2.  **引导加载程序和相关二进制文件**:关键是要把低级启动二进制文件，包括引导加载程序本身，放到 SD 卡的引导分区上；这包括`bootcode.bin`(实际的引导加载程序)、`fixup*.dat`和`start*.elf`二进制文件；`/boot`文件夹的内容解释如下:[https://www . raspberrypi . org/documentation/configuration/boot _ folder . MD](https://www.raspberrypi.org/documentation/configuration/boot_folder.md)。(如果你不确定如何获得这些二进制文件，简单地在 SD 卡上安装一个树莓 Pi OS 的股票版本可能是最简单的；这些二进制文件将被安装在其引导分区中。股票树莓 Pi OS 图片可从[https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads/)获得；此外，仅供参考，更新的树莓皮成像仪应用(适用于 Windows、macOS、Linux)使首次安装变得非常容易。
3.  如果存在的话，备份然后用我们刚刚建立的`zImage`文件替换 microSD 卡上`/boot`分区内的`kernel7.img`文件，命名为`kernel7.img`。

4.  安装刚刚构建的内核模块；确保您使用`INSTALL_MOD_PATH`环境变量将该位置指定为 microSD 卡的根文件系统！(做不到这一点意味着它可能会覆盖您主机的模块，这将是灾难性的！)在这里，我们假设 microSD 卡的第二个分区(包含根文件系统)安装在`/media/${USER}/rootfs`下；然后，执行以下操作(全部在一行中):

```sh
sudo env PATH=$PATH make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-  INSTALL_MOD_PATH=/media/${USER}/rootfs modules_install
```

5.  安装我们刚刚在 SD 卡上生成的数字地面广播(和覆盖图):

```sh
sudo cp arch/arm/boot/dts/*.dtb /media/${USER}/boot
sudo cp arch/arm/boot/dts/overlays/*.dtb* arch/arm/boot/dts/overlays/README /media/${USER}/boot/overlays
sync 
```

6.  卸下 SD 卡，重新插入设备，然后试用。

Again, to ensure it works, please refer to the official documentation (available at [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)). We have not covered the details regarding the generation and copying of kernel modules and DTBs to the microSD card.

Also, FYI, we again discuss kernel configuration and build for the Raspberry Pi in [Chapter 11](11.html), *The CPU Scheduler – Part 2*.

这就完成了我们对树莓皮的内核交叉编译实验的简短介绍。我们将用一些杂七杂八但仍然有用的提示来结束这一章。

# 内核构建的其他技巧

我们用一些技巧完成了从源代码构建 Linux 内核的这一章。以下每个小节都概括了一个提示，供您注意。

对于不熟悉这一点的人来说，这通常是一个困惑点:一旦我们配置、构建并从一个新的 Linux 内核启动，我们注意到根文件系统和任何其他装载的文件系统仍然与原始(发行版或定制)系统上的相同。只有内核本身发生了变化。这完全是有意的，因为 Unix 的范例是在内核和根文件系统之间有一个松散的耦合。因为它是保存所有应用、系统工具和实用程序(包括库)的根文件系统，所以实际上，我们可以有几个内核，以适应同一基础系统的不同产品风格。

## 最低版本要求

为了成功构建内核，您必须确保您的构建系统拥有工具链(以及其他各种工具和实用程序)的各种软件的文档化*最低*版本。这些信息显然包含在*编译内核的最低要求*部分的内核文档中，可在[T5](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)[https://github . com/Torvalds/Linux/blob/master/Documentation/process/changes . rst #编译内核的最低要求](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)中找到。

比如截止到撰写本文时，`gcc`的推荐最低版本为 4.9，`make`的推荐最低版本为 3.81。

## 为另一个站点构建内核

在本书的内核构建演练中，我们在某个系统上构建了一个 Linux 内核(在这里，它是一个 x86_64 客户机)，并从同一个系统启动了新构建的内核。如果情况不是这样呢，就像在为另一个站点或客户场所构建内核时经常发生的那样？虽然总是可以在远程系统上手动将各个部分放置到位，但有一种更简单、更正确的方法——将内核和与之捆绑的相关元工作(即`initrd`映像、内核模块集合、内核头等)构建成众所周知的**包格式** (Debian 的`deb`、Red Hat 的`rpm`等等)！内核顶层`Makefile`上的快速`help`命令揭示了这些包目标:

```sh
$ make help
[ ... ]
Kernel packaging:
 rpm-pkg - Build both source and binary RPM kernel packages
 binrpm-pkg - Build only the binary kernel RPM package
 deb-pkg - Build both source and binary deb kernel packages
 bindeb-pkg - Build only the binary kernel deb package
 snap-pkg - Build only the binary kernel snap package (will connect to external hosts)
 tar-pkg - Build the kernel as an uncompressed tarball
 targz-pkg - Build the kernel as a gzip compressed tarball
 tarbz2-pkg - Build the kernel as a bzip2 compressed tarball
 tarxz-pkg - Build the kernel as a xz compressed tarball
[ ... ]
```

例如，要将内核及其相关文件构建为 Debian 包，只需执行以下操作:

```sh
$ make -j8 bindeb-pkg
scripts/kconfig/conf --syncconfig Kconfig
sh ./scripts/package/mkdebian
dpkg-buildpackage -r"fakeroot -u" -a$(cat debian/arch) -b -nc -uc
dpkg-buildpackage: info: source package linux-5.4.0-min1
dpkg-buildpackage: info: source version 5.4.0-min1-1
dpkg-buildpackage: info: source distribution bionic
[ ... ]
```

实际的包被写入内核源目录正上方的目录。例如，从我们刚刚运行的命令中，以下是生成的`deb`包:

```sh
$ ls -l ../*.deb
-rw-r--r-- 1 kaiwan kaiwan 11106860 Feb 19 17:05 ../linux-headers-5.4.0-min1_5.4.0-min1-1_amd64.deb
-rw-r--r-- 1 kaiwan kaiwan 8206880 Feb 19 17:05 ../linux-image-5.4.0-min1_5.4.0-min1-1_amd64.deb
-rw-r--r-- 1 kaiwan kaiwan 1066996 Feb 19 17:05 ../linux-libc-dev_5.4.0-min1-1_amd64.deb
```

这确实很方便！现在，你可以用一个简单的`dpkg -i <package-name>`命令在任何其他匹配的(就 CPU 和 Linux 风格而言)系统上安装软件包。

## 观看内核构建运行

要在内核构建运行时查看详细信息(编译器标志等)，请将 **`V=1`** 详细选项切换到`make(1)`。以下是构建树莓 Pi 3 内核时的一点示例输出，详细开关设置为上的*:* 

```sh
$ make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs
[...]
make -f ./scripts/Makefile.build obj=kernel/sched
arm-linux-gnueabihf-gcc -Wp,-MD,kernel/sched/.core.o.d 
 -nostdinc 
 -isystem <...>/gcc-linaro-7.3.1-2018.05-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/7.3.1/include 
 -I./arch/arm/include -I./arch/arm/include/generated/uapi 
 -I./arch/arm/include/generated -I./include 
 -I./arch/arm/include/uapi -I./include/uapi 
 -I./include/generated/uapi -include ./include/linux/kconfig.h 
 -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes 
 -Wno-trigraphs -fno-strict-aliasing -fno-common 
 -Werror-implicit-function-declaration -Wno-format-security 
 -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-omit-frame-pointer 
 -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux 
 -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm 
 -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm 
 -fno-delete-null-pointer-checks -Wno-frame-address 
 -Wno-format-truncation -Wno-format-overflow 
 -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 
 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector 
 -Wno-unused-but-set-variable -Wno-unused-const-variable 
 -fno-omit-frame-pointer -fno-optimize-sibling-calls 
 -fno-var-tracking-assignments -pg -Wdeclaration-after-statement 
 -Wno-pointer-sign -fno-strict-overflow -fno-stack-check 
 -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes 
 -Werror=date-time -Werror=incompatible-pointer-types 
 -fno-omit-frame-pointer -DKBUILD_BASENAME='"core"' 
 -DKBUILD_MODNAME='"core"' -c -o kernel/sched/.tmp_core.o  
 kernel/sched/core.c
[...]
```

请注意，我们通过插入新的行并突出显示一些开关，使前面的输出更加人性化。这种详细程度有助于调试构建失败的情况。

## 生成过程的快捷 shell 语法

构建过程的快捷 shell(通常是 Bash)语法(假设内核配置步骤已经完成)可能类似于下面的示例，可能用于非交互式构建脚本中:

```sh
time make -j4 [ARCH=<...> CROSS_COMPILE=<...>] all && sudo make modules_install && sudo make install
```

在前面的代码中， **`&&`** 和 **`||`** 元素是 shell 的(Bash 的)便利条件列表语法:

*   `cmd1 && cmd2`表示:只有`cmd1`成功，才能运行`cmd2`。
*   `cmd1 || cmd2`表示:仅当`cmd1`失败时运行`cmd2`。

## 处理编译器切换问题

不久前，即 2016 年 10 月，当我试图为 x86_64 构建(较旧的 3.x)内核时，我遇到了以下错误:

```sh
$ make
[...]
CC scripts/mod/empty.o
scripts/mod/empty.c:1:0: error: code model kernel does not support PIC mode
/* empty file to figure out endianness / word size */
[...]
```

事实证明，这根本不是一个核心问题。相反，这是 Ubuntu 16.10 上的编译器切换问题:`gcc(1)`坚持默认使用`-fPIE`(其中 **PIE** 是**位置独立可执行文件**的缩写)标志。在旧内核的 Makefile 中，我们需要关闭它。从那以后就修好了。

*AskUbuntu* 网站上的这个问答，题目是*内核不支持 pic 模式编译？，*描述了如何做到这一点:[https://askubuntu . com/questions/851433/kernel-nots-support-pic-mode-for-compile](https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling)。

(有趣的是，在前面的*关注内核构建运行*部分，用最近的一个内核，注意构建是如何使用 **`-fno-PIE`** 编译器开关的。)

## 处理缺少的 OpenSSL 开发头

在一个实例中，Ubuntu 盒子上 x86_64 上的内核构建失败，出现以下错误:

```sh
[...] fatal error: openssl/opensslv.h: No such file or directory
```

这只是缺少 OpenSSL 开发头的一个例子；这一点在这里的*编译内核*文档的最低要求中有明确的提及:[https://github . com/Torvalds/Linux/blob/master/Documentation/process/changes . rst # OpenSSL](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl)。具体来说，它提到从 v4.3 及更高版本开始，需要`openssl`开发包。

仅供参考，本问答也展示了`openssl-devel`包的安装(或同等产品；例如，在树莓 Pi 上，`libssl-dev`包需要安装)解决了这个问题: *OpenSSL 在期间丢失。/configure。怎么修？*，可在[https://超级用户. com/questions/371901/OpenSSL-配置过程中丢失-如何修复](https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix)。

事实上，这个错误也发生在普通的 x86_64 *Fedora 29* 发行版上:

```sh
make -j4
[...]
HOSTCC scripts/sign-file
scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory
 #include <openssl/opensslv.h>
 ^~~~~~~~~~~~~~~~~~~~
compilation terminated.
make[1]: *** [scripts/Makefile.host:90: scripts/sign-file] Error 1
make[1]: *** Waiting for unfinished jobs....
make: *** [Makefile:1067: scripts] Error 2
make: *** Waiting for unfinished jobs....
```

此处的修复如下:

```sh
sudo dnf install openssl-devel-1:1.1.1-3.fc29
```

最后，记住一个几乎可以保证成功的方法:当你遇到那些你*无法修复的构建和/或启动错误时*:将准确的错误信息复制到剪贴板，进入谷歌(或另一个搜索引擎)，然后键入类似于`linux kernel build <ver ...> fails with <paste-your-error-message-here>`的内容。你可能会对这种帮助的频率感到惊讶。如果没有，努力做你的研究，如果你真的找不到任何相关的/正确的答案，一定要在一个合适的论坛上发表你的(深思熟虑的)问题。

Several Linux "builder" projects exist, which are elaborate frameworks for building a Linux system or distribution in its entirety (typically used for embedded Linux projects). As of the time of writing, ***Yocto*** ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)) is considered the industry standard Linux-builder project, with ***Buildroot*** ([https://buildroot.org/](https://buildroot.org/)) being an older but very much supported one; they are indeed well worth checking out.

# 摘要

这一章和前一章一样，详细介绍了如何从源代码构建 Linux 内核。我们从实际的内核(和内核模块)构建过程开始。构建完成后，我们展示了如何将内核模块安装到系统上。然后，我们继续讨论生成`initramfs`(或`initrd`)图像的实用性，并继续解释其背后的动机。内核构建的最后一步是引导加载程序的(简单)定制(这里，我们只关注 x86 GRUB)。然后，我们展示了如何通过新烘焙的内核引导系统，并验证其配置是否如我们所料。作为一个有用的附加组件，我们展示了如何为另一个处理器交叉编译 Linux 内核的基础知识。最后，我们分享了一些额外的技巧来帮助您构建内核。

同样，如果您还没有这样做，我们敦促您仔细检查并尝试这里提到的过程，并构建您自己的定制 Linux 内核。

因此，祝贺您从头开始完成 Linux 内核构建！您可能会发现，在实际的项目(或产品)中，您可能需要*而不是*实际执行内核构建过程中的每一步，正如我们努力尝试仔细展示的那样。为什么呢？一个原因是可能会有一个独立的 BSP 团队从事这方面的工作；另一个原因——越来越有可能，尤其是在嵌入式 Linux 项目上——是使用了一个 Linux 构建器框架，如 *Yocto* (或 *Buildroot* )。Yocto 通常会处理构建的机械方面。*不过*你能够*按照项目要求配置*内核真的很重要；这仍然需要在这里获得的知识和理解。

接下来的两章将带你进入 Linux 内核开发的世界，向你展示如何编写你的第一个内核模块。

# 问题

作为我们的总结，这里有一个问题列表，供您测试您对本章材料的知识:[https://github . com/packt publishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。你会在这本书的 GitHub repo 中找到一些问题的答案:[https://GitHub . com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions _ to _ assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。

# 进一步阅读

为了帮助您用有用的材料更深入地研究这个主题，我们在本书的 GitHub 存储库中的进一步阅读文档中提供了一个相当详细的在线参考资料和链接列表(有时甚至是书籍)。*进一步阅读*文档可在此处获得:[https://github . com/packt publishing/Linux-Kernel-Programming/blob/master/进一步阅读. md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md) 。********