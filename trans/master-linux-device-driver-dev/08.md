# *第 8 章*：与 V4L2 异步和媒体控制器框架集成

随着时间的推移，媒体支持已经成为**片上系统**(**SoCS**)的必备和销售论据，它正变得越来越复杂。 这些媒体 IP 核的复杂性使得获取传感器数据需要软件设置整个流水线(由多个子设备组成)。 基于设备树的系统的异步特性意味着那些子设备的设置和探测并不简单。 因此进入异步框架，当所有媒体子设备都准备好时，异步框架解决对子设备的无序探测，以便媒体设备按时弹出。 最后但并非最不重要的一点是，由于媒体管道的复杂性，有必要找到一种方法来简化组成它的子设备的配置。 于是出现了媒体控制器框架，它将整个媒体管道包装在单个元素(媒体设备)中。 它附带一些抽象概念，其中之一是每个子设备都被视为一个实体，要么具有接收器垫，要么具有源垫，或者两者兼而有之。

本章将重点介绍异步和媒体控制器框架如何工作以及它们是如何设计的，我们还将介绍它们的 API，以了解如何在**Video4Linux2**(**V4L2**)设备驱动程序开发中利用它们。

换句话说，在本章中，我们将介绍以下主题：

*   V4L2 异步接口和图绑定的概念
*   V4L2 异步和面向图形的 API
*   V4L2 异步框架和 API
*   Linux 媒体控制器框架

# 技术要求

在本章中，您将需要以下元素：

*   具备高级计算机体系结构知识和 C 编程技能
*   Linux 内核 v4.19.X 源代码，可从[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获得

# V4L2 异步接口和图绑定的概念

到目前为止，对于 V4L2 驱动程序开发，我们实际上还没有处理探测顺序。 也就是说，我们考虑了同步方法，即桥接设备驱动程序在探测期间为所有子设备同步注册设备。 但是，此方法不能用于本质上异步和无序的设备注册系统，例如**展平的设备树**。 为了解决这个问题，引入了我们目前所称的异步接口。

使用这种新方法，网桥驱动程序注册子设备描述符和通知器回调的列表，子设备驱动程序注册它们将要探测或已经成功探测的子设备。 异步核心将负责根据硬件描述符匹配子设备，并在找到匹配时调用网桥驱动程序回调。 当子设备未注册时，会调用另一个回调。 异步子系统以一种特殊方式依赖于设备声明，称为**图绑定**，我们将在下一节讨论这一点。

## 图形绑定

嵌入式系统的设备数量减少了，其中一些设备是无法发现的。 然而，设备树出现在画面中是为了(从硬件的角度)向内核描述实际系统。 有时(如果不是总是)，这些设备以某种方式相互连接。

虽然可以在设备树中使用指向其他节点的`phandle`属性来描述简单而直接的连接(例如父/子关系)，但无法对由多个互连组成的复合设备进行建模。 在某些情况下，关系建模会产生一个相当完整的图形-例如，i.MX6**图像处理单元**(**IPU**)，它本身是一个逻辑设备，但由几个物理 IP 块组成，这些物理 IP 块的互连可能会导致相当复杂的管道。

这就是所谓的**开放固件**(的**)**图**与其 API 和一些新概念一起介入**端口**和**端点**概念的地方：**

*   可以将**端口**视为设备中的接口(如在 IP 块中)。
*   可以将**端点**视为焊盘，因为它描述了到远程端口的连接的一端。

但是，`phandle`属性仍用于引用树中的其他节点。 有关这方面的更多文档，请参阅`Documentation/devicetree/bindings/graph.txt`。

### 端口和端点表示

端口是设备的接口。 设备可以有一个或多个端口。 端口由其所属设备的节点中包含的端口节点表示。 每个端口节点都包含此端口连接到的每个远程设备端口的端点子节点。 这意味着单个端口可以连接到远程设备上的多个端口，并且每个链路必须由端点子节点表示。 现在，如果设备节点包含多个端口，如果一个端口处有多个端点，或者端口节点需要连接到选定的硬件接口，则使用`#address-cells`、`#size-cells`和`reg`属性的流行方案来为节点编号。

以下摘录显示了如何使用`#address-cells`、`#size-cells`和`reg`属性来处理这些情况：

```sh
device {
    ...
    #address-cells = <1>;
    #size-cells = <0>;
    port@0 {
        #address-cells = <1>;
        #size-cells = <0>;
        reg = <0>;
        endpoint@0 {
            reg = <0>;
            ...
        };
        endpoint@1 {
            reg = <1>;
            ...
        };
    };
    port@1 {
        reg = <1>;
        endpoint { ... };
    };
};
```

这方面的完整文档可以在`Documentation/devicetree/bindings/graph.txt`中找到。 现在我们已经完成了端口和端点表示，我们需要学习如何彼此链接，如下一节中所述。

### 端点链接

对于要链接在一起的两个端点，它们中的每个都应该包含一个`remote-endpoint``phandle`属性，该属性指向远程设备端口中的相应端点。 反过来，远程端点应该包含`remote-endpoint`属性。 其`remote-endpoint`管脚相互指向的两个端点在包含端口之间形成链接，如下例所示：

```sh
device-1 {
    port {
        device_1_output: endpoint {
            remote-endpoint = <&device_2_input>;
        };
    };
};
device-2 {
    port {
        device_2_input: endpoint {
            remote-endpoint = <&device_1_output>;
        };
    };
}
```

引入图绑定概念而不讨论它的 API将是浪费时间。 让我们跳到这个新的 binding 方法附带的 API。

## V4L2 异步和面向图形的 API

这一节的标题不能误导您，因为图绑定不仅仅是针对 V4L2 子系统的。 Linux`DRM`子系统也利用了它。 也就是说，异步框架在很大程度上依赖于设备树来描述媒体设备及其端点和连接，或者这些端点之间的链路以及它们的总线配置属性。

### 从 DT(of_graph_*)接口到通用 fwnode 图 API(fwnode_graph_*)

`fwnode`图形 API 是一次成功的尝试，将仅基于图形 API 的设备树更改为通用 API，将 ACPI 和 API 的设备树合并在一起，以获得统一和通用的 API。 这通过使用相同的 API 用 ACPI 扩展了图形的概念。 通过查看`struct device_node`和`struct acpi_device`结构，您可以看到它们的共同成员：`struct fwnode_handle fwnode`：

```sh
struct device_node {
[...]
    struct fwnode_handle fwnode;
[...]
};
```

前面的摘录从设备树的角度表示设备节点，而下面的摘录与 ACPI 相关：

```sh
struct acpi_device	{
[...]
    struct fwnode_handle fwnode;
[...]
};
```

`fwnode`成员属于`struct fwnode_handle`类型，是抽象`device_node`或`acpi_device`的较低级别的泛型数据结构，因为它们都继承自此数据结构。 这使得`struct fwnode_handle`成为图形 API 同质化的好客户机，以便端点(通过其`fwnode_handle`类型的字段)可以引用 ACPI 设备或基于 OF 的设备。 该抽象模型现在用于图形 API 中，允许我们通过嵌入指向`struct fwnode_handle`的指针的通用数据结构(`struct fwnode_endpoint`，如下所述)来抽象端点，该指针可以引用 ACPI 或 OF 节点。 除了通用性之外，这还允许此端点的基础子设备基于 ACPI 或 OF：

```sh
struct fwnode_endpoint {
    unsigned int port;
    unsigned int id;
    const struct fwnode_handle *local_fwnode;
};
```

此结构不推荐使用旧的`struct of_endpoint`结构，`device_node*`类型的成员为`fwnode_handle*`类型的成员留出空间。 在上述结构中，`local_fwnode`指向相关固件节点，`port`为端口号(即对应于`port@0`中的`0`或`port@1`中的`1`)，`id`为该端点在端口内的索引(即对应于`endpoint@0`中的`0`和`endpoint@1`中的`1`)。

V4L2 框架使用此模型通过构建在`fwnode_endpoint`之上的`struct v4l2_fwnode_endpoint`来抽象与 V4L2 相关的端点，如下所示：

```sh
struct v4l2_fwnode_endpoint {
    struct fwnode_endpoint base;
    /*
     * Fields below this line will be zeroed by
     * v4l2_fwnode_endpoint_parse()
     */
    enum v4l2_mbus_type bus_type;
    union {
        struct v4l2_fwnode_bus_parallel parallel;
        struct v4l2_fwnode_bus_mipi_csi1 mipi_csi1;
        struct v4l2_fwnode_bus_mipi_csi2 mipi_csi2;
    } bus;
    u64 *link_frequencies;
    unsigned int nr_of_link_frequencies;
};
```

从内核 v4.13 开始，这个结构就过时并取代了`struct v4l2_of_endpoint`，以前由 V4L2 用来表示 API 的**V4L2 时代的端点节点。 在前面的数据结构定义中，`base`表示底层 ACPI 或设备节点的`struct fwnode_endpoint`结构。 其他字段与 V4L2 相关，如下所示：**

*   `bus_type`是该子设备用于传输数据的媒体总线的类型。 此成员的值确定应使用来自`fwnode`终结点(设备树或 ACPI)的解析总线属性填充哪个底层总线结构。 `enum v4l2_mbus_type`中列出了可能的值，如下所示：

    ```sh
    enum v4l2_mbus_type {
        V4L2_MBUS_PARALLEL,
        V4L2_MBUS_BT656,
        V4L2_MBUS_CSI1,
        V4L2_MBUS_CCP2,
        V4L2_MBUS_CSI2,
    };
    ```

*   `bus`是表示媒体总线本身的结构。 联合中已经存在可能的值，`bus_type`确定要考虑的值。 这些总线结构都在`include/media/v4l2-fwnode.h`中定义。
*   `link_frequencies`是该链路支持的频率列表。
*   `nr_of_link_frequencies` is the number of elements in `link_frequencies`.

    重要音符

    在内核 v4.19 中，`bus_type`成员是根据`fwnode`中的`bus-type`属性独占设置的。 驱动程序可以检查读取的值并调整其行为。 这意味着 V4L2`fwnode`API 将始终将其解析策略基于此`fwnode`属性。 然而，从内核 V5.0 开始，驱动程序必须将此成员设置为预期的总线类型(在调用解析函数之前)，该类型将与在`fwnode`中读取的`bus-type`属性的值进行比较，如果它们不匹配，则会引发错误。 如果总线类型未知或司机可以处理多个总线类型，则必须使用`V4L2_MBUS_UNKNOWN`值。 从内核 V5.0 开始，该值也是`enum v4l2_mbus_type`的一部分。

    在内核代码中，您可以找到`enum v4l2_fwnode_bus_type`枚举类型。 这是一个 V4L2`fwnode`本地枚举类型，它相当于全局`enum v4l2_mbus_type`枚举类型，其值相互映射。 随着代码的发展，它们各自的值保持同步。

然后，与 V4L2 相关的绑定需要附加属性。 这些属性的一部分用于构建`v4l2_fwnode_endpoint`，另一部分用于构建底层的`bus`(实际上是媒体总线)结构。 所有这些都在专门的、与视频相关的绑定文档`Documentation/devicetree/bindings/media/video- interfaces.txt`中进行了描述，我强烈建议您查看该文档。

下面是网桥(`isc`)和传感子设备(`mt9v032`)之间的典型绑定：

```sh
&i2c1 {
    #address-cells = <1>;
    #size-cells = <0>;
    mt9v032@5c {
        compatible = "aptina,mt9v032";
        reg = <0x5c>;
        port {
            mt9v032_out: endpoint {
                remote-endpoint = <&isc_0>;
                link-frequencies =
                       /bits/ 64 <13000000 26600000 27000000>;
                hsync-active = <1>;
                vsync-active = <0>;
                pclk-sample = <1>;
            };
        };
    };
};
&isc {
    port {
        isc_0: endpoint@0 {
            remote-endpoint = <&mt9v032_out>;
            hsync-active = <1>;
            vsync-active = <0>;
            pclk-sample = <1>;
        };
    };
};
```

在前面的绑定中，`hsync-active`、`vsync-active`、`link-frequencies`和`pclk- sample`都是特定于 V4L2 的属性，并描述了媒体总线。 他们的价值观在这里并不连贯，也没有真正意义上的意义，但很适合我们的学习目的。 本摘录很好地展示了端点和远程端点的概念；在*Linux 媒体控制器框架*一节中详细讨论了`struct v4l2_fwnode_endpoint`的用法。

重要音符

V4L2 处理和`fwnode`API 的部分称为**V4L2 fwnode API**。 它取代了仅支持设备树的 API，即 API 的**V4L2。 前者有一组 API 前缀为`v4l2_fwnode_`，而第二个 API 集的前缀为`v4l2_of_`。 请注意，在仅基于 OF 的 API 中，端点由`struct of_endpoint`表示，而与 V4L2 相关的端点由`struct v4l2_of_endpoint`表示。 有一些 API 允许从基于 OF 的模型切换到基于`fwnode`的模型，反之亦然。**

的 V4L2`fwnode`和 V4L2 是完全可互操作的。 例如，使用 V4L2`fwnode`的子设备驱动程序将毫不费力地与使用 V4L2 的媒体设备驱动程序一起工作，反之亦然！ 但是，新驱动程序必须使用`fwnode`API，包括`#include <media/v4l2- fwnode.h>`，当切换到`fwnode`API 时，它应该替换旧驱动程序中的`#include <media/v4l2-of.h>`。

话虽如此，前面讨论的`struct fwnode_endpoint`只是为了展示潜在的机制。 我们本可以完全跳过它，因为只有核心处理此数据结构。 对于更通用的方法，与其使用`struct device_node`来引用设备的固件节点，不如使用新的`struct fwnode_handle`。 这无疑确保了 DT 和 ACPI 绑定使用驱动程序中的相同代码是兼容的/可互操作的。 以下是新驱动因素中的变化应该是什么样子的简短摘录：

```sh
-    struct device_node *of_node;
+    struct fwnode_handle *fwnode;
-    of_node = ddev->of_node;
+	fwnode = dev_fwnode(dev);
```

一些常见的`fwnode`节点相关接口如下：

```sh
[...]
struct fwnode_handle *fwnode_get_parent(
                           const struct fwnode_handle *fwnode);
struct fwnode_handle *fwnode_get_next_child_node(
                           const struct fwnode_handle *fwnode,
                           struct fwnode_handle *child);
struct fwnode_handle *fwnode_get_next_available_child_node(
                            const struct fwnode_handle *fwnode,
                            struct fwnode_handle *child);
#define fwnode_for_each_child_node(fwnode, child) \
    for (child = fwnode_get_next_child_node(fwnode, NULL); child; \
           child = fwnode_get_next_child_node(fwnode, child))
#define fwnode_for_each_available_child_node(fwnode, child) \
    for (child = fwnode_get_next_available_child_node(fwnode,                                                      NULL);          child; \
   child = fwnode_get_next_available_child_node(fwnode, child))
struct fwnode_handle *fwnode_get_named_child_node(
                            const struct fwnode_handle *fwnode,
                            const char *childname);
struct fwnode_handle *fwnode_handle_get(struct                                         fwnode_handle *fwnode);
void fwnode_handle_put(struct fwnode_handle *fwnode);
```

上述接口有以下说明：

*   `fwnode_get_parent()`返回其`fwnode`值在参数中给定的节点的父句柄，否则返回`NULL`。
*   `fwnode_get_next_child_node()`将父节点作为其第一个参数，并返回该父节点中给定子节点(作为第二个参数给出)之后的下一个子节点(否则返回`NULL`)。 如果`child`(第二个参数)为`NULL`，则将返回该父代的第一个子代。
*   `fwnode_get_next_available_child_node()`与`fwnode_get_next_child_node()`相同，但在返回`fwnode`句柄之前，请确保设备实际存在(已成功探测)。
*   `fwnode_for_each_child_node()`迭代给定节点中的子节点(第一个参数)，第二个参数用作迭代器。
*   `fwnode_for_each_available_child_node`与`fwnode_for_each_child_node()`相同，但只在系统中实际存在设备的节点上迭代。
*   `fwnode_get_named_child_node()`按名称获取给定节点中的子节点。
*   `fwnode_handle_get()`获取对设备节点的引用，`fwnode_handle_put()`删除该引用。

与`fwnode`相关的一些属性如下：

```sh
[...]
bool fwnode_device_is_available(const                                 struct fwnode_handle *fwnode); 
bool fwnode_property_present(const                              struct fwnode_handle *fwnode, 
                             const char *propname);
int fwnode_property_read_string(const                              struct fwnode_handle *fwnode, 
                             const char *propname,                              const char **val);
int fwnode_property_match_string(const                                  struct fwnode_handle *fwnode,
                                 const char *propname,                                  const char *string);
```

与属性和节点相关的`fwnode`API 在`include/linux/property.h`中都可用。 但是，有帮助器允许在 OF、ACPI 和`fwnode`之间来回切换。 以下是一个简短的示例：

```sh
/* to switch from fwnode to of */
struct device_node *of_node = to_of_node(fwnode);
/* to switch from of to fw */
struct fwnode_handle *fwnode = of_fwnode_handle(node)
/* to switch from fwnode to acpi handle, the below macro has
 * been introduced
 *
 * #define ACPI_HANDLE_FWNODE(fwnode)	\
 *        acpi_device_handle(to_acpi_device_node(fwnode))
 *
 * and to switch from acpi device to fwnode:
 *
 *   struct fwnode_handle *
 *          acpi_fwnode_handle(struct acpi_device *adev)
 *
 */
```

最后，也是对我们来说最重要的是`fwnode`图形 API。 在下面的代码片段中，我们列举了此 API 最重要的函数：

```sh
struct fwnode_handle
   *fwnode_graph_get_next_endpoint(const                                   struct fwnode_handle *fwnode,
                                  struct fwnode_handle *prev);
struct fwnode_handle
   *fwnode_graph_get_port_parent(const                                  struct fwnode_handle *fwnode);
struct fwnode_handle
   *fwnode_graph_get_remote_port_parent(
                           const struct fwnode_handle *fwnode);
struct fwnode_handle
   *fwnode_graph_get_remote_port(const                                  struct fwnode_handle *fwnode);
struct fwnode_handle 
   *fwnode_graph_get_remote_endpoint(
                           const struct fwnode_handle *fwnode);
#define fwnode_graph_for_each_endpoint(fwnode, child) \
    for (child = NULL;	\
    (child = fwnode_graph_get_next_endpoint(fwnode, child)); )
int fwnode_graph_parse_endpoint(const                                 struct fwnode_handle *fwnode,
                             struct fwnode_endpoint *endpoint);
[...]
```

尽管前面的函数名介绍了它们自身，但下面更好地描述了它们的作用：

*   `fwnode_graph_get_next_endpoint()`返回上一个端点(`prev`，第二个参数)之后的给定节点(第一个参数)中的下一个端点(否则返回`NULL`)。 如果`prev`为`NULL`，则返回第一个端点。 此函数获取对返回的终结点的引用，该终结点在使用后必须删除。 参见`fwnode_handle_put()`。
*   `fwnode_graph_get_port_parent()`返回参数中给定的端口节点的父节点。
*   `fwnode_graph_get_remote_port_parent()`返回远程设备的固件节点，该远程设备包含其固件节点是通过`fwnode`参数给定的终结点。
*   `fwnode_graph_get_remote_endpoint()`返回远程终结点的固件节点，该远程终结点与其固件节点是通过`fwnode` 参数给定的本地终结点相对应。
*   `fwnode_graph_parse_endpoint()`解析表示图形端点节点的`fwnode`(第一个参数)中的公共端点节点属性，并将信息存储在`endpoint`(第二个和输出参数)中。 V4L2 固件节点e API 大量使用这一点。

### V4L2 固件节点(V4L2 Fwnode)API

V4L2 fwnode API 的主要数据结构为`struct v4l2_fwnode_endpoint`。 这个结构只不过是`struct fwnode_handle`增加了一些与 V4L2 相关的属性。 然而，这里有一个与 V4L2 相关的 fwnode 图函数值得一谈：`v4l2_fwnode_endpoint_parse()`。 此函数的原型声明为`include/media/v4l2-fwnode.h`，如下所示：

```sh
int v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
                             struct v4l2_fwnode_endpoint *vep);
```

给定端点的`fwnode_handle`(前面函数中的第一个参数)，您可以使用`v4l2_fwnode_endpoint_parse()`来解析所有 fwnode 属性。 该函数还识别并处理特定于 V4L2 的属性，如果您还记得的话，这些属性记录在`Documentation/devicetree/bindings/media/video-interfaces.txt`中。 `v4l2_fwnode_endpoint_parse()`使用`fwnode_graph_parse_endpoint()`解析常见的 fwnode 属性，并使用特定于 V4L2 的解析器助手解析与 V4L2 相关的属性。 如果成功，则返回`0`；如果失败，则返回负错误代码。

如果我们考虑`dts`中的`mt9v032`CMOS 图像传感器节点，我们可以在`probe`方法中使用以下代码：

```sh
int err;
struct fwnode_handle *ep;
struct v4l2_fwnode_endpoint bus_cfg;
/* We grab the fwnode corresponding to the device */
struct fwnode_handle *fwnode = dev_fwnode(dev);
/* We grab its endpoint(s) node */
ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
/* We parse the endpoint common properties as well as
 * v4l2 related properties  */
err = v4l2_fwnode_endpoint_parse(ep, &bus_cfg);
if (err) {   /* handle error */ }
/* At this point we can access parameters such as bus_type,  * bus.flags  
 * (in case of mipi csi2 or parallel buses), V4L2_MBUS_*  * which are the 
 * media bus flags
 */
/* we drop the reference on the enpoint */
fwnode_handle_put(ep);
```

前面的代码显示了如何使用 fwnode API 及其 V4L2 版本来访问节点和端点属性。 但是，在调用`v4l2_fwnode_endpoint_parse()`时会解析特定于 V4L2 的属性。 这些属性描述了所谓的**媒体总线**到，其数据从一个接口e 传送到另一个接口。 我们将在下一节讨论这个问题。

### V4L2 转发节点或媒体总线类型

大多数媒体设备支持特定的媒体总线类型。 虽然端点链接在一起，但它们实际上是通过总线连接的，需要向 V4L2 框架描述其属性。 为了使 V4L2 能够找到该信息，它在设备的 fwnode(DT 或 ACPI)中作为属性提供。 因为这些是特定的属性，所以 V4L2fwnode API 能够识别和解析它们。 每条总线都有其特性和属性。

首先，让我们看看目前支持的总线及其数据结构：

*   **MIPI CSI-1**：这是 MIPI Alliance 的**摄像机串行接口**(**CSI**)版本 1。此总线表示为`struct v4l2_fwnode_bus_mipi_csi1`的实例。
*   **CCP2**：这代表**紧凑型相机端口 2**，由**标准移动成像架构**(**SMIA**)制定，该架构是为处理移动应用程序(如 SMIA CCP2)中使用的相机模块的公司制定的开放标准。 此总线在此框架中也用`struct v4l2_fwnode_bus_mipi_csi1`实例表示。
*   **并行总线**：这是典型的并行接口，具有`HSYNC`和`VSYNC`信号。 用于表示该总线的结构是`struct v4l2_fwnode_bus_parallel`。
*   **BT656**：这适用于 BT.1120 或在数据中传输常规视频定时和同步信号(`HSYNC`、`VSYNC`和`BLANK`)的任何并行总线。 与标准并行总线相比，这些总线具有更少的引脚数量。 该框架使用`struct v4l2_fwnode_bus_parallel`来表示该总线。
*   **MIPI CSI-2**：这是 MIPI Alliance 的 CSI 接口的版本 2。 此总线由`struct v4l2_fwnode_bus_mipi_csi2`结构抽象。 但是，此数据结构不区分 D-PHY 和 C-PHY。 从内核 V5.0 开始，就解决了这种差异不足的问题。

正如我们将在后面的一章中看到的，在*媒体总线的概念*一节中，总线的这个概念可以用来检测本地端点与其远程对应设备之间的兼容性，这样，如果两个子设备不具有相同的总线属性，就不能链接在一起，这是完全有道理的。

在前面的*V4L2fwnode API*部分中，我们看到`v4l2_fwnode_endpoint_parse()`负责解析端点的 fwnode 并填充适当的总线结构。 此函数首先调用`fwnode_graph_parse_endpoint()`以解析常见的 fwnode 图形相关属性，然后检查`bus-type`属性的值，如下所示，以确定适当的`v4l2_fwnode_endpoint.bus`数据类型：

```sh
u32 bus_type = 0;
fwnode_property_read_u32(fwnode, "bus-type", &bus_type);
```

根据此值，将选择总线数据结构。 以下是来自`fwnode`设备的预期可能值：

*   `0`：这意味着自动检测。 内核将根据 fwnode 中存在的属性(MIPI CSI-2 D-PHY、PARALLEL 或 BT656)尝试猜测总线类型。
*   `1`：这意味着 MIPI CSI-2 C-PHY。
*   `2`：这意味着 MIPI CSI-1。
*   `3`：这意味着 CCP2。

例如，对于 CPP2 总线，设备的 fwnode将包含以下行：

```sh
bus-type = <3>;
```

重要音符

从内核 V5.0 开始，驱动程序可以在将其作为第二个参数提供给`v4l2_fwnode_endpoint_parse()`之前，在`v4l2_fwnode_endpoint`的`bus_type`成员中指定预期的总线类型。 这样，除非预期的总线 t类型设置为`V4L2_MBUS_UNKNOWN`，否则如果前面的`fwnode_property_read_u32`返回的值与预期值不匹配，则解析将失败。

#### BT656 和并行总线

这些总线类型都是，由`struct v4l2_fwnode_bus_parallel`表示，如下所示：

```sh
struct v4l2_fwnode_bus_parallel {
    unsigned int flags;
    unsigned char bus_width;
    unsigned char data_shift;
};
```

在前面的数据结构中，`flags`表示总线的标志。 这些标志将根据设备固件节点中存在的属性进行设置。 `bus_width`表示当前使用的数据线的数量，不一定是总线的总线数。 `data_shift`用于通过指定在到达第一个有效数据线之前要跳过的行数来指定真正使用哪些数据线。 以下是用于设置`struct v4l2_fwnode_bus_parallel`的这些媒体总线的绑定属性：

*   `hsync-active`：HSYNC 信号的激活状态；`0`/`1`分别表示`LOW`/`HIGH`。 如果该属性的值为`0`，则在`flags`成员中设置`V4L2_MBUS_HSYNC_ACTIVE_LOW`标志。 任何其他值将改为设置`V4L2_MBUS_HSYNC_ACTIVE_HIGH`标志。
*   `vsync-active`：Vsync 信号的激活状态；`0`/`1`分别对应于`LOW`/`HIGH`。 如果该属性的值为`0`，则在`flags`成员中设置`V4L2_MBUS_VSYNC_ACTIVE_LOW`标志。 任何其他值将改为设置`V4L2_MBUS_VSYNC_ACTIVE_HIGH`标志。
*   `field-even-active`：偶数场数据传输期间的场信号电平。 这与前面的相同，但是相关的标志是`V4L2_MBUS_FIELD_EVEN_HIGH`和`V4L2_MBUS_FIELD_EVEN_LOW`。
*   `pclk-sample`：像素时钟信号`V4L2_MBUS_PCLK_SAMPLE_RISING`和`V4L2_MBUS_PCLK_SAMPLE_FALLING`的上升沿(`1`)或下降沿(`0`)上的采样数据。
*   `data-active`：与`HSYNC`和`VSYNC`类似，指定数据线极性`V4L2_MBUS_DATA_ACTIVE_HIGH`和`V4L2_MBUS_DATA_ACTIVE_LOW`。
*   `slave-mode`：这是一个布尔属性，它的出现表明链路在从属模式下运行，并且设置了`V4L2_MBUS_SLAVE`标志。 否则，将设置`V4L2_MBUS_MASTER`标志。
*   `data-enable-active`：与`HSYNC`和`VSYNC`类似，指定数据使能信号极性。
*   `bus-width`：此属性仅与并行总线有关，并表示当前使用的数据线的数量。 相应地设置`V4L2_MBUS_DATA_ENABLE_HIGH`或`V4L2_MBUS_DATA_ENABLE_LOW`标志。
*   `data-shift`：在使用`bus-width`指定数据线数量的并行数据总线上，此属性可用于指定实际使用的数据线；例如，`bus-width=<8>; data-shift=<2>;`表示使用 9：2 线。
*   `sync-on-green-active`：**同步绿色**(**SOG**)信号的激活状态；`LOW`/`HIGH`分别为`0`/`1`。 相应地设置`V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH`或`V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW`标志。

这些总线的类型为`V4L2_MBUS_PARALLEL`或`V4L2_MBUS_BT656`。 负责解析这些总线的底层函数是`v4l2_fwnode_endpoint_parse_parallel_bus()`。

#### MIPI CSI-2 总线

这是 MIPI 联盟的 CSI 总线的第二版。 此总线涉及两个物理层：D-PHY 或 C-PHY。 D-PHY 面世已有一段时间，主要针对相机、显示器和低速应用。 C-PHY 是一种更新、更复杂的 PHY，其中时钟被嵌入到数据中，因此不需要单独的时钟通道。 与 D-PHY 相比，它具有更少的导线、更少的通道数和更低的功耗，并且可以实现更高的数据速率。 C-PHY 在带宽有限的信道上提供高吞吐量性能。

启用 C-PHY 和 D-PHY 的总线都使用一个数据结构`struct``v4l2_fwnode_bus_mipi_csi2`表示，如下所示：

```sh
struct v4l2_fwnode_bus_mipi_csi2 {
    unsigned int flags;
    unsigned char data_lanes[V4L2_FWNODE_CSI2_MAX_DATA_LANES]; 
    unsigned char clock_lane;
    unsigned short num_data_lanes;
    bool lane_polarities[1 + V4L2_FWNODE_CSI2_MAX_DATA_LANES];
};
```

在前面的块中，`flags`代表总线的标志，将根据固件节点中存在的属性进行设置：

*   `data-lanes`是个物理数据通道索引的数组。
*   `lane-polarities`：此属性仅对串行总线有效。 它是通道的极性数组，从时钟通道开始，然后是数据通道，顺序为 SAMe，如`data-lanes`属性。 有效值为`0`(正常)和`1`(反转)。 此数组的长度应该是`data-lanes`和`clock-lanes`属性的组合长度。 有效值为`0`(正常)和`1`(反转)。 如果省略`lane-polarities`属性，则该值必须解释为`0`(正常)。
*   `clock-lanes`是时钟通道的物理通道索引。 这是时钟通道位置。
*   `clock-noncontinuous`：如果存在，则设置`V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK`标志。 否则，设置`V4L2_MBUS_CSI2_CONTINUOUS_CLOCK`。

这些公交车是`V4L2_MBUS_CSI2`型的。 在 Linux 内核 v4.20 之前，支持 C-PHY 和 D-PHY 的 CSI 总线之间没有区别。 然而，从 Linux 内核 V5.0 开始，对于支持 D-PHY 或 C-PHY 的总线，已经引入了这种差异，并且分别用`V4L2_MBUS_CSI2_DPHY`或`V4L2_MBUS_CSI2_CPHY`替换了`V4L2_MBUS_CSI2`。

负责解析这些总线的底层函数是`v4l2_fwnode_endpoint_parse_csi2_bus()`。 下面是一个例子：

```sh
[...]
    port {
        tc358743_out: endpoint {
          remote-endpoint = <&mipi_csi2_in>;           clock-lanes = <0>;
          data-lanes = <1 2 3 4>;
          lane-polarities = <1 1 1 1 1>;
          clock-noncontinuous;
        };
    };
```

#### CPP2 和 MIPI CSI-1 总线

这些是较旧的单数据通道串行总线。 它们的类型对应于`V4L2_FWNODE_BUS_TYPE_CCP2`或`V4L2_FWNODE_BUS_TYPE_CSI1`。 内核使用`struct v4l2_fwnode_bus_mipi_csi1`表示这些总线：

```sh
struct v4l2_fwnode_bus_mipi_csi1 {
    bool clock_inv;
    bool strobe;
    bool lane_polarity[2];
    unsigned char data_lane;
    unsigned char clock_lane;
};
```

以下是此结构中元素的含义：

*   `clock-inv`：时钟/选通信号的极性(FALSE 表示不反转，TRUE 表示反转)。 `0`表示 FALSE，其他值表示 TRUE。
*   `strobe`：假-数据/时钟，真-数据/选通。
*   `data-lanes`：数据通道的数量。
*   `clock-lanes`：时钟通道的数量。
*   `lane-polarities`：这与前面相同，但由于 CPP2 和 MIPI CSI-1 是单数据串行总线，阵列只能有两个条目：时钟极性(索引`0`)和数据通道(索引`1`)。

在解析给定节点之后，前面的数据结构用`v4l2_fwnode_endpoint_parse_csi1_bus()`填充。

#### 猜公交车

将总线类型指定为`0`(或`V4L2_MBUS_UNKNOWN`)将指示 V4L2 内核根据固件节点中找到的属性尝试猜测实际的媒体总线。 它将首先考虑设备是否在 CSI-2 总线上，并尝试相应地解析端点节点，查找与 CSI-2 相关的属性。 幸运的是，CSI-2 和并行总线没有共同的属性。 这样，如果且仅当没有找到特定于 MIPI CSI-2 的属性时，内核才会解析并行视频总线属性。 核心不是 guess`V4L2_MBUS_CCP2`也不是`V4L2_MBUS_CSI1`。 对于这些总线，必须指定`bus-type`属性。

## V4L2 异步

由于基于视频的硬件非常复杂，有时会集成位于不同总线上的非 V4L2 设备(实际上是子设备)，因此需要对子设备推迟初始化，直到加载了网桥驱动程序，而另一方面，网桥驱动程序需要推迟初始化子设备，直到加载了所有所需的子设备；即 V4L2 异步。

在异步模式下，可以独立于网桥驱动程序可用性调用子设备探测。 然后，子设备驱动程序必须验证子设备驱动程序是否满足成功探测的所有要求。 这可以包括检查主时钟可用性、GPIO 或任何其他内容。 如果不满足任何条件，子设备驱动程序可能决定返回`-EPROBE_DEFER`以请求进一步的重新探测尝试。 一旦满足所有条件，子设备将使用`v4l2_async_register_subdev()`函数向 V4L2 异步内核注册。 取消注册是使用`v4l2_async_unregister_subdev()`调用执行的。

我们在前面看到了同步注册的应用。 在这种模式下，网桥驱动程序知道其负责的所有子设备的上下文。 它负责在探测期间使用每个子设备上的`v4l2_device_register_subdev()`注册所有子设备，就像`drivers/media/platform/exynos4-is/media-dev.c`驱动程序一样。

在 V4L2 异步框架中，抽象子设备的概念。 子设备在异步框架中被称为`struct v4l2_async_subdev`结构的实例。 除了这个结构，还有另一个`struct v4l2_async_notifier`结构。 两者都在`include/media/v4l2-async.h`中定义，并以某种方式形成 V4L2 异步内核的中心部分。 在进一步介绍之前，我们必须介绍 V4L2 异步框架的核心部分`struct v4l2_async_notifier`，如下所示：

```sh
struct v4l2_async_notifier {
    const struct v4l2_async_notifier_operations *ops;
    unsigned int num_subdevs;
    unsigned int max_subdevs;
    struct v4l2_async_subdev **subdevs;
    struct v4l2_device *v4l2_dev;
    struct v4l2_subdev *sd;
    struct v4l2_async_notifier *parent;
    struct list_head waiting;
    struct list_head done;
    struct list_head list;
};
```

前述结构主要由桥驱动器和异步内核使用。 但是，在某些情况下，子设备驱动程序可能需要由某些其他子设备通知。 在这两种情况下，成员的用途和含义都是相同的：

*   `ops`是要由该通知器的所有者提供的一组回调，当探测到在该通知器中等待的子设备时，该回调由异步核心调用。
*   `v4l2_dev`是注册此通告程序的网桥驱动程序的 V4L2 父级。
*   `sd`，如果此通知器已由子设备注册，则将指向此子设备。 我们在这里不处理这个案例。
*   `subdevs`是应该通知此通知器的注册商(网桥驱动程序或另一个子设备驱动程序)的子设备数组。
*   `waiting`是此通告程序中等待探测的子设备的列表。
*   `done`是实际绑定到此通知器的子设备的列表。
*   `num_subdevs`是`**subdevs`中的子设备数。
*   `list`由异步核心在该通知器的注册期间使用，以便将该通知器链接到通知器的全局列表`notifier_list`。

回到我们的`struct v4l2_async_subdev`结构，其定义如下：

```sh
struct v4l2_async_subdev {
    enum v4l2_async_match_type match_type;
    union {
        struct fwnode_handle *fwnode;
        const char *device_name;
        struct {
            int adapter_id;
            unsigned short address;
        } i2c;
        struct {
        bool (*match)(struct device *,                      struct v4l2_async_subdev *);
            void *priv;
        } custom;
    } match;
    /* v4l2-async core private: not to be used by drivers */
    struct list_head list;
};
```

在 V4L2 异步框架中，上述数据结构是一个子设备。 只有网桥驱动程序(其分配异步子设备)和异步核心可以使用该结构。 子设备驱动程序根本不知道这一点。 其成员的含义如下：

*   `match_type` is of the `enum v4l2_async_match_type` type. A match is a comparison of some criteria (occurring **strictly** between a sub-device of the `struct v4l2_subdev` type and an async sub-device of the `struct v4l2_async_subdev` type). Since each `struct v4l2_async_subdev` structure must be associated with its `struct v4l2_subdev` structure, this field specifies the algorithm used by the async core to match both. This field is set by the driver (which is also responsible for allocating asynchronous sub-devices). Possible values are as follows:

    --`V4L2_ASYNC_MATCH_DEVNAME`，指示异步内核使用设备名称进行匹配。 在这种情况下，网桥驱动程序必须设置`v4l2_async_subdev.match.device_name`字段，以便在探查该子设备时可以匹配子设备设备名称(即`dev_name(v4l2_subdev->dev)`)。

    --`V4L2_ASYNC_MATCH_FWNODE`，表示异步内核应该使用固件节点进行匹配。 在这种情况下，网桥驱动程序必须使用与子设备的设备节点相对应的固件节点句柄设置`v4l2_async_subdev.match.fwnode`，以便它们可以匹配。

    --`V4L2_ASYNC_MATCH_I2C`用于通过检查 I2C 适配器 ID 和地址来执行匹配。 使用此选项时，桥接器驱动器必须同时设置`v4l2_async_subdev.match.i2c.adapter_id`和`v4l2_async_subdev.match.i2c.address`。 这些值将与与`v4l2_subdev.dev`关联的`i2c_client`对象的地址和适配器号进行比较。

    --`V4L2_ASYNC_MATCH_CUSTOM`是最后一种可能性，表示异步内核应该使用由`v4l2_async_subdev.match.custom.match`中的网桥驱动程序设置的匹配回调。 如果设置了此标志，并且没有提供自定义匹配回调，则任何匹配尝试都将立即返回 TRUE。

*   `list`用于将该待探测的异步子设备添加到通知器的等待列表中。

子设备注册不再依赖网桥可用性，只需调用`v4l2_async_unregister_subdev()`方法即可。 但是，在注册自身之前，网桥驱动程序必须执行以下操作：

1.  分配一个通知器以供以后使用。 最好将此通知器嵌入较大的设备状态数据结构中。 此通知器对象属于`struct v4l2_async_notifier`类型。
2.  Parse its port node(s) and create an async sub-device (`struct v4l2_async_subdev`) for each sensor (or IP block) specified there and that it needs for its operations:

    A)此解析是使用`fwnode`图形 API(旧驱动程序仍使用`of_graph`API)完成的，如下所示：

    --`fwnode_graph_get_next_endpoint()`(或旧驱动程序中的`of_graph_get_next_endpoint()`)，从网桥的端口子节点中获取端点的`fw_handle`(或旧驱动程序中的`of_node`)。

    --`fwnode_graph_get_remote_port_parent()`(或旧驱动程序中的`of_graph_get_remote_port_parent()`)，以获取与当前端点的远程端口的父级相对应的`fw_handle`(或旧驱动程序中的设备的`of_node`)。

    可选地(在使用 OF API 的旧驱动程序中)使用`of_fwnode_handle()`，以便将在先前状态中抓取的`of_node`转换为`fw_handle`。

    B)根据应该使用的匹配逻辑设置当前的异步子设备。 它应该设置`v4l2_async_subdev.match_type`和`v4l2_async_subdev.match`成员。

    C)将该异步子设备添加到通知器的异步子设备列表中。 从内核的 4.20 版开始，有一个帮助器`v4l2_async_notifier_add_subdev()`，允许您执行此操作。

3.  使用`v4l2_async_notifier_register(&big_struct->v4l2_dev, &big_struct->notifier)`调用注册通知器对象(此通知器将存储在`drivers/media/v4l2-core/v4l2-async.c`中定义的全局`notifier_list`列表中)。 要取消注册通知器，驱动程序必须调用`v4l2_async_notifier_unregister(&big_struct->notifier)`。

当网桥驱动程序调用`v4l2_async_notifier_register()`时，异步内核在`notifier->subdevs`数组中的异步子设备上迭代。 对于内部的每个异步子设备，内核检查此`asd->match_type`值是否为`V4L2_ASYNC_MATCH_FWNODE`。 如果适用，异步内核通过比较 fwnode 来确保`asd`不在`notifier->waiting`列表或`notifier->done`列表中。 这提供了保证`asd`尚未为`fwnode`设置，并且它还不存在于给定的通知器中。 如果`asd`未知，则将其添加到`notifier->waiting`。 在此之后，异步核心将测试`notifier->waiting`列表中的所有异步子设备是否与`subdev_list`中存在的所有子设备匹配，`subdev_list`是在桥驱动程序之前注册的孤儿子设备的列表(因此在其通知器之前)。 异步内核为此使用每个电流`asd`的`asd->match`值。 如果匹配(`asd->match`回调返回 TRUE)，则当前异步子设备(来自`notifier->waiting`)和当前子设备(来自`subdev_list`)将被绑定，异步子设备将从`notifier->waiting`列表中移除，子设备将使用`v4l2_device_register_subdev()`向 V4L2 内核注册，子设备将从全局`subdev_list`列表移至`notifier->done`列表。

最后，正在注册的实际通知器将被添加到通知器的全局列表`notifier_list`，以便以后每当向异步核心注册新子设备时都可以将其用于匹配尝试。

重要音符

可以从前面的匹配和绑定逻辑描述中猜测当子设备驱动程序调用`v4l2_async_register_subdev()`时异步内核会做什么。 有效地，在该调用之后，异步核心将尝试将当前子设备与在`notifier_list`全局列表中存在的每个通知器中等待的所有异步子设备进行匹配。 如果没有匹配，则意味着该子设备的网桥尚未被探测，并且该子设备被添加到子设备的全局列表`subdev_list`。 如果匹配，该子设备将根本不会添加到此列表中。

请记住，匹配测试是一些标准的比较，严格地在`struct v4l2_subdev`类型的子设备和`struct v4l2_async_subdev`类型的异步子设备之间进行。

在前面的参数图中，我们说了异步子设备和子设备是绑定的。 但这意味着什么呢？ 这就是`notifier->ops`成员进入画面的地方。 它属于`struct v4l2_async_notifier_operations`类型，定义如下：

```sh
struct v4l2_async_notifier_operations {
    int (*bound)(struct v4l2_async_notifier *notifier,
                  struct v4l2_subdev *subdev,
                  struct v4l2_async_subdev *asd);
    int (*complete)(struct v4l2_async_notifier *notifier);
    void (*unbind)(struct v4l2_async_notifier *notifier,
                    struct v4l2_subdev *subdev,
                    struct v4l2_async_subdev *asd);
};
```

以下是此结构中每个回调的含义，尽管所有三个回调都是可选的：

*   `bound`：如果设置，则异步核心将调用此回调，以响应其(子设备)驱动程序成功的子设备探测。 这还意味着异步子设备已成功匹配该子设备。 此回调将发起匹配的通知器以及匹配的子设备(`subdev`)和异步子设备(`asd`)作为参数。 大多数驱动程序只需在此处打印调试消息。 但是，您可以在此处的子设备(即`v4l2_subdev_call()`)上执行其他设置。 如果一切正常，它应该返回一个正值；否则，该子设备将被取消注册。
*   从系统中删除子设备时调用`unbind`。 除了在此处打印调试消息外，如果未绑定子设备是视频设备正常工作的必要条件(即`video_unregister_device()`)，则网桥驱动程序必须注销该视频设备。
*   当通知器中不再有异步子设备等待时，调用`complete`。 异步核心可以检测到`notifier->waiting`列表何时为空(这意味着子设备已被成功探测并全部移入`notifier->done`列表)。 仅对根通知器执行完整的回调。 已注册通知器的子设备将不会调用其`.complete`回调。 根通知器通常是由网桥设备注册的根通知器。

因此，毫无疑问，在注册通告程序对象之前，桥驱动程序必须设置通告程序的`ops`成员。 对我们来说最重要的回调是`.complete`。

虽然您可以从网桥驱动程序的`probe`函数中调用`v4l2_device_register()`，但通常的做法是从`notifier.complete`回调中注册实际的视频设备，因为所有子设备都会被注册，而`/dev/videoX`的存在意味着它实际上是可用的。 `.complete`回调也适用于通过`v4l2_device_register_subdev_nodes()`和`media_device_register()`注册实际视频设备的子节点和注册媒体设备。

请注意，`v4l2_device_register_subdev_nodes()`将为每个标有`V4L2_SUBDEV_FL_HAS_DEVNODE`标志的`subdev`对象ct 创建一个设备节点(实际上是`/dev/v4l2-subdevX`)。

### 异步网桥和子设备探测示例

我们将通过一个简单的用例来介绍这部分。 请考虑以下配置：

*   一个网桥设备(我们的 CSI 控制器)-假设是`omap`ISP，其名称为`foo`。
*   One off-chip sub-device, the camera sensor, with `bar` as its name.

    两者都是这样连接的：`CSI <-- Camera Sensor`。

在`bar`驱动程序中，我们可以按如下方式注册异步子设备：

```sh
static int bar_probe(struct device *dev)
{
    int ret;
    ret = v4l2_async_register_subdev(subdev);
    if (ret) {
        dev_err(dev, "ouch\n");
        return -ENODEV;
    }
    return 0;
}
```

`foo`驱动器的`probe`功能可以如下所示：

```sh
/* struct foo_device */
struct foo_device {
    struct media_device mdev;
    struct v4l2_device v4l2_dev;
    struct video_device *vdev;
    struct v4l2_async_notifier notifier;
    struct *subdevs[FOO_MAX_SUBDEVS];
};
/* foo_probe() */
static int foo_probe(struct device *dev)
{
    struct foo_device *foo = kmalloc(sizeof(*foo)); 
    media_device_init(&bar->mdev);
    foo->dev = dev;
    foo->notifier.subdevs = kcalloc(FOO_MAX_SUBDEVS,
                             sizeof(struct v4l2_async_subdev)); 
    foo_parse_nodes(foo);
    foo->notifier.bound = foo_bound;
    foo->notifier.complete = foo_complete; 
    return 
        v4l2_async_notifier_register(&foo->v4l2_dev,                                      &foo->notifier);
}
```

在下面的代码中，我们实现了`foo`fwnode(或`of_node`)解析器帮助器`foo_parse_nodes()`：

```sh
struct foo_async {
    struct v4l2_async_subdev asd;
    struct v4l2_subdev *sd;
};
/* Either */
static void foo_parse_nodes(struct device *dev,
                            struct v4l2_async_notifier *n)
{
    struct device_node *node = NULL;
    while ((node = of_graph_get_next_endpoint(dev->of_node,                                               node))) { 
        struct foo_async *fa = kmalloc(sizeof(*fa));
        n->subdevs[n->num_subdevs++] = &fa->asd;
        fa->asd.match.of.node =         of_graph_get_remote_port_parent(node); 
        fa->asd.match_type = V4L2_ASYNC_MATCH_OF;
    }
}
/* Or */
static void foo_parse_nodes(struct device *dev,
                            struct v4l2_async_notifier *n)
{
    struct fwnode_handle *fwnode = dev_fwnode(dev);
    struct fwnode_handle *ep = NULL;
    while ((ep = fwnode_graph_get_next_endpoint(ep, fwnode))) {
        struct foo_async *fa = kmalloc(sizeof(*fa));
        n->subdevs[n->num_subdevs++] = &fa->asd;
        fa->asd.match.fwnode =
                fwnode_graph_get_remote_port_parent(ep);
        fa->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
    }
}
```

在前面的代码中，已经使用了`of_graph_get_next_endpoint()`和`fwnode_graph_get_next_endpoint()`来说明如何使用这两个代码。 也就是说，您最好使用 fwnode 版本，因为它更通用。

同时，我们需要编写`foo`的通知程序操作，如下所示：

```sh
/* foo_bound() and foo_complete() */
static int foo_bound(struct v4l2_async_notifier *n,
                struct v4l2_subdev *sd,                 struct v4l2_async_subdev *asd)
{
    struct foo_async *fa = container_of(asd, struct bar_async,                                         asd);
    /* One can use subdev_call here */
    [...]
    fa->sd = sd;
}
static int foo_complete(struct v4l2_async_notifier *n)
{
    struct foo_device *foo =
             container_of(n, struct foo_async, notifier);
    struct v4l2_device *v4l2_dev = &isp->v4l2_dev;
    /* Create /dev/sub-devX if applicable */ 
    v4l2_device_register_subdev_nodes(&foo->v4l2_dev);
    /* setup the video device: fops, queue, ioctls ... */
[...]
    /* Register the video device */
       ret = video_register_device(foo->vdev,                                    VFL_TYPE_GRABBER, -1);
    /* Register with the media controller framework */ 
    return media_device_register(&bar->mdev);
}
```

在设备树中，V4L2 网桥设备可以声明如下：

```sh
csi1: csi@1cb4000 {
    compatible = "allwinner,sun8i-v3s-csi";
    reg = <0x01cb4000 0x1000>;
    interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
    /* we omit clock and others */
[...]
    port {
        csi1_ep: endpoint {
            remote-endpoint = <&ov7740_ep>;
           /* We omit v4l2 related properties */
[...]
        };
    };
};
```

可以如下声明来自 I2C 控制器节点内的摄像机节点：

```sh
&i2c1 {
    #address-cells = <1>;
    #size-cells = <0>;
    ov7740: camera@21 {
        compatible = "ovti,ov7740";
        reg = <0x21>;
        /* We omit clock or pincontrol or everything else */

       [...]
       port {
           ov7740_ep: endpoint {
               remote-endpoint = <&csi1_ep>;
               /* We omit v4l2 related properties */
               [...]
           };
       };
   };
};
```

现在我们熟悉了 V4L2 异步框架，并且我们已经看到了异步子设备注册如何简化探测和代码。 我们以一个具体的例子结束，它突出了我们讨论的每一个方面。 现在，我们可以继续前进并与媒体控制器框架集成，这是我们可以添加到 V4L2 驱动程序的最后一项改进。

# Linux 媒体控制器框架

媒体设备非常复杂，涉及 SoC 的几个 IP 块，因此需要视频流(重新)路由。

现在，让我们考虑这样一个情况，其中我们有一个更复杂的 SoC，它由另外两个片上子设备组成-比方说一个大小调节器和一个图像转换器，称为`baz`和`biz`。

在*V4L2 Async*部分的上一个示例中，设置由一个桥接设备和一个子设备(片外并不重要)组成，即摄像机传感器。 这是相当直截了当的。 幸运的是，事情奏效了。 但是，如果我们现在必须通过图像转换器或图像大小调整器路由流，甚至通过这两个 IP 怎么办？ 或者，假设我们必须(动态)从一个切换到另一个？

我们可以通过`sysfs`或`ioctls`来实现这一点，但这会有以下问题：

*   它会太难看(毫无疑问)，而且可能会有问题。
*   那太难了(很多工作)。
*   它将严重依赖于 SoC 供应商，可能会有大量代码重复，没有统一的用户空间 API 和 ABI，驱动程序之间也没有一致性。
*   这不是一个非常可信的解决方案。

许多 SoC 可以重新路由内部视频流-例如，从传感器捕获它们并执行内存到内存大小调整，或者将传感器输出直接发送到大小调节器。 由于 V4L2API不支持这些高级设备，因此 SoC 制造商制作了自己的定制驱动程序。 然而，V4L2 无疑是用于捕获图像的 Linux API，有时还用于特定的显示设备(这些设备是 mem2mem 设备)。

很明显，我们 n需要另一个覆盖 V4L2 限制的子系统和框架。 Linux 媒体控制器框架就是这样诞生的。

## 媒体控制器抽象模型

发现设备的内部拓扑并在运行时对其进行配置是媒体框架的目标之一。 为了实现这一点，它附带了一层抽象层。 利用媒体控制器框架，硬件设备通过由其**焊盘**经由**链路**连接的**实体**构成的有向图来表示。 这组元素组合在一起形成了所谓的**媒体设备**。 源焊盘只能生成数据。

前面的简短描述值得注意。 有三个高亮显示的词非常重要：Entity、Pad 和 LINK：

*   **实体**由`include/media/media-entity.h`中定义的`struct media_entity`实例表示。 尽管驱动程序可以直接分配实体，但该结构通常嵌入到更高级别的结构中，例如`v4l2_subdev`或`video_device`实例。
*   **焊盘**是实体与外部世界的接口。 这些是媒体实体的输入和输出可连接点。 但是，焊盘可以是输入(接收器焊盘)或输出(源焊盘)，但不能同时是两者。 数据流从一个实体的源垫流向另一个实体的汇垫。 通常，传感器或视频解码器等设备只有一个输出垫，因为它只将视频送入系统，而`/dev/videoX`垫将被建模为输入垫，因为它是流的末尾。
*   **链接**：可以通过媒体设备设置、获取和枚举这些链接。 驱动程序正常工作的应用程序负责正确设置链接，以便驱动程序了解视频数据的源和目的地。

系统上的所有实体，连同它们的焊盘和它们之间的连接链路，给出了如下图所示的**媒体设备**：

![Figure 8.1 – Media controller abstraction model ](image/Figure_8.1_B10985.jpg)

图 8.1-媒体控制器抽象模型

在上图中，**Stream**将是`/dev/videoX`Charr 设备的等价物，因为它是流的末尾。

### V4L2 设备抽象

在更高的级别上，媒体控制器使用`struct media_device`来抽象 V4L2 框架中的`struct v4l2_device`。 也就是说，`struct media_device`对于媒体控制器就像`struct v4l2_device`对于 V4L2 一样，会吞噬其他较低级别的结构。 回到`struct v4l2_device`，媒体控制器框架使用`mdev`成员来抽象该结构。 以下内容摘录如下：

```sh
struct v4l2_device {
[...]
    struct media_device *mdev;
[...]
};
```

然而，从媒体控制器的角度来看，V4L2 视频设备和子设备都被视为媒体实体，在此框架中表示为`struct media_entity`的实例。 很明显，视频设备和子设备数据结构嵌入了这种类型的成员，如以下摘录所示：

```sh
struct video_device
{
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
    struct media_intf_devnode *intf_devnode;
    struct media_pipeline pipe;
#endif
[...]
};
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
#endif
[...]
};
```

视频设备具有附加成员`intf_devnode`和`pipe`。 前者为`struct media_intf_devnode`类型，表示到视频设备节点的媒体控制器接口。 此结构使媒体控制器能够访问底层视频设备节点的信息，例如其主要和次要编号。 另一个附加成员`pipe`，wh是`struct media_pipeline`类型，存储与该视频设备的流水线相关的 ES 信息。

媒体控制器数据结构

媒体控制器框架基于几个数据结构，其中是`struct media_device`结构，它位于层次结构的顶部，定义如下：

```sh
struct media_device {
    /* dev->driver_data points to this struct. */
    struct device *dev;
    struct media_devnode *devnode;
    char model[32];
    char driver_name[32];
[...]
    char serial[40];
    u32 hw_revision;
    u64 topology_version;
    struct list_head entities;
    struct list_head pads;
    struct list_head links;
    struct list_head entity_notify;
    struct mutex graph_mutex;
[...]
    const struct media_device_ops *ops;
};
```

该结构表示高级媒体设备。 它允许轻松访问实体，并提供基本的媒体设备级支持：

*   `dev`是此媒体设备的父设备(通常是`&pci_dev`、`&usb_interface`或`&platform_device`实例)。
*   `devnode`是媒体设备节点，抽象了底层的`/dev/mediaX`。
*   `driver_name`是可选但建议使用的字段，表示介质设备驱动程序名称。 如果未设置，则默认为`dev->driver->name`。
*   `model`是此媒体设备的型号名称。 它不一定是独一无二的。
*   `serial`是应使用设备序列号设置的可选成员。 `hw_revision`是此媒体设备的硬件设备修订版。
*   `topology_version`：用于存储图形拓扑版本的单调计数器。 应在每次拓扑更改时递增。
*   `entities`是已注册实体的列表。
*   `pads`是向该媒体设备注册的焊盘列表。
*   `links`是注册到此媒体设备的链接列表。
*   `entity_notify`是向此媒体设备注册新实体时调用的通知回调列表。 驱动程序可以注册此回调以通过`media_device_unregister_entity_notify()`采取操作，并使用`media_device_register_entity_notify()`取消注册。 注册新实体时，将调用所有已注册的`media_entity_notify`回调。
*   `graph_mutex`：保护对`struct media_device`数据的访问。 例如，在使用`media_graph_*`族函数时，应该保持。
*   `ops`属于`struct media_device_ops`类型，表示此媒体设备的操作处理程序回调。

除了由媒体控制器框架操纵之外，`struct media_device`基本上用在网桥驱动程序中，在那里它被初始化和注册。 也就是说，媒体设备本身是由几个实体组成的。 这一实体概念允许媒体控制器在涉及现代和复杂的 V4L2 驱动程序时成为中心权威，这些驱动程序还可以同时支持帧缓冲器、ALSA、I2C、LIRC 和/或 DVB 设备，并用于通知用户空间什么是什么。

媒体实体表示为`struct media_entity`的实例，在`include/media/media-entity.h`中定义如下：

```sh
struct media_entity {
    struct media_gobj graph_obj;
    const char *name;
    enum media_entity_type obj_type;
    u32 function;
    unsigned long flags;
    u16 num_pads;
    u16 num_links;
    u16 num_backlinks;
    int internal_idx;
    struct media_pad *pads;
    struct list_head links;
    const struct media_entity_operations *ops;
    int stream_count;
    int use_count;
    struct media_pipeline *pipe;
[...]
};
```

就层次而言，这是媒体框架中的第二个数据结构。 前面的定义已经缩小到我们感兴趣的最低限度。 以下是该结构中各成员的含义：

*   `name`是此实体的名称。 它应该足够有意义，因为它是通过`media-ctl`工具在用户空间中使用的。
*   `type` is most of the time set by the core depending on the type of V4L2 video data structure this struct is embedded in. It is the type of the object that implements `media_entity` – for example, set with `MEDIA_ENTITY_TYPE_V4L2_SUBDEV` at the sub-device initialization by the core. This allows runtime type identification of media entities and safe casting to the correct object type using the `container_of` macro, for instance. Possible values are as follows:

    --`MEDIA_ENTITY_TYPE_BASE`：这意味着实体没有嵌入到另一个实体中。

    --`MEDIA_ENTITY_TYPE_VIDEO_DEVICE`：表示实体嵌入在`struct video_device`实例中。

    --`MEDIA_ENTITY_TYPE_V4L2_SUBDEV`：这表示实体嵌入在`struct v4l2_subdev`实例中。

*   `function` represents the entity's main function. This must be set by the driver according to the value defined in `include/uapi/linux/media.h`. The following are commonly used values while dealing with video devices:

    --`MEDIA_ENT_F_IO_V4L`：该标志表示该实体是数据流输入和/或输出实体。

    --`MEDIA_ENT_F_CAM_SENSOR`：该标志表示该实体为摄像机视频传感器实体。

    --`MEDIA_ENT_F_PROC_VIDEO_SCALER`：表示该实体可以进行视频伸缩。 这些实体至少有一个接收垫(在活动实体上)和一个源垫(它们在其中输出缩放的帧)，它们从那里接收帧(一个或多个)。

    --`MEDIA_ENT_F_PROC_VIDEO_ENCODER`：表示该实体可以压缩视频。 这些实体必须有一个接收器焊盘和至少一个源焊盘。

    --`MEDIA_ENT_F_VID_MUX`：用于视频多路复用器。 该实体具有至少两个信宿焊盘和一个信源焊盘，并且必须将从活动的信宿焊盘接收的视频帧传递到信源焊盘。

    --`MEDIA_ENT_F_VID_IF_BRIDGE`：视频接口桥。 视频接口桥实体应至少具有一个宿焊盘和一个源焊盘。 它在其接收板上从一种类型的输入视频总线(HDMI、EDP、MIPI CSI-2 等)接收视频帧，并在其源板上将其输出到另一种类型的输出视频总线(EDP、MIPI CSI-2、并行等)。

*   `flags`由驾驶员设置。 它表示此实体的标志。 可能的值是`include/uapi/linux/media.h`中定义的`MEDIA_ENT_FL_*`标志族。 以下链接可能有助于您了解可能的值：[https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html)。
*   `function`表示此实体的功能，默认情况下为`MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN`。 可能的值是`include/uapi/linux/media.h`中定义的`MEDIA_ENT_F_*`函数族。 例如，摄像机传感器子设备驱动程序必须包含`sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;`。 您可以通过此链接查找有关可能适合您的媒体实体的详细信息：https://linuxtv.org/downloads/v4l-dvb-apis/uapi/mediactl/media-types.html.
*   `num_pads`是此实体(接收器和源)的焊盘总数。
*   `num_links`是该实体的链接总数(前向、后向、启用和禁用)
*   `num_backlinks`是该实体的反向链接数。 反向链接用于帮助图形遍历，不会报告给用户空间。
*   `internal_idx`：实体注册时由媒体控制器核心分配的唯一实体编号。
*   `pads`是该实体的焊盘数组。 其大小由`num_pads`定义。
*   `links`是该实体的数据链表。 请参见`media_add_link()`。
*   `ops`属于`media_entity_operations`类型，表示此实体的操作。 这个结构将在后面讨论。
*   `stream_count`：实体的流计数。
*   `use_count`：实体的使用计数。 用于电源管理目的。
*   `pipe`是此实体所属的媒体管道。

当然，我们要引入的下一个数据结构似乎很明显是`struct media_pad`结构，它表示该框架中的一个垫子。 PAD 是实体可以通过其与其他实体交互的连接端点。 实体产生的数据(不限于视频)从实体的输出流向一个或多个实体输入。 焊盘不应与芯片边界处的物理引脚混淆。 `struct media_pad`定义如下：

```sh
struct media_pad {
[...]
    struct media_entity *entity;
    u16 index;
    unsigned long flags;
};
```

焊盘由其实体及其实体的焊盘阵列中从 0 开始的`index`标识。 在`flags`字段中，可以设置`MEDIA_PAD_FL_SINK`(表示焊盘支持接收数据)或`MEDIA_PAD_FL_SOURCE`(表示焊盘支持源数据)，但不能同时设置两者，因为焊盘不能同时接收和发送数据。

焊盘应该绑定在一起以允许数据流路径。 来自同一实体或来自不同实体的两个焊盘通过称为链路的点对点定向连接被绑定在一起。 链接在媒体框架中表示为`struct media_link`的实例，定义如下：

```sh
struct media_link {
    struct media_gobj graph_obj;
    struct list_head list;
[...]
    struct media_pad *source;
    struct media_pad *sink;
[...]
    struct media_link *reverse;
    unsigned long flags;
    bool is_backlink;
};
```

在前面的代码块中，出于可读性的考虑，只列出了几个字段。 以下是这些字段的含义：

*   `list`：用于将此链接与拥有该链接的实体或接口相关联。
*   `source`：此链接的来源。
*   `sink`：链接目标。
*   `flags`: Represents the link flags, as defined in `uapi/media.h` (with the `MEDIA_LNK_FL_*` pattern). The following are the possible values:

    --`MEDIA_LNK_FL_ENABLED`：该标志表示链路处于启用状态，可以进行数据传输。

    --`MEDIA_LNK_FL_IMMUTABLE`：该标志表示运行时不能修改链路启用状态。

    --`MEDIA_LNK_FL_DYNAMIC`：该标志表示可以在流媒体过程中修改链路状态。 但是，此标志由驱动程序设置，但对于应用程序是只读的。

*   `reverse`：指向焊盘到焊盘链接的反向链接(实际上是反向链接)的指针。
*   `is_backlink`：指示此链接是否为反向链接。

每个实体都有一个列表，该列表指向始发于或指向其任何焊盘的所有链接。 因此，给定链接被存储两次，一次在源实体中，一次在目标实体中。 当您想要将`A`链接到`B`时，实际上会创建两条链接：

*   一个对应于预期的链接；链接存储在源实体中，并且源实体的`num_links`字段递增。
*   另一个存储在宿实体中。 接收器和源保持不变，不同之处在于将`is_backlink`成员设置为`true`。 这与您创建的链接相反。 接收器实体的`num_backlinks`和`num_links`字段将递增。 然后将此反向链接分配给原始链接的`reverse`成员。

最后，`mdev->topology_version`成员递增两次。 这种链接和反向链接的原理允许媒体控制器计算实体，以及实体之间的 p可能链接和当前链接，如下图所示：

![Figure 8.2 – Media controller entity description ](image/Figure_8.2_B10985.jpg)

图 8.2-媒体控制器实体描述

在上图中，如果我们考虑**Entity-1**和**Entity-2**，那么**链路**和**反向链路**本质上是相同的，只是**链路**属于**Entity-1**，**反向链路**属于**Entity-2**。 然后，您应该将反向链路视为备用链路。 我们可以看到，实体既可以是接收器，也可以是源，或者两者兼而有之。

我们到目前为止介绍的数据结构可能会让媒体控制器框架听起来有点吓人。 然而，这些数据结构中的大多数将由框架通过其提供的 API 在幕后管理。 也就是说，可以在内核源代码的`Documentation/media-framework.txt`中找到完整框架的文档。

## 在驱动程序中集成媒体控制器支持

当需要介质控制器的支持时，V4L2 驱动器必须首先使用`media_device_init()`函数在`struct v4l2_device`内初始化`struct media_device`。 每个实体驱动程序必须使用`media_entity_pads_init()`函数初始化其实体(实际上是`video_device->entity`或`v4l2_subdev->entity`)及其焊盘阵列，如果需要，使用`media_create_pad_link()`创建焊盘到焊盘的链接。 在此之后，可以注册实体。 但是，V4L2 框架将通过`v4l2_device_register_subdev()`或`video_register_device()`方法为您处理此注册。 在这两种情况下，调用的底层注册函数都是`media_device_register_entity()`。

作为最后一步，必须使用`media_device_register()`注册媒体设备。 值得一提的是，媒体设备注册应该推迟到将来，当我们确定每个子设备(或者我应该说实体)都已注册并准备好使用时。 在根通知器的`.complete`回调中注册媒体设备绝对是一种KES 意义。

### 初始化和注册焊盘和实体

使用相同的函数来初始化实体和其焊盘阵列：

```sh
int media_entity_pads_init(struct media_entity *entity,
                         u16 num_pads, struct media_pad *pads);
```

在前面的原型中，`*entity`是要注册的焊盘所属的实体，`*pads`是要注册的焊盘阵列，`num_pads`是阵列中应该注册的实体的数量。 在调用以下命令之前，驱动程序必须已设置焊盘阵列中每个焊盘的类型：

```sh
struct mydrv_state_struct {
    struct v4l2_subdev sd;
    struct media_pad pad;
[...]
};
static int my_probe(struct i2c_client *client,
                     const struct i2c_device_id *id)
{
    struct v4l2_subdev *sd;
    struct mydrv_state_struct *my_struct;
[...]
    sd = &my_struct->sd;
    my_struct->pad.flags = MEDIA_PAD_FL_SINK | 
                            MEDIA_PAD_FL_MUST_CONNECT;
    ret = media_entity_pads_init(&sd->entity, 1,                                  &my_struct->pad);
[...]
    return 0;
}
```

需要注销实体的驱动程序必须对要注销的实体调用以下函数：

```sh
media_device_unregister_entity(struct media_entity *entity);
```

然后，为了让驱动程序释放与实体关联的资源，它应该调用以下代码：

```sh
media_entity_cleanup(struct media_entity *entity);
```

当媒体设备取消注册时，其所有实体将自动取消注册。 然后，不需要注销手动实体。

### 媒体实体运营

实体可以被提供个与链接相关的回调，使得媒体框架可以在链接创建和验证时调用这些回调：

```sh
struct media_entity_operations {
    int (*get_fwnode_pad)(struct fwnode_endpoint *endpoint);
    int (*link_setup)(struct media_entity *entity,
                      const struct media_pad *local,
                      const struct media_pad *remote,                       u32 flags);
    int (*link_validate)(struct media_link *link);
};
```

提供上述结构是可选的。 但是，可能存在需要在链路设置或链路验证时执行或检查附加内容的情况。 在这种情况下，请注意以下说明：

*   `get_fwnode_pad`：根据 fwnode 端点或错误时的负值返回焊盘编号。 此操作可用于将 fwnode 映射到媒体垫编号(可选)。
*   `link_setup`：通知实体链接更改。 此操作可能返回错误，在这种情况下，链路设置将被取消(可选)。
*   `link_validate`：从实体的角度返回链接是否有效。 `media_pipeline_start()`函数通过调用此操作来验证此实体所涉及的所有链接。 此成员是可选的。 但是，如果尚未设置，则`v4l2_subdev_link_validate_default`将使用d 作为默认回调函数，以确保源焊盘和宿焊盘的 WID、高度和媒体总线像素代码一致；否则，将返回错误。

### 媒体总线的概念

媒体框架的主要目的是配置和控制管道及其实体。 摄像机和解码器等视频子设备通过专用总线连接到视频桥或其他子设备。 数据正以各种格式在这些总线上传输。 也就是说，为了让两个实体真正交换数据，它们的 PAD 配置需要相同。

应用程序负责在整个管道上配置一致的参数，并确保连接的焊盘具有兼容的格式。 在`VIDIOC_STREAMON`时间检查管道中是否有不匹配的格式。

驱动程序负责根据所请求的(来自用户的)格式在流水线输入和/或输出处应用视频流水线中的每个块的配置。

以下面的简单数据流`sensor ---> CPHY ---> csi ---> isp ---> stream`为例。

为了使媒体框架能够在流式传输数据之前配置总线，驱动程序需要为`struct v4l2_subdev_pad_ops`结构中的媒体总线属性提供一些垫级设置器和获取器。 如果子设备驱动程序打算处理视频并与媒体框架集成，则该结构实现必须定义的 PAD 级操作。 以下是其定义：

```sh
struct v4l2_subdev_pad_ops {
[...]
    int (*enum_mbus_code)(struct v4l2_subdev *sd,
                      struct v4l2_subdev_pad_config *cfg,
                      struct v4l2_subdev_mbus_code_enum *code);
    int (*enum_frame_size)(struct v4l2_subdev *sd,
                      struct v4l2_subdev_pad_config *cfg,
                      struct v4l2_subdev_frame_size_enum *fse);
    int (*enum_frame_interval)(struct v4l2_subdev *sd,
                  struct v4l2_subdev_pad_config *cfg,
                  struct v4l2_subdev_frame_interval_enum *fie); 
    int (*get_fmt)(struct v4l2_subdev *sd,
                   struct v4l2_subdev_pad_config *cfg,
                   struct v4l2_subdev_format *format);
    int (*set_fmt)(struct v4l2_subdev *sd,
                   struct v4l2_subdev_pad_config *cfg,
                   struct v4l2_subdev_format *format);
#ifdef CONFIG_MEDIA_CONTROLLER
    int (*link_validate)(struct v4l2_subdev *sd,
                         struct media_link *link,
                         struct v4l2_subdev_format *source_fmt,
                         struct v4l2_subdev_format *sink_fmt);
#endif /* CONFIG_MEDIA_CONTROLLER */
[...]
};
```

以下是该结构中各成员的含义：

*   `init_cfg`：将焊盘配置初始化为默认值。 这是初始化`cfg->try_fmt`的正确位置，可以通过`v4l2_subdev_get_try_format()`获取。
*   `enum_mbus_code`：`VIDIOC_SUBDEV_ENUM_MBUS_CODE`ioctl 处理程序代码的回调。 枚举当前支持的数据格式。 此回调处理像素格式枚举。
*   `enum_frame_size`：`VIDIOC_SUBDEV_ENUM_FRAME_SIZE`ioctl 处理程序代码的回调。 枚举子设备支持的帧(图像)大小。 枚举当前支持的解决方案。
*   `enum_frame_interval`：`VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL`ioctl 处理程序代码的回调。
*   `get_fmt`：`VIDIOC_SUBDEV_G_FMT`ioctl 处理程序代码的回调。
*   `set_fmt`：`VIDIOC_SUBDEV_S_FMT`ioctl 处理程序代码的回调。 设置输出数据格式和分辨率。
*   `get_selection`：`VIDIOC_SUBDEV_G_SELECTION`ioctl 处理程序代码的回调。
*   `set_selection`：`VIDIOC_SUBDEV_S_SELECTION`ioctl 处理程序代码的回调。
*   `link_validate`：由媒体控制器代码用来检查属于管道的链接是否可以用于流。

所有这些回调共有的参数是`cfg`，它属于`struct v4l2_subdev_pad_config`类型，用于存储子设备焊盘信息。 此结构在`include/uapi/linux/v4l2-mediabus.h`中定义如下：

```sh
struct v4l2_subdev_pad_config {
    struct v4l2_mbus_framefmt try_fmt;
    struct v4l2_rect try_crop;
[...]
};
```

在前面的代码块中，我们感兴趣的主要字段是`try_fmt`，它属于`struct v4l2_mbus_framefmt`类型。 该数据结构用于描述 PAD 级媒体总线格式，定义如下：

```sh
struct v4l2_subdev_format {
    __u32 which;
    __u32 pad;
    struct v4l2_mbus_framefmt format;
[...]
};
```

在前面的结构中，`which`是格式类型(Try 或 Active)，`pad`是媒体 API 报告的焊盘号。 此字段由用户空间设置。 `format`表示总线上的帧格式。 这里的术语`format`表示媒体总线数据格式、帧宽度和帧高度的组合。 它属于`struct v4l2_mbus_framefmt`类型，其轮次定义如下：

```sh
struct v4l2_mbus_framefmt {
    __u32	width;
    __u32	height;
    __u32	code;
    __u32	field;
    __u32	colorspace;
[...]
};
```

在前面的总线帧格式数据结构中，只列出了与我们相关的字段。 `width`和`height`分别表示图像的宽度和高度。 `code`来自`enum v4l2_mbus_pixelcode`，表示数据格式码。 `field`表示使用的隔行扫描类型，应来自`enum v4l2_field`，`colorspace`表示来自`enum v4l2_colorspace`的数据的色彩空间。

现在，让我们更多地关注`get_fmt`和`set_fmt`回调。 它们分别获取和设置子设备焊盘上的数据格式。 这些 IOCTL 处理程序用于在图像流水线中的特定子设备焊盘处协商帧格式。 要设置当前格式化应用程序，请将`struct v4l2_subdev_format`的`.pad`字段设置为媒体 API 报告的所需焊盘编号，并将`which`字段(从`enum v4l2_subdev_format_whence`)设置为`V4L2_SUBDEV_FORMAT_TRY`或`V4L2_SUBDEV_FORMAT_ACTIVE`，并发出带有指向此结构的指针的`VIDIOC_SUBDEV_S_FMT`ioctl。 这个 ioctl 最终调用了`v4l2_subdev_pad_ops->set_fmt`回调。 如果将`which`设置为`V4L2_SUBDEV_FORMAT_TRY`，则驱动程序应使用参数中给出的`try`格式的值设置请求焊盘配置的`.try_fmt`字段。 但是，如果将`which`设置为`V4L2_SUBDEV_FORMAT_ACTIVE`，则驱动程序必须将配置应用到设备。 在这种情况下，通常将请求的“活动”格式存储在驱动程序状态结构中，并在管道启动流时将其应用于底层设备。 这样，将格式配置实际应用于设备的正确位置是在流开始时调用的回调中，例如`v4l2_subdev_video_ops.s_stream`。 以下是来自 rcar CSI驱动程序的示例：

```sh
static int rcsi2_set_pad_format(struct v4l2_subdev *sd,
                            struct v4l2_subdev_pad_config *cfg,
                            struct v4l2_subdev_format *format)
{
    struct v4l2_mbus_framefmt *framefmt;
    /* retrieve the private data structure */
    struct rcar_csi2 *priv = sd_to_csi2(sd);
    [...]
    /* Store the requested format so that it can be applied to
     * the device when the pipeline starts
     */
    if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
        priv->mf = format->format;
    } else { /* V4L2_SUBDEV_FORMAT_TRY */ 
        /* set the .try_fmt of this pad config with the
         * value of the requested "try" format
         */
        framefmt = v4l2_subdev_get_try_format(sd, cfg, 0);
        *framefmt = format->format;
        /* driver is free to update any format->* field */
        [...]
    }
    return 0;
}
```

另外，请注意，驱动程序可以自由地将请求格式的值更改为它实际支持的值。 然后由应用程序检查它，并根据驱动程序授予的格式调整其逻辑。 修改这些`try`格式将保持设备状态不变。

另一方面，当涉及到检索当前格式时，应用程序应该执行与前面相同的操作，并发出`VIDIOC_SUBDEV_G_FMT`ioctl。 此 ioctl 将最终调用`v4l2_subdev_pad_ops->get_fmt`回调。 驱动程序使用当前活动的格式值或最近存储的`try`格式(大部分时间在驱动程序状态结构中)填充`format`字段的成员：

```sh
static int rcsi2_get_pad_format(struct v4l2_subdev *sd,
                            struct v4l2_subdev_pad_config *cfg, 
                            struct v4l2_subdev_format *format)
{
    struct rcar_csi2 *priv = sd_to_csi2(sd);
    if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)
        format->format = priv->mf;
    else
      format->format = *v4l2_subdev_get_try_format(sd, cfg, 0);
    return 0;
}
```

显然，在第一次将焊盘配置的`.try_fmt`字段传递给`get`回调之前，它应该已经被初始化，而`v4l2_subdev_pad_ops.init_cfg`回调是进行此初始化的正确位置，如下例所示：

```sh
/*
 * Initializes the TRY format to the ACTIVE format on all pads
 * of a subdev. Can be used as the .init_cfg pad operation.
 */
int imx_media_init_cfg(struct v4l2_subdev *sd,
                        struct v4l2_subdev_pad_config *cfg)
{
    struct v4l2_mbus_framefmt *mf_try;
    struct v4l2_subdev_format format;
    unsigned int pad;
    int ret;
    for (pad = 0; pad < sd->entity.num_pads; pad++) {
        memset(&format, 0, sizeof(format));
       format.pad = pad;
       format.which = V4L2_SUBDEV_FORMAT_ACTIVE;
       ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &format);
       if (ret)
            continue;
        mf_try = v4l2_subdev_get_try_format(sd, cfg, pad);
        *mf_try = format.format;
    }
    return 0;
}
```

重要音符

支持的格式列表可以在内核源代码的`include/uapi/linux/videodev2.h`中找到，它们的部分文档可以在以下链接中找到：[https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html)。

现在我们已经熟悉了媒体的概念，我们可以学习 how，最终通过使用适当的 API 注册媒体设备来使其成为系统的一部分。

### 注册媒体设备

驱动程序通过`media_device_register()`宏调用`__media_device_register()`来注册媒体设备实例，并通过调用`media_device_unregister()`来注销它们。 注册成功后，将创建名为`media[0-9] +`的字符设备。 设备主号和次号是动态的。 `media_device_register()`接受指向要注册的媒体设备的指针，如果成功则返回`0`，如果出错则返回负错误代码。

如前所述，最好从根通知器的`.complete`回调中在中注册媒体设备，以确保实际的媒体设备只有在其所有实体都被探测之后才会注册。 以下摘录自 TI OMAP3 ISP 媒体驱动程序(完整代码可在内核源代码的`drivers/media/platform/omap3isp/isp.c`中找到)：

```sh
static int isp_subdev_notifier_complete(
                             struct v4l2_async_notifier *async)
{
    struct isp_device *isp =
              container_of(async, struct isp_device, notifier);
[...]
    return media_device_register(&isp->media_dev);
}
static const
struct v4l2_async_notifier_operations isp_subdev_notifier_ops = {
    .complete = isp_subdev_notifier_complete,
};
```

前面的代码显示了如何通过`media_device_register()`方法利用根通知器的`.complete`回调来注册最终的媒体设备。

既然媒体设备是系统的一部分，那么现在是利用它的时候了，特别是从用户空间。 现在让我们看看如何从命令行控制媒体设备并与之交互。

## 来自用户空间的媒体控制器

虽然仍然是流接口，但`/dev/video0`不再是默认的管道中心，因为它被`/dev/mediaX`包装。 流水线可以通过媒体节点(`/dev/media*`)来配置，并且可以通过视频节点(`/dev/video*`)来执行控制操作，例如流的开/关()。

### 使用 media-ctl(v4l-utils 包)

来自`v4l-utils`包的`media-ctl`应用程序是一个用户空间应用程序，它使用 Linux 媒体控制器 API 来配置管道。 以下是要与其配合使用的标志：

*   `--device <dev>`指定媒体设备(默认情况下为`/dev/media0`)。
*   `--entity <name>`打印与给定实体关联的设备名称。
*   `--set-v4l2 <v4l2>`提供要设置的格式的逗号分隔列表。
*   `--get-v4l2 <pad>`在给定焊盘上打印活动格式。
*   `--set-dv <pad>`在给定焊盘上配置 DV 计时。
*   `--interactive`交互修改链接。
*   `--links <linux>`提供要设置的链接描述符列表(以逗号分隔)。
*   `--known-mbus-fmts`列出已知格式及其数值。
*   `--print-topology`打印设备拓扑或简称`-p`。
*   `--reset`将所有链接重置为非活动。

也就是说，硬件媒体管道的基本配置步骤如下：

1.  使用`media-ctl --reset`重置所有链接。
2.  使用`media-ctl --links`配置链路。
3.  用`media-ctl --set-v4l2`配置焊盘格式。
4.  使用`/dev/video*`设备上的`v4l2-ctl`捕获帧配置子设备属性。

使用`media-ctl --links`将实体源焊盘链接到实体宿焊盘应遵循以下模式：

```sh
media-ctl --links\
"<entitya>:<srcpadn> -> <entityb>:<sinkpadn>[<flags>]
```

在前面的行中，`flags`可以是`0`(非活动)或`1`(活动)。 此外，要查看媒体总线的当前设置，请使用以下命令：

```sh
$ media-ctl --print-topology
```

在某些系统上，介质设备`0`可能不是默认设备，在这种情况下，您应该使用以下设备：

```sh
$ media-ctl --device /dev/mediaN --print-topology
```

前面的命令将打印与指定媒体设备关联的媒体拓扑。

请注意，`--print-topology`只是将媒体拓扑以 ASCII 格式转储到控制台。 但是，通过生成其`dot`表示，将该表示更改为更人性化的图形图像，可以更好地表示此拓扑。 以下是要使用的命令：

```sh
$ media-ctl --print-dot > graph.dot
$ dot -Tpng graph.dot > graph.png
```

例如，为了设置媒体管道，已在 UDOO 四元板上运行以下命令。 主板附带 i.MX6 四核和插入 MIPI CSI-2 接口的 OV5640 摄像头：

```sh
# media-ctl -l "'ov5640 2-003c':0 -> 'imx6-mipi-csi2':0[1]"
# media-ctl -l "'imx6-mipi-csi2':2 -> 'ipu1_csi1':0[1]"
# media-ctl -l "'ipu1_csi1':1 -> 'ipu1_ic_prp':0[1]"
# media-ctl -l "'ipu1_ic_prp':1 -> 'ipu1_ic_prpenc':0[1]"
# media-ctl -l "'ipu1_ic_prpenc':1 -> 'ipu1_ic_prpenc capture':0[1]" 
```

下图表示前面的设置：

![Figure 8.3 – Graph representation of a media device ](image/Figure_8.3_B10985.jpg)

图 8.3-媒体设备的图形表示

如您所见，它有助于可视化硬件组件。 以下是对这些生成的图像的描述：

*   虚线显示个可能的连接。 您可以使用这些信息来确定可能性。
*   实线表示活动连接。
*   绿色方框显示媒体实体。
*   黄色方框显示**Video4Linux**(**V4L**)端点。

之后，您可以看到实线与前面完成的设置完全对应。 我们有五条实线，对应于用于配置介质设备的命令数量。 以下是这些命令的含义：

*   `media-ctl -l "'ov5640 2-003c':0 -> 'imx6-mipi-csi2':0[1]"`表示将摄像机传感器(`'ov5640 2-003c':0`)的输出焊盘编号`0`链接到 MIPI CSI-2 输入焊盘编号`0`(`'imx6-mipi-csi2':0`)，并将该链接设置为活动(`[1]`)。
*   `media-ctl -l "'imx6-mipi-csi2':2 -> 'ipu1_csi1':0[1]"`表示将 MIPI CSI-2 实体(`'imx6-mipi-csi2':2`)的输出焊盘编号`2`链接到 IPU 捕获传感器接口#1(`' ipu1_csi1':0`)的输入焊盘编号`0`，并将该链接设置为活动(`[1]`)。
*   相同的解码规则适用于其他命令行，直到最后一个命令行`media-ctl -l "'ipu1_ic_prpenc':1 -> 'ipu1_ic_prpenc capture':0[1]"`，这意味着将`ipu1`的图像转换器预处理编码实体(`'ipu1_ic_prpenc':1`)的输出焊盘号`1`链接到捕获接口输入焊盘号`0`，并将该链接设置为活动。

为了理解实体、链接和焊盘的概念，请毫不犹豫地返回图像并多次阅读这些描述。

重要音符

如果您的目标上没有安装`dot`软件包，您可以将`.dot`文件下载到您的主机上(假设主机上安装了该软件包)，并将其转换为映像。

#### 带有 OV2680 示例的 WaRP7

WaRP7 是基于i.MX7 的电路板，与 i.MX5/6 系列不同，它不包含 IPU。 因此，执行捕获帧操作或操作的功能较少。 I.MX7 图像采集链由三个单元组成：摄像机审查接口、视频多路复用器和 MIPI CSI-2 接收器，它们代表媒体实体，如下所述：

*   `imx7-mipi-csi2`：这是 MIPI CSI-2 接收器实体。 它有一个接收板，用于接收来自 MIPI CSI-2 相机传感器的像素数据。 它有一个源垫，对应于虚拟通道`0`。
*   `csi_mux`：这是视频多路复用器。 它有两个接收器垫可供选择，无论是带并行接口的摄像头传感器还是 MIPI CSI-2 虚拟通道`0`。 它只有一个源板，路由到 CSI。
*   `csi`：CSI 允许芯片直接连接到外部 CMOS 图像传感器。 CSI 可以直接与并行和 MIPI CSI-2 总线接口。 它具有 256 x 64 FIFO 用于存储接收到的图像像素数据，嵌入式 DMA 控制器用于通过 AHB 总线从 FIFO 传输数据。 该实体有一个接收来自`csi_mux`实体的接收板和一个直接将视频帧路由到内存缓冲区的单一源板。 此焊盘被路由到捕获设备节点：

```sh
                                      |\
MIPI Camera Input --> MIPI CSI-2 -- > | \
                                      |  \
                                      | M |
                                      | U | --> CSI --> Capture
                                      | X |
                                      |  /
Parallel Camera Input --------------> | /
                                      |/
```

在该平台上，OV2680 MIPI CSI-2 模块连接到内部 MIPI CSI-2 接收器。 以下示例配置输出为 800 x 600 的 BGGR 10 位拜耳格式的视频捕获管道：

```sh
# Setup links
media-ctl --reset
media-ctl -l "'ov2680 1-0036':0 -> 'imx7-mipi-csis.0':0[1]"
media-ctl -l "'imx7-mipi-csis.0':1 -> 'csi_mux':1[1]"
media-ctl -l "'csi_mux':2 -> 'csi':0[1]"
media-ctl -l "'csi':1 -> 'csi capture':0[1]"
```

前面的几行可以合并到一个命令中，如下所示：

```sh
media-ctl -r -l '"ov2680 1-0036":0->"imx7-mipi-csis.0":0[1], \
                 "imx7-mipi-csis.0":1 ->"csi_mux":1[1], \
                 "csi_mux":2->"csi":0[1], \
                 "csi":1->"csi capture":0[1]'
```

在前面的命令中，请注意以下事项：

*   `-r`表示将所有链接重置为非活动。
*   `-l`在逗号分隔的链接描述符列表中设置链接。
*   `"ov2680 1-0036":0->"imx7-mipi-csis.0":0[1]`将摄像机传感器的输出焊盘编号`0`链接到 MIPI CSI-2 输入焊盘编号`0`，并将此链接设置为激活。
*   `"csi_mux":2->"csi":0[1]`将`csi_mux`的输出焊盘编号`2`链接到`csi`输入焊盘编号`0`，并将该链接设置为激活。
*   `"csi":1->"csi capture":0[1]`链接`csi`的输出焊盘编号`1`以捕获接口的输入焊盘编号`0`，并将此链接设置为活动。

为了在每个焊盘上配置格式，我们可以使用以下命令：

```sh
# Configure pads for pipeline
media-ctl -V "'ov2680 1-0036':0 [fmt:SBGGR10_1X10/800x600 field:none]" 
media-ctl -V "'csi_mux':1 [fmt:SBGGR10_1X10/800x600 field:none]"
media-ctl -V "'csi_mux':2 [fmt:SBGGR10_1X10/800x600 field:none]"
media-ctl \
      -V "'imx7-mipi-csis.0':0 [fmt:SBGGR10_1X10/800x600 field:none]"
media-ctl -V "'csi':0 [fmt:SBGGR10_1X10/800x600 field:none]"
```

同样，可以将前面的命令行合并到单个命令中，如下所示：

```sh
media-ctl \
    -f '"ov2680 1-0036":0 [SGRBG10 800x600 (32,20)/800x600], \
        "csi_mux":1 [SGRBG10 800x600], \
        "csi_mux":2 [SGRBG10 800x600], \
        "mx7-mipi-csis.0":2 [SGRBG10 800x600], \
        "imx7-mipi-csi.0":0 [SGRBG10 800x600], \
        "csi":0 [UYVY 800x600]'
```

前面的命令行可以翻译如下：

*   `-f`：将焊盘格式设置为逗号分隔的格式描述符列表。
*   `"ov2680 1-0036":0 [SGRBG10 800x600 (32,20)/800x600]`：将相机传感器垫编号`0`格式设置为分辨率(拍摄大小)为 800 x 600 的原始拜耳 10 位图像。 通过指定裁剪矩形设置允许的最大传感器窗口宽度。
*   `"csi_mux":1 [SGRBG10 800x600]`：将`csi_mux`焊盘编号`1`格式设置为分辨率为 800 x 600 的原始拜耳 10 位图像。
*   `"csi_mux":2 [SGRBG10 800x600]`：将`csi_mux`焊盘编号`2`格式设置为分辨率为 800 x 600 的原始拜耳 10 位图像。
*   `"csi":0 [UYVY 800x600]`：将`csi`焊盘编号`0`格式设置为分辨率为 800 x 600 的`YUV4:2:2`图像。

`video_mux`、`csi`和`mipi-csi-2`都是 SoC 的一部分，因此它们在供应商`dtsi`文件(即内核源代码中的`arch/arm/boot/dts/imx7s.dtsi`)中声明。 `video_mux`声明如下：

```sh
gpr: iomuxc-gpr@30340000 {
[...]
    video_mux: csi-mux {
        compatible = "video-mux";
        mux-controls = <&mux 0>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
        port@0 {
            reg = <0>;
        };
        port@1 {
            reg = <1>;
            csi_mux_from_mipi_vc0: endpoint {
                remote-endpoint = <&mipi_vc0_to_csi_mux>;
            };
        };
        port@2 {
            reg = <2>;
           csi_mux_to_csi: endpoint {
               remote-endpoint = <&csi_from_csi_mux>;
           };
        };
    }; 
};
```

在前面的代码块中，我们有三个端口，其中端口`1`是`2`连接到远程端点。 `csi`和`mipi-csi-2`声明如下：

```sh
mipi_csi: mipi-csi@30750000 {
    compatible = "fsl,imx7-mipi-csi2";
[...]
    status = "disabled";
    port@0 {
        reg = <0>;
    };
    port@1 {
        reg = <1>;
        mipi_vc0_to_csi_mux: endpoint {
            remote-endpoint = <&csi_mux_from_mipi_vc0>;
        };
    };
};
[...]
csi: csi@30710000 {
    compatible = "fsl,imx7-csi"; [...]
    status = "disabled";
    port {
        csi_from_csi_mux: endpoint {
            remote-endpoint = <&csi_mux_to_csi>;
        };
    };
};
```

从`csi`和`mipi-csi-2`节点，我们可以看到它们如何链接到`video_mux`节点中的远程端口。

重要音符

关于`video_mux`绑定的更多信息可以在内核源代码中的`Documentation/devicetree/bindings/media/video-mux.txt`中找到。

但是，大多数供应商声明的节点在默认情况下是禁用的，需要从电路板文件(实际上是`dts`文件)中启用。 这就是在下面的代码块中执行的操作。 此外，摄像头传感器是电路板的一部分，而不是 SoC。 因此，它需要在 board`dts`文件中声明，该文件在内核源代码中为`arch/arm/boot/dts/imx7s-warp.dts`。 以下内容摘录如下：

```sh
&video_mux {
    status = "okay";
};
&mipi_csi {
    clock-frequency = <166000000>;
    fsl,csis-hs-settle = <3>;
    status = "okay";
    port@0 {
        reg = <0>;
        mipi_from_sensor: endpoint {
            remote-endpoint = <&ov2680_to_mipi>;
            data-lanes = <1>;
        };
    };
};
&i2c2 {
    [...]
    status = "okay";
    ov2680: camera@36 {
        compatible = "ovti,ov2680";
        [...]
    port {
        ov2680_to_mipi: endpoint {
            remote-endpoint = <&mipi_from_sensor>;
            clock-lanes = <0>;
            data-lanes = <1>;
        };
    };
};
```

重要音符

在内核源代码的`Documentation/devicetree/bindings/media/imx7-csi.txt`和`Documentation/devicetree/bindings/media/imx7-mipi-csi2.txt`中都可以找到有关 i.MX7 实体绑定的更多信息。

在此之后，可以开始流。 `v4l2-ctl`工具可用于选择传感器支持的任何分辨率：

```sh
root@imx7s-warp:~# media-ctl -p
Media controller API version 4.17.0
Media device information
------------------------
driver          imx7-csi
model           imx-media
serial
bus info
hw revision     0x0
driver version  4.17.0
Device topology
- entity 1: csi (2 pads, 2 links)
            type V4L2 subdev subtype Unknown flags 0
            device node name /dev/v4l-subdev0
        pad0: Sink
                [fmt:SBGGR10_1X10/800x600 field:none]
                <- "csi-mux":2 [ENABLED]
        pad1: Source
                [fmt:SBGGR10_1X10/800x600 field:none]
                -> "csi capture":0 [ENABLED]
- entity 4: csi capture (1 pad, 1 link)
            type Node subtype V4L flags 0
            device node name /dev/video0
        pad0: Sink
                <- "csi":1 [ENABLED]
- entity 10: csi-mux (3 pads, 2 links)
             type V4L2 subdev subtype Unknown flags 0
             device node name /dev/v4l-subdev1
        pad0: Sink
                [fmt:unknown/0x0]
        pad1: Sink
               [fmt:unknown/800x600 field:none]
                <- "imx7-mipi-csis.0":1 [ENABLED]
        pad2: Source
                [fmt:unknown/800x600 field:none]
                -> "csi":0 [ENABLED]
- entity 14: imx7-mipi-csis.0 (2 pads, 2 links)
             type V4L2 subdev subtype Unknown flags 0
             device node name /dev/v4l-subdev2
        pad0: Sink
                [fmt:SBGGR10_1X10/800x600 field:none]
                <- "ov2680 1-0036":0 [ENABLED]
        pad1: Source
                [fmt:SBGGR10_1X10/800x600 field:none]
                -> "csi-mux":1 [ENABLED]
- entity 17: ov2680 1-0036 (1 pad, 1 link)
             type V4L2 subdev subtype Sensor flags 0
             device node name /dev/v4l-subdev3
        pad0: Source
                [fmt:SBGGR10_1X10/800x600 field:none]
                -> "imx7-mipi-csis.0":0 [ENABLED]
```

按照数据流从左到右的顺序，我们可以这样解读前面的控制台日志：

*   `-> "imx7-mipi-csis.0":0 [ENABLED]`：此源焊盘将数据馈送到其右侧的实体，即`"imx7-mipi-csis.0":0`。
*   `<- "ov2680 1-0036":0 [ENABLED]`：此接收板由其左侧的实体(即`"ov2680 1-0036":0`)馈送(即，从其查询数据)。

我们现在已经完成了媒体控制器框架的所有方面。 我们从它的体系结构开始，然后描述了构成它的数据结构，然后详细了解了它的 API。 最后，我们从用户空间使用它，以便利用模式媒体管道。

# 摘要

在本章中，我们介绍了 V4L2 异步接口，该接口简化了视频桥和子设备驱动程序探测。 这对于本质上异步和无序的设备注册系统非常有用，例如扁平化设备树驱动程序探测。 此外，我们还处理了媒体控制器框架，该框架允许利用 V4L2 视频管道。 到目前为止，我们看到的是内核空间。

在下一章中，我们将了解如何从用户空间处理 V4L2 设备，从而利用其设备驱动程序提供的功能。