# *第 4 章*：冲击公共时钟框架

从一开始，嵌入式系统总是需要时钟信号来协调其内部工作，以进行同步或电源管理(例如，在设备处于活动状态时启用时钟或根据某些标准(如系统负载)调整时钟)。 因此，Linux 一直都有时钟框架。 只有编程接口声明支持系统时钟树的软件管理，每个平台都必须实现此 API。 不同的**片上系统**(**SoCS**)有自己的实现。 这在一段时间内还不错，但人们很快就发现他们的硬件实现非常相似。 代码也变得杂乱和冗余，这意味着必须使用与平台相关的 API 来获取/设置时钟。

这是一个相当不舒服的情况。 然后，出现了**公共时钟框架(CCF)**，允许软件以独立于硬件的方式管理系统上可用的时钟。 CCF 是一个接口，允许我们控制各种时钟设备(大多数情况下，这些设备都嵌入在 SoC 中)，并提供可用于控制它们的统一 API(启用/禁用、获取/设置速率、选通/取消选通等)。 在本章中，时钟的概念不是指**实时时钟**(**RTCS**)，也不是指计时设备，后者是内核中有自己的子系统的其他类型的设备。

CCF 背后的主要思想是统一和抽象分布在不同 SoC 时钟驱动器中的相似代码。 这种标准化方法以以下方式引入了时钟提供者和时钟消费者的概念：

*   提供者是与框架连接并提供对硬件的访问的 Linux 内核驱动程序，从而根据 SoC 数据表提供(使这些对消费者可用)时钟树(现在人们可以借助它来转储整个时钟树)。
*   使用者是通过公共 API 访问框架的 Linux 内核驱动程序或子系统。
*   也就是说，驱动程序既可以是提供者，也可以是使用者(然后它将消耗它提供的一个或多个时钟，或者其他人提供的一个或多个时钟)。

在本章中，我们将介绍 CCF 数据结构，然后在介绍消费者 API 之前重点编写时钟提供程序驱动程序(与时钟类型无关)。 我们将通过以下主题来实现这一点：

*   CCF 数据结构和接口
*   编写时钟提供程序设备驱动程序
*   时钟使用器设备驱动程序和 API

# 技术要求

以下是本章的技术要求：

*   具备高级计算机体系结构知识和 C 编程技能
*   Linux 内核 v4.19.X 源代码，可从[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获得

# CCF 数据结构和接口

在以前的内核时代，每个平台都必须实现一个在内核中定义的基本 API(抓取/释放时钟、设置/获取速率、启用/禁用时钟等)，以供消费者驱动程序使用。 由于这些特定 API 的实现是由每台机器的代码完成的，因此在每台机器目录中都会产生一个类似的文件，并具有类似的逻辑来实现时钟提供程序功能。 这有几个缺点，其中有很多冗余代码。 后来，内核以时钟提供程序(`drivers/clk/clk.c`)的形式抽象了这个公共代码，这就是我们现在所说的 CCF 核心。

在使用 CCF 之前，需要通过`CONFIG_COMMON_CLK`选项将其支持拉入内核。 CCF 本身分为两部分：

*   **公共时钟框架核心**：这是框架的核心，不应该在您添加新驱动程序并提供`struct clk`的公共定义时进行修改，它统一了框架级代码和过去在各种平台上重复的传统平台相关实现。 这一半还允许我们在必须由每个时钟提供者提供的`struct clk_ops`之上包装使用者接口(也称为**CLK 实现**)。
*   **特定于硬件的一半**：它针对必须为每个新硬件时钟写入的时钟设备。 这需要驱动程序提供`struct clk_ops`，该回调对应于用于让我们在底层硬件上操作的回调(这些回调由时钟的核心实现调用)，以及包装和抽象时钟硬件的相应的特定于硬件的结构。

两半通过`struct clk_hw`结构连接在一起。 这种结构有助于我们实现自己的硬件时钟类型。 在本章中，这称为`struct clk_foo`。 由于`struct clk_hw`也指向`struct clk`内，因此它允许在两半之间导航。

现在，我们可以介绍 CCF 数据结构。 CCF 构建在常见的异构数据结构(在`include/linux/clk-provider.h`中)之上，这些数据结构有助于尽可能保持该框架的通用性。 这些资料如下：

*   `struct clk_hw`：此结构抽象硬件时钟线，仅在提供程序代码中使用。 它将前面介绍的两个部分联系在一起，并允许在它们之间进行导航。 此外，这个硬件时钟的基本结构允许平台定义它们自己的特定于硬件的时钟结构，以及它们自己的时钟操作回调，只要它们包装了`struct clk_hw`结构的一个实例。
*   `struct clk_ops`：此结构表示可以在时钟线上操作的特定于硬件的回调；即硬件。 这就是为什么此结构中的所有回调都接受指向`struct clk_hw`的指针作为第一个参数，尽管这些操作中只有几个是必需的，具体取决于时钟类型。
*   `struct clk_init_data`：它保存时钟提供程序和公共时钟框架之间共享的所有时钟共有的`init`数据。 时钟提供程序负责为系统中的每个时钟准备此静态数据，然后将其传递给时钟框架的核心逻辑。
*   `struct clk`：此结构是时钟的消费者表示，因为每个消费者 API 都依赖于此结构。
*   `struct clk_core`: This is the CCF representation of a clock.

    重要音符

    通过辨别`struct clk_hw`和`struct clk`之间的区别，我们可以进一步明确区分使用者和提供者 CLK API。

现在我们已经列举了该框架的数据结构，我们可以了解它们是如何实现的，以及它们的用途。

## 了解结构 CLK_HW 及其依赖关系

`struct clk_hw`是 CCF 中每种时钟类型的基本结构。 可以将它(T4)视为从`struct clk`遍历到其对应的特定于硬件的结构的句柄。 以下是`struct clk_hw`的正文：

```sh
struct clk_hw {
    struct clk_core *core;
    struct clk *clk;
    const struct clk_init_data *init;
};
```

让我们来看看前面结构中的字段：

*   `core`：此结构位于框架核心的内部。 它还在内部指向这个`struct clk_hw`实例。
*   `clk`：这是一个每个用户的`struct clk`实例，可以使用`clk`API 操作。 它由时钟框架分配和维护，并在需要时提供给时钟消费者。 当消费者通过`clk_get`发起对 CCF 中的时钟设备(即`clk_core`)的访问时，它需要获取一个句柄，即`clk`。
*   `init`：这是指向`struct clk_init_data`的指针。 在初始化底层时钟提供程序驱动器的过程中，调用`clk_register()`接口来注册时钟硬件。 在此之前，您需要设置一些初始数据，这些初始数据被抽象为`struct clk_init_data`数据结构。 在初始化过程中，来自`clk_init_data`的数据用于初始化对应于`clk_hw`的`clk_core`数据结构。 初始化完成后，`clk_init_data`没有意义。

`struct clk_init_data`定义如下：

```sh
struct clk_init_data {
    const char *name;
    const struct clk_ops *ops;
    const char * const *parent_names;
    u8 num_parents;
    unsigned long flags;
};
```

它保存所有时钟共有的初始化数据，并在时钟提供程序和公共时钟框架之间共享。 其字段如下：

*   `name`，表示时钟的名称。
*   `ops`是一组与时钟相关的操作功能。 这将在后面的*提供时钟操作*部分中描述。 它的回调将由时钟提供程序驱动程序提供(以便允许驱动硬件时钟)，并将由驱动程序通过`clk_*`消费者 API 调用。
*   `parent_names`包含时钟的所有父时钟的名称。 这是包含所有可能父级的字符串数组。
*   `num_parents`是父母的数量。 它应该与前面数组中的条目数相对应。
*   `flags` represent the framework-level flags of the clock. We will explain this in detail later in the *Providing clock ops* section, since these flags actually modify some `ops`.

    重要音符

    `struct clk`和`struct clk_core`是私有数据结构，在`drivers/clk/clk.c`中定义。 `struct clk_core`结构将时钟设备抽象到 CCF 层，使得每个实际硬件时钟设备(`struct clk_hw`)对应于`struct clk_core`。

现在我们已经完成了 CCF 的核心部分`struct clk_hw`，我们可以学习如何向系统注册时钟提供程序。

## 注册/注销时钟提供程序

时钟提供程序负责在系统初始化期间以树的形式公开它提供的时钟，对它们进行排序，并通过提供程序或时钟框架的核心初始化接口。

在早期内核时代(CCF 之前)，时钟注册由`clk_register()`接口统一。 现在我们有了基于`clk_hw`的(提供程序)API，我们可以在注册时钟时去掉基于`struct clk`的 API。 由于建议时钟提供者使用新的基于`struct clk_hw`的 API，因此需要考虑的注册接口是`devm_clk_hw_register()`，它是`clk_hw_register()`的托管版本。 但是，由于历史原因，旧的基于`clk`的 API 名称仍然保留，您可能会发现有几个驱动程序在使用它。 甚至还实现了一个称为`devm_clk_register()`的资源管理版本。 我们讨论这个旧的 API 只是为了让您了解现有的代码，而不是帮助您实现新的驱动程序：

```sh
struct clk *clk_register(struct device *dev, struct clk_hw *hw)
int clk_hw_register(struct device *dev, struct clk_hw *hw)
```

基于此`clk_hw_register()`接口，内核还提供其他更方便的注册接口(稍后介绍)，具体取决于要注册的时钟类型。 它负责将时钟注册到内核，并返回表示时钟的`struct clk_hw`指针。

它接受指向`struct clk_hw`的指针(因为`struct clk_hw`是时钟的提供者端表示)，并且必须包含要注册的时钟的一些信息。 内核将在其中填充更多数据。 其实现逻辑如下：

*   Assigning the `struct clk_core` space (`clk_hw->core`):

    --根据`struct clk_hw`指针提供的信息，初始化`clk`的字段名`ops`、`hw`、`flags`、`num_parents`、`parents_names`。

    --调用内核接口`__clk_core_init()`，执行后续初始化操作，包括构建时钟树层次结构。

*   通过内部内核接口`clk_create_clk()`赋值`struct clk`空间(`clk_hw->clk`)，并返回此`struct clk`变量。
*   即使`clk_hw_register()`包装了`clk_register()`，也不应该直接使用`clk_register()`，因为它返回`struct clk`。 这可能会导致混淆，并打破提供者和使用者接口之间的严格分离。

下面是`drivers/clk/clk.c`中`clk_hw_register`的实现：

```sh
int clk_hw_register(struct device *dev, struct clk_hw *hw)
{
    return PTR_ERR_OR_ZERO(clk_register(dev, hw));
}
```

在执行进一步步骤之前，应检查`clk_hw_register()`的返回值。 由于 CCF 框架负责建立整个抽象时钟树的树形结构并维护其数据，因此它通过`drivers/clk/clk.c`中定义的两个静态链表来实现这一点，如下所示：

```sh
static HLIST_HEAD(clk_root_list);
static HLIST_HEAD(clk_orphan_list);
```

每当您在时钟`hw`上调用`clk_hw_register()`(内部调用`__clk_core_init()`以初始化时钟)时，如果该时钟有有效的父时钟，它将在父时钟的`children`列表中结束。 另一方面，如果`num_parent`是`0`，则将其放置在`clk_root_list`中。 否则，它将挂在`clk_orphan_list`内部，这意味着它没有有效的父级。 此外，每当一个新的`clk`是 clk_init‘d 时，CCF 将遍历`clk_orphan_list`(孤立时钟列表)，并重新为当前正在初始化的时钟的子级。 这就是 CCF 保持时钟树与硬件拓扑一致的方式。

另一方面，`struct clk`是时钟设备的消费者端实例。 基本上，所有用户对时钟设备的访问都会创建`struct clk`类型的访问句柄。 当不同的用户访问相同的时钟设备时，尽管在幕后使用相同的`struct clk_core`实例，但他们访问的句柄(`struct clk`)是不同的。

重要音符

您应该记住，`clk_hw_register`(或其祖先`clk_register()`)在幕后操作`struct clk_core`，因为这是时钟的 CCF 表示。

CCF 通过在`drivers/clk/clkdev.c`中声明的全局链表以及保护其访问的互斥体来管理`clk`个实体，如下所示：

```sh
static LIST_HEAD(clocks);
static DEFINE_MUTEX(clocks_mutex);
```

这源于设备树使用不多的时代。 当时，时钟使用者通过名称(CLK 的名称)获得 CLK。 这是用来识别时钟的。 知道`clk_register()`的目的只是注册到公共时钟框架，所以消费者无法知道如何定位 CLK。 因此，对于底层时钟提供程序驱动程序，除了调用`clk_register()`函数注册到公共时钟框架之外，还必须在`clk_register()`之后立即调用，以便将时钟与名称绑定(否则，时钟消费者将不知道如何定位时钟)。 因此，内核使用`struct clk_lookup`(顾名思义)来查找可用的时钟，以防消费者请求时钟(当然是按名称)。

该机制仍然有效，并在内核中得到支持。 但是，为了使用基于`hw`的 API 强制分离提供者和使用者代码，代码中的`clk_register()`和`clk_register_clkdev()`应该分别替换为`clk_hw_register()`和`clk_hw_register_clkdev()`。

换句话说，假设您有以下代码：

```sh
/* Not be used anymore, introduced here for studying purpose */
int clk_register_clkdev(struct clk *clk,
                        const char *con_id, const char *dev_id)
```

这应替换为以下代码：

```sh
/* recommended interface */
int clk_hw_register_clkdev(struct clk_hw *hw,
                           const char *con_id,                            const char *dev_id)
```

回到`struct clk_lookup`数据结构，让我们来看看它的定义：

```sh
struct clk_lookup {
    struct list_head node;
    const char *dev_id;
    const char *con_id;
    struct clk *clk;
    struct clk_hw *clk_hw;
};
```

在前面的数据结构中，`dev_id`和`con_id`用于标识/查找适当的`clk`。 该`clk`是对应的底层时钟。 `node`是将挂起在全局时钟列表内的列表条目，如以下摘录中的低级`__clkdev_add()`函数所示：

```sh
static void __clkdev_add(struct clk_lookup *cl)
{
    mutex_lock(&clocks_mutex);
    list_add_tail(&cl->node, &clocks);
    mutex_unlock(&clocks_mutex);
}
```

前面的`__clkdev_add()`函数是从`clk_hw_register_clkdev()`中间接调用的，它实际上包装了`clk_register_clkdev()`。 既然我们已经引入了设备树，情况就发生了变化。 基本上，每个时钟提供程序都成为 DTS 中的一个节点；也就是说，每个`clk`在设备树中都有一个与其对应的设备节点。 在这种情况下，与其捆绑`clk`和名称，不如通过新的数据结构`struct of_clk_provider`捆绑`clk`和设备节点。 此特定数据结构如下所示：

```sh
struct of_clk_provider {
    struct list_head link;
    struct device_node *node;
    struct clk *(*get)(struct of_phandle_args *clkspec,                        void *data);
    struct clk_hw *(*get_hw)(struct of_phandle_args *clkspec,
                             void *data);
    void *data;
};
```

在前面的结构中，会发生以下情况：

*   `link`挂起在`of_clk_providers`全局列表中。
*   `node`表示时钟设备的 DTS 节点。
*   `get_hw`是解码时钟的回调。 对于设备(消费者)，它通过`clk_get()`被调用以返回与节点或`NULL`相关联的时钟。
*   `get`出于历史和兼容性原因，是否支持旧的基于 CLK 的 API。

然而，如今，由于设备树的频繁和普遍使用，对于底层提供程序驱动程序，原始的`clk_hw_register()`+`clk_hw_register_clkdev()`(或其基于 CLK 的旧实现，`clk_register()`+`clk_register_clkdev()`)组合变成了`clk_hw_register`+`of_clk_add_hw_provider`的组合(以前的`clk_register`+`of_clk_add_provider`-这可以在旧的和非基于`clk_hw`的驱动程序中找到)。 此外，CCF 中还引入了新的全局链表`of_clk_providers`，以帮助管理所有 DTS 节点和时钟之间的对应关系，以及保护该列表的互斥体：

```sh
static LIST_HEAD(of_clk_providers);
static DEFINE_MUTEX(of_clk_mutex);
```

虽然`clk_hw_register()`和`clk_hw_register_clkdev()`函数名非常相似，但这两个函数的目标不同。 利用前者，时钟提供者可以在公共时钟框架中注册时钟。 另一方面，顾名思义，`clk_hw_register_clkdev()`在公共时钟框架中注册了一个`struct clk_lookup`。 此操作主要用于查找 CLK。 如果您有一个仅支持设备树的平台，则不再需要对`clk_hw_register_clkdev()`的所有调用(除非您有很强的理由)，因此您应该依赖于对`of_clk_add_provider()`的一次调用。

重要音符

建议时钟提供程序使用新的基于`struct clk_hw`的 API，因为这使我们更接近消费者和提供程序 CLK API 的明显分离。

`clk_hw_*`接口是应该在时钟提供程序驱动程序中使用的提供程序接口，而`clk_*`用于消费者端。 每当您在提供者 c节点中遇到基于`clk_*`的 API 时，请注意此驱动程序应该更新以支持新的基于硬件的接口。

有些驱动程序仍然同时使用两种功能(`clk_hw_register_clkdev()`和`of_clk_add_hw_provider()`)，以便同时支持两种时钟查找方法，例如 SoC 时钟驱动程序，但除非有理由，否则不应同时使用这两种方法。

到目前为止，我们已经花了一些时间来讨论时钟注册。 但是，可能需要取消注册时钟，这可能是因为底层时钟硬件脱离系统，或者因为硬件初始化过程中出现错误。 时钟注销接口相当简单：

```sh
void clk_hw_unregister(struct clk_hw *hw)
void clk_unregister(struct clk *clk)
```

前一个以基于`clk_hw`的时钟为目标，而第二个以基于 CLK 的时钟为目标。 对于托管变体，除非 Devres 核心处理取消注册，否则您应该使用以下 API：

```sh
void devm_clk_unregister(struct device *dev, struct clk *clk)
void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw)
```

在这两种情况下，`dev`表示与时钟相关的底层设备结构。

至此，我们已经完成了时钟注册/取消注册。 也就是说，驱动程序的主要目的之一是向潜在消费者公开设备资源，这也适用于时钟设备。 在下一节中，我们将学习如何向消费者展示时钟线路。

## 将时钟暴露给其他人(详细)

一旦时钟已经向 CCF 注册了，下一步就是注册该时钟提供程序，以便其他设备可以使用它的时钟线路。 在旧的内核时代(设备树使用不多)，您必须通过在每条时钟线上调用`clk_hw_register_clkdev()`来向消费者公开时钟，这会导致为给定的时钟线注册一个查找结构。 目前，设备树通过调用`of_clk_add_hw_provider()`接口以及一定数量的参数来实现此目的：

```sh
int of_clk_add_hw_provider(
    struct device_node *np,
    struct clk_hw *(*get)(struct of_phandle_args *clkspec,
                          void *data),
    void *data)
```

让我们看一下此函数中的参数：

*   `np`是与时钟提供程序关联的设备节点指针。
*   `get`是解码时钟的回调。 我们将在下一节详细讨论此回调。
*   `data`是给定`get`回调的上下文指针。 这通常是指向需要与设备节点关联的时钟的指针。 这对解码很有用。

此函数在成功的路径上返回`0`。 它执行与`of_clk_del_provider()`相反的操作，后者包括从全局列表中删除提供程序并释放其空间：

```sh
void of_clk_del_provider(struct device_node *np)
```

它的资源管理版本`devm_of_clk_add_hw_provider()`也可以用来去除的删除功能。

### 时钟提供程序设备树节点及其关联机制

在相当长的一段时间内，设备树是描述(声明)系统上的设备的首选方法。 公共时钟框架无法逃脱这一规则。 在这里，我们将尝试弄清楚如何从设备树和相关驱动程序代码中描述时钟。 要实现这一点，我们需要考虑以下设备树摘录：

```sh
clocks {
    /* Provider node */
    clk54: clk54 {
        #clock-cells = <0>;
        compatible = 'fixed-clock';
        clock-frequency = <54000000>;
        clock-output-names = 'osc';
    };
};
[...]
i2c0: i2c-master@d090000 {
    [...]
    /* Consumer node */
    cdce706: clock-synth@69 {
        compatible = 'ti,cdce706';
        #clock-cells = <1>;
        reg = <0x69>;         clocks = <&clk54>;
        clock-names = 'clk_in0';
    };
};
```

请记住，时钟是通过`clocks`属性分配给消费者的，时钟提供者也可以是消费者。 在前面的摘录中，`clk54`是一个固定的时钟；我们不会在这里详细介绍。 `cdce706`是一个时钟提供程序，它也消耗`clk54`(在`clocks`属性中作为`phandle`给出)。

时钟提供者节点需要指定的最重要的信息是`#clock- cells`属性，该属性确定时钟说明符的长度：当它为`0`时，这意味着只需要将该提供者的`phandle`属性提供给使用者。 当它为`1`(或更大)时，这意味着`phandle`属性有多个输出，需要提供附加信息，例如指示需要使用什么输出的 ID。 此 ID 直接由立即值表示。 最好在头文件中定义系统中所有时钟的 ID。 设备树可以包括此头文件，例如`clocks = <&clock CLK_SPI0>`，其中`CLK_SPI0`是在头文件中定义的宏。

现在，让我们来看看`clock-output-names`。 这是一个可选但建议使用的属性，应该是与输出(即提供的)时钟线的名称相对应的字符串列表。

请看以下提供程序节点摘录：

```sh
osc {
    #clock-cells = <1>;
    clock-output-names = 'ckout1', 'ckout2';
};
```

前面的节点定义了一个设备，该设备分别提供名为`ckout1`和`ckout2`的两条时钟输出线。 使用者节点不应直接使用这些名称来引用这些时钟线。 相反，它们应该使用适当的时钟说明符(根据供应商的`#clock-cells`通过索引引用时钟)，以允许它们根据器件的需要命名其输入时钟线路：

```sh
device {
    clocks = <&osc 0>, <&osc 1>;
    clock-names = 'baud', 'register';
};
```

该器件消耗`osc`提供的两条时钟线，并根据需要命名其输入线。 我们将在本章末尾讨论消费者节点。

当时钟线路分配给消费者设备，并且该消费者的驱动程序调用`clk_get()`(或用于获取时钟的类似接口)时，此接口调用`of_clk_get_by_name()`，而后者又调用`__of_clk_get()`。 这里感兴趣的函数是`__of_clk_get()`。 在`drivers/clk/clkdev.c`中定义如下：

```sh
static struct clk * of_clk_get(struct device_node *np,                                int index,
                               const char *dev_id,                                const char *con_id)
{
    struct of_phandle_args clkspec;
    struct clk *clk;
    int rc;
    rc = of_parse_phandle_with_args(np, 'clocks',            
                                    '#clock-cells',
                                    index, &clkspec);
    if (rc)
        return ERR_PTR(rc);
    clk = of_clk_get_from_provider(&clkspec, dev_id, con_id); 
    of_node_put(clkspec.np);
    return clk;
}
```

重要音符

此函数返回指向`struct clk`的指针而不是指向`struct clk_hw`的指针，这是完全正常的，因为此接口是从消费者端操作的。

这里的魔力来自`of_parse_phandle_with_args()`，它解析`phandle`及其参数的列表，然后调用`__of_clk_get_from_provider()`，我们将在后面描述。

#### 了解 of_parse_phandle_with_args()API

下面是`of_parse_phandle_with_args`的原型：

```sh
int of_parse_phandle_with_args(const struct device_node *np,
                               const char *list_name,
                               const char *cells_name,
                               int index,
                               struct of_phandle_args *out_args)
```

此函数在成功时返回`0`，并填充`out_args`；在出错时返回适当的`errno`值。 让我们来看看它的论点：

*   `np`是指向包含列表的设备树节点的指针。 在我们的示例中，它将是与使用者相对应的节点。
*   `list_name`是包含列表的属性名称。 在我们的例子中，它是`clocks`。
*   `cells_name`是指定 phandle 的参数计数的属性名称。 在我们的例子中，它是`#clock-cells`。 它帮助我们获取说明符中`phandle`属性之后的参数(其他单元格)。
*   `index`是`phandle`属性的索引，用于解析列表。
*   `out_args`是在成功路径上填充的可选输出参数。 此参数为`of_phandle_args`类型，定义如下：

    ```sh
    #define MAX_PHANDLE_ARGS 16
    struct of_phandle_args {
        struct device_node *np;
        int args_count;
        uint32_t args[MAX_PHANDLE_ARGS];
    };
    ```

在`struct of_phandle_args`中，`np`元素是指向对应于`phandle`属性的节点的指针。 在时钟说明符的情况下，它将是时钟提供程序的设备树节点。 `args_count`元素对应于说明符中竖线后面的单元格数量。 它可用于遍历`args`，这是一个包含相关参数的数组。

让我们看一个使用`of_parse_phandle_with_args()`的示例，给出以下 DTS 摘录：

```sh
phandle1: node1 {
    #gpio-cells = <2>;
};
phandle2: node2 {
    #list-cells = <1>;
};
node3 {
    list = <&phandle1 1 2 &phandle2 3>;
};
/* or */
node3 {
    list = <&phandle1 1 2>, <&phandle2 3>;
}
```

这里，`node3`是一个消费者。 要获取指向`node2`节点的`device_node`指针，可以调用`of_parse_phandle_with_args(node3, 'list', '#list-cells', 1, &args);`。 由于`&phandle2`在列表中位于索引`1`(从`0`开始)，因此我们在`index`参数中指定了`1`。

同样，要获得`node1`节点的关联`device_node`，可以调用`of_parse_phandle_with_args(node3, 'list', '#gpio-cells', 0, &args);`。 对于第二种情况，如果我们查看`args`输出参数，我们将看到`args->np`对应于`node3`，`args->args_count`的值是`2`(因为此说明符需要`2`参数)，`args->args[0]`的值是`1`，`args->args[1]`的值是`2`，对应于说明符中的`2`参数。

重要音符

要进一步了解设备树 API，请查看`drivers/of/base.c`中的 de副树核心代码提供的`of_parse_phandle_with_fixed_args()`和其他接口。

#### 了解 __of_clk_get_from_Provider()API

`__of_clk_get()`中的下一个函数调用是`__of_clk_get_from_provider()`。 我之所以提供它的原型，是因为您不能在代码中使用它。 但是，该函数只是遍历时钟提供程序(在`of_clk_providers`列表中)，当找到合适的提供程序时，它调用作为`of_clk_add_provider()`的第二个参数提供的底层回调来解码底层时钟。 这里，给出了`of_parse_phandle_with_args()`返回的时钟说明符作为参数。 您可能还记得，当您必须向其他设备公开时钟提供程序时，我们必须使用`of_clk_add_hw_provider()`。 作为第二个参数，每当消费者调用`clk_get()`时，该接口接受 CCF 用来解码底层时钟的回调。 该回调的结构如下：

```sh
struct clk_hw *(*get_hw)(struct of_phandle_args *clkspec, void *data)
```

此回调应根据其参数返回底层的`clock_hw`。 `clkspec`是`of_parse_phandle_with_args()`返回的时钟说明符，而`data`是作为第三个参数给`of_clk_add_hw_provider()`的上下文数据。 请记住，`data`通常是指向与节点关联的时钟的指针。 要了解此回调是如何在内部调用的，我们需要了解一下`__of_clk_get_from_provider()`接口的定义，定义如下：

```sh
struct clk * of_clk_get_from_provider(struct                                       of_phandle_args *clkspec,
                                      const char *dev_id,                                       const char *con_id)
{
    struct of_clk_provider *provider;
    struct clk *clk = ERR_PTR(-EPROBE_DEFER);
    struct clk_hw *hw;
    if (!clkspec)
        return ERR_PTR(-EINVAL);
    /* Check if we have such a provider in our array */
    mutex_lock(&of_clk_mutex);
    list_for_each_entry(provider, &of_clk_providers, link) {
        if (provider->node == clkspec->np) {
          hw = of_clk_get_hw_from_provider (provider, clkspec);
            clk = clk_create_clk(hw, dev_id, con_id);
        }
        if (!IS_ERR(clk)) {
            if (! clk_get(clk)) {
                clk_free_clk(clk);
                clk = ERR_PTR(-ENOENT);
            }
            break;
        }
    }
    mutex_unlock(&of_clk_mutex);
    return clk;
}
```

#### 时钟解码回调

如果我们必须总结从 CCF 获取时钟背后的机制，我们会说，当消费者调用`clk_get()`时，CCF 内部调用`__of_clk_get()`。 这是作为该使用者的`device_node`属性的第一个参数给出的，这样 CCF 就可以获取时钟说明符，并找到与提供者相对应的`device_node`属性(通过`of_parse_phandle_with_args()`)。 然后，它以`of_phandle_args`的形式返回该值。 此`of_phandle_args`对应于时钟说明符，并作为参数提供给`__of_clk_get_from_provider()`，它只是将`of_phandle_args`(即`of_phandle_args->np`)中提供程序的`device_node`属性与设备树时钟提供程序列表`of_clk_providers`中存在的属性进行比较。 一旦找到匹配项，就会调用该提供程序的相应`of_clk_provider->get()`回调，并返回底层时钟。

重要音符

如果`__of_clk_get()`失败，这意味着无法找到给定设备节点的有效时钟。 这也可能意味着提供商没有向设备树接口注册其时钟。 因此，当`of_clk_get()`失败时，CCF 代码调用`clk_get_sys()`，这是退回到根据不再在设备树上的时钟名称查找时钟。 这是`clk_get()`背后的真正逻辑。

此`of_clk_provider->get()`回调通常依赖于作为参数提供给`of_clk_add_provider()`的上下文数据，以便返回底层时钟。 虽然可以编写您自己的回调(应该尊重上一节中已经介绍的原型)，但 CCF 框架提供了两个覆盖大多数情况的通用解码回调。 这些是`of_clk_src_onecell_get()`和`of_clk_src_simple_get()`，它们都有相同的原型：

```sh
struct clk_hw *of_clk_hw_simple_get(struct                                     of_phandle_args *clkspec,
                                    void *data);
struct clk_hw *of_clk_hw_onecell_get(struct                                      of_phandle_args *clkspec,
                                     void *data);
```

`of_clk_hw_simple_get()`用于简单时钟提供程序，其中除了时钟本身不需要特殊的上下文数据结构，例如时钟-GPIO 驱动器(在`drivers/clk/clk-gpio.c`中)。 该回调只按原样返回作为上下文数据参数提供的数据，这意味着该参数应该是时钟。 在`drivers/clk/clk.c`中定义如下：

```sh
struct clk_hw *of_clk_hw_simple_get(struct                                     of_phandle_args *clkspec,
                                    void *data)
{
    return data;
}
EXPORT_SYMBOL_GPL(of_clk_hw_simple_get);
```

另一方面，`of_clk_hw_onecell_get()`稍微复杂一些，因为它需要称为`struct clk_hw_onecell_data`的特殊数据结构。 这可以定义为：

```sh
struct clk_hw_onecell_data {
    unsigned int num;
    struct clk_hw *hws[];
};
```

在前面的结构中，`hws`是指向`struct clk_hw`的指针数组，`num`是该数组中的条目数。

重要音符

在尚未实现基于 CLK_HW 的 API 的旧时钟提供程序驱动程序中，您可能会看到`struct clk_onecell_data`、`of_clk_add_provider()`、`of_clk_src_onecell_get()`和`of_clk_add_provider()`，而不是本书中介绍的数据结构和接口。

也就是说，要控制存储在此数据结构中的时钟，建议将它们包装在您的上下文数据结构中，如`drivers/clk/sunxi/clk-sun9i-mmc.c`中的以下示例所示：

```sh
struct sun9i_mmc_clk_data {
    spinlock_t	lock;
    void  iomem		*membase;
    struct clk	*clk;
    struct reset_control	*reset;
    struct clk_hw_onecell_data	clk_hw_data;
    struct reset_controller_dev		rcdev;
};
```

然后，您应该根据应该存储的时钟数量为这些时钟动态分配空间：

```sh
int sun9i_a80_mmc_config_clk_probe(struct                                    platform_device *pdev){    struct device_node *np = pdev->dev.of_node;
    struct sun9i_mmc_clk_data *data;
    struct clk_hw_onecell_data *clk_hw_data;
    const char *clk_name = np->name;
    const char *clk_parent;
    struct resource *r;
    [...]
    data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;
    clk_hw_data = &data->clk_hw_data;
    clk_hw_data->num = count;
    /* Allocating space for clk_hws, and 'count' is the number
     *of entries
     */
    clk_hw_data->hws =
    devm_kcalloc(&pdev->dev, count, sizeof(struct clk_hw *),
                     GFP_KERNEL);
    if (!clk_hw_data->hws)
        return -ENOMEM;
    /* A clock provider may be a consumer from another
     * provider as well      */
    data->clk = devm_clk_get(&pdev->dev, NULL);
    clk_parent = __clk_get_name(data->clk);
    for (i = 0; i < count; i++) {
        of_property_read_string_index(np, 'clock-output-names',
                                      i, &clk_name);
        /* storing each clock in its location */
        clk_hw_data->hws[i] =
        clk_hw_register_gate(&pdev->dev, clk_name,                            clk_parent, 0,
                           data->membase + SUN9I_MMC_WIDTH * i,
                           SUN9I_MMC_GATE_BIT, 0, &data->lock);        if (IS_ERR(clk_hw_data->hws[i])) {            ret = PTR_ERR(clk_hw_data->hws[i]);            goto err_clk_register;        }    }
    ret =
       of_clk_add_hw_provider(np, of_clk_hw_onecell_get,                               clk_hw_data);
    if (ret)
        goto err_clk_provider;
    [...]
    return 0;}
```

重要音符

在撰写本文时，前面的摘录(摘自 Sunxi A80 SoC MMC 配置时钟/复位驱动程序)仍然使用基于 CLK 的 API(以及`struct clk`、`clk_register_gate()`和`of_clk_add_src_provider()`接口)，而不是`clk_hw`接口。 因此，出于学习目的，我修改了这段摘录，使其使用推荐的`clk_hw`API。

如您所见，在时钟注册期间给出的上下文数据是`clk_hw_data`，它属于`clk_hw_onecell_data`类型。 此外，给出了`of_clk_hw_onecell_get`作为时钟解码器回调函数。 这个帮助器只返回在时钟说明符(类型为`of_phandle_args`)中作为参数给定的索引处的时钟。 请看一下它的定义，以便更好地理解：

```sh
struct clk_hw * of_clk_hw_onecell_get(struct                                       of_phandle_args *clkspec, 
                                      void *data)
{
    struct clk_hw_onecell_data *hw_data = data;
    unsigned int idx = clkspec->args[0];
    if (idx >= hw_data->num) {
        pr_err('%s: invalid index %u\n', func , idx);
        return ERR_PTR(-EINVAL);
    }
    return hw_data->hws[idx];
}
EXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);
```

当然，根据您的需要，可以随意实现您自己的解码器回调，类似于`max9485`音频时钟生成器中的回调，它的驱动程序在内核源代码的树中是`drivers/clk/clk-max9485.c`。

在本节中，我们了解了时钟提供程序的设备树方面。 我们已经了解了如何暴露设备的时钟源线，以及如何将这些时钟线分配给消费者。 现在，到了介绍驱动程序端的时候了，驱动程序端还包括为其时钟提供程序编写代码。

# 编写时钟提供程序驱动程序

虽然设备树的目的是描述手头的硬件(在本例中是时钟提供程序)，但值得注意的是，需要编写用于管理底层硬件的代码。 本节介绍如何为时钟提供程序编写代码，以便一旦将时钟线路分配给消费者，它们就会按照设计的方式运行。 编写时钟设备驱动程序时，最好将完整的`struct clk_hw`(而不是指针)嵌入到私有的更大的数据结构中，因为它是作为`clk_ops`中每个回调的第一个参数给出的。 这使您可以在`container_of`宏上定义自定义的`to_<my-data-structure>`帮助器，从而返回指向您的私有数据结构的指针，如下所示：

```sh
/* forward reference */
struct max9485_driver_data;
struct max9485_clk_hw {
    struct clk_hw hw;
    struct clk_init_data init;     u8 enable_bit;
    struct max9485_driver_data *drvdata;
;
struct max9485_driver_data {
    struct clk *xclk;
    struct i2c_client *client;
    u8 reg_value;
    struct regulator *supply;
    struct gpio_desc *reset_gpio;
    struct max9485_clk_hw hw[MAX9485_NUM_CLKS];
};
static inline struct max9485_clk_hw *to_max9485_clk(struct                                                     clk_hw *hw)
{
    return container_of(hw, struct max9485_clk_hw, hw);
}
```

在前面的示例中，`max9485_clk_hw`抽象了`hw`时钟(因为它包含`struct clk_hw`)。 现在，从驱动程序的角度来看，每个`struct max9485_clk_hw`代表一个 HW 时钟，允许我们定义另一个更大的结构，这一次将用作驱动程序数据：`max9485_driver_data`结构。 您将注意到前面结构中的一些交叉引用，特别是在包含指向`struct max9485_driver_data`的指针的`struct max9485_clk_hw`和包含`max9485_clk_hw`数组的`struct max9485_driver_data`中。 这允许我们从任何`clk_ops`回调中获取驱动程序数据，如下所示：

```sh
static unsigned long
max9485_clkout_recalc_rate(struct clk_hw *hw,
                               unsigned long parent_rate)
{
    struct max9485_clk_hw *max_clk_hw = to_max9485_clk(hw);
    struct max9485_driver_data *drvdata = max_clk_hw->drvdata;
    [...]
    return 0;
}
```

此外，如下面的摘录所示，静态声明时钟线(在本例中由`max9485_clk_hw`抽象)以及相关的操作是一种很好的做法。 这是因为，与私有数据(可能会从一个设备更改到另一个设备)不同，无论系统上存在多少相同类型的时钟芯片，此信息永远不会更改：

```sh
static const struct max9485_clk max9485_clks[MAX9485_NUM_CLKS] = {
    [MAX9485_MCLKOUT] = {
        .name = 'mclkout',
        .parent_index = -1,
        .enable_bit = MAX9485_MCLK_ENABLE,
        .ops = {
            .prepare		= max9485_clk_prepare,
            .unprepare	= max9485_clk_unprepare,
        },
    },
    [MAX9485_CLKOUT] = {
        .name = 'clkout',
        .parent_index = -1,
        .ops = {
             .set_rate	= max9485_clkout_set_rate,
            .round_rate	= max9485_clkout_round_rate,
            .recalc_rate	= max9485_clkout_recalc_rate,
        },
    },
    [MAX9485_CLKOUT1] = {
        .name = 'clkout1',
        .parent_index = MAX9485_CLKOUT,
        .enable_bit = MAX9485_CLKOUT1_ENABLE,
        .ops = {
            .prepare	= max9485_clk_prepare,
            .unprepare	= max9485_clk_unprepare,
        },
    },
    [MAX9485_CLKOUT2] = {
        .name = 'clkout2',
        .parent_index = MAX9485_CLKOUT,
        .enable_bit = MAX9485_CLKOUT2_ENABLE,
        .ops = {
            .prepare	= max9485_clk_prepare,
            .unprepare	= max9485_clk_unprepare,
        },
    },
};
```

尽管 op 嵌入在抽象数据结构中，但它们可以单独声明，就像在内核源代码的`drivers/clk/clk-axm5516.c`文件中一样。 另一方面，更好的做法是动态分配驱动程序数据结构，因为它更容易成为驱动程序的私有数据，从而允许每个声明的设备都有私有数据，如以下摘录所示：

```sh
static int max9485_i2c_probe(struct i2c_client *client,
                             const struct i2c_device_id *id)
{
    struct max9485_driver_data *drvdata;
    struct device *dev = &client->dev;
    const char *xclk_name;
    int i, ret;
    drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
    if (!drvdata)
        return -ENOMEM;
    [...]
    for (i = 0; i < MAX9485_NUM_CLKS; i++) {
        int parent_index = max9485_clks[i].parent_index;
        const char *name;
        if (of_property_read_string_index
           (dev->of_node, 'clock-output-names', i, &name) == 0) {
            drvdata->hw[i].init.name = name;
        } else {
            drvdata->hw[i].init.name = max9485_clks[i].name;
        }
        drvdata->hw[i].init.ops = &max9485_clks[i].ops;
        drvdata->hw[i].init.num_parents = 1;
        drvdata->hw[i].init.flags = 0;
        if (parent_index > 0) {
            drvdata->hw[i].init.parent_names =
                        &drvdata->hw[parent_index].init.name;
            drvdata->hw[i].init.flags |= CLK_SET_RATE_PARENT;
        } else {
            drvdata->hw[i].init.parent_names = &xclk_name;
        }
        drvdata->hw[i].enable_bit = max9485_clks[i].enable_bit;
        drvdata->hw[i].hw.init = &drvdata->hw[i].init;
        drvdata->hw[i].drvdata = drvdata;
        ret = devm_clk_hw_register(dev, &drvdata->hw[i].hw);
        if (ret < 0)
            return ret;
    }
    return
      devm_of_clk_add_hw_provider(dev, max9485_of_clk_get,                                   drvdata);
}
```

在前面的摘录中，驱动程序调用`clk_hw_register()`(这实际上是`devm_clk_hw_register()`，它是 t他管理的版本)，以便将每个时钟注册到 CCF。 既然我们已经了解了时钟提供程序驱动程序的基础知识，我们将学习如何允许与时钟线路交互，这要归功于可以在驱动程序中公开的操作的 sET。

## 提供时钟操作

`struct clk_hw`是基础硬件时钟结构，CCF 在此基础上构建其他时钟变量结构。 作为快速回调，公共时钟框架提供了以下基准时钟：

*   **固定速率**：这种类型的时钟不能更改其速率，并且始终在运行。
*   **GATE**：它充当时钟源的门，因为它是其父时钟源。 显然，它不能改变它的汇率，因为它只是一个大门。
*   **多路复用器**：此类型的时钟无法选通。 它有两个或更多的时钟输入：它的双亲。 它允许我们从与其连接的父项中选择父项。 此外，它还允许我们从选定的父代获得比率。
*   **固定因数**：此时钟类型不能选通/取消选通，但可以用其常量除以和乘以父速率。
*   **分频器**：此类型的时钟无法选通/取消选通。 然而，它通过使用可以从注册时提供的各种阵列中选择的分频器来划分父时钟速率。
*   **复合**：这是我们前面描述的三个基本时钟的组合：MUX、RATE 和 GATE。 它允许我们重用这些基准时钟来构建单个时钟接口。

您可能想知道，当将`clk_hw`作为参数提供给`clk_hw_register()`函数时，内核(即 CCF)如何知道给定时钟的类型。 事实上，建和团并不知道，也不需要知道任何事情。 这就是`clk_hw->init.ops`字段的目的，它属于`struct clk_ops`类型。 根据这个结构中设置的回调函数，可以猜测它面对的是哪种类型的时钟。 以下是`struct clk_ops`中时钟的这组操作功能的详细介绍：

```sh
struct clk_ops {
    int	(*prepare)(struct clk_hw *hw);
    void	(*unprepare)(struct clk_hw *hw);
    int	(*is_prepared)(struct clk_hw *hw);
    void	(*unprepare_unused)(struct clk_hw *hw);
    int	(*enable)(struct clk_hw *hw);
    void	(*disable)(struct clk_hw *hw);
    int	(*is_enabled)(struct clk_hw *hw);
    void	(*disable_unused)(struct clk_hw *hw);
    unsigned long (*recalc_rate)(struct clk_hw *hw,
                                 unsigned long parent_rate);
    long	(*round_rate)(struct clk_hw *hw, unsigned long rate,
                         unsigned long *parent_rate);
    int	(*determine_rate)(struct clk_hw *hw,
                          struct clk_rate_request *req);
    int	(*set_parent)(struct clk_hw *hw, u8 index);
    u8	(*get_parent)(struct clk_hw *hw);
    int	(*set_rate)(struct clk_hw *hw, unsigned long rate,
                       unsigned long parent_rate);
[...]
    void	(*init)(struct clk_hw *hw);
};
```

为清楚起见，删除了一些字段。

每个`prepare*`/`unprepare*`/`is_prepared`回调都允许休眠，因此不能从原子上下文调用，而每个`enable*`/`disable*`/`is_enabled`回调不能也不能休眠。 让我们更详细地看看这段代码：

*   `prepare`和`unprepare`是可选的回调。 在`prepare`中所做的操作应该在`unprepare`中撤消。
*   `is_prepared` is an optional callback that tells is whether the clock is prepared or not by querying the hardware. If omitted, the clock framework core will do the following:

    --维护准备计数器(调用`clk_prepare()`消费者接口加 1，调用`clk_unprepare()`减 1)。

    --根据该计数器判断时钟是否准备好。

*   `unprepare_unused`/`disable_unused`：这些回调是可选的，仅在`clk_disable_unused`接口中使用。 该接口由时钟框架核心提供，并在系统启动的延迟调用中调用(在`drivers/clk/clk.c`：`late_initcall_sync(clk_disable_unused)`中)，以便取消准备/取消选通/关闭未使用的时钟。 此接口将调用系统上每个未使用时钟的对应`.unprepare_unused`和`.disable_unused`函数。
*   `enable`/`disable`：自动启用/禁用时钟。 这些函数必须自动运行，并且不能休眠。 例如，对于`enable`，当底层时钟正在生成消费者节点可以使用的有效时钟信号时，它应该只返回**。**
***   `is_enabled`与`is_prepared`具有相同的逻辑。*   `recalc_rate`：这是一个可选的回调，给定父速率作为输入参数，它查询硬件以重新计算底层时钟的速率。 如果省略此操作，则初始速率为`0`。*   `round_rate`：此回调接受目标速率(以 Hz 为单位)作为输入，并应返回底层时钟实际支持的最接近速率。 父速率是一个输入/输出参数。*   `determine_rate`：此回调被赋予一个目标时钟频率作为参数，并返回底层硬件支持的最接近的时钟频率。*   `set_parent`：这与具有多个输入(多个可能的父节点)的时钟有关。 当给定索引作为要选择的父级的参数(作为`u8`)时，此回调接受更改输入源。 此索引应对应于在时钟的`clk_init_data.parent_names`或`clk_init_data.parents`数组中有效的父级。 此回调应在成功路径上返回`0`，否则返回`-EERROR`。*   `get_parent`是具有多个(至少两个)输入(多个`parents`)的时钟的强制回调。 它查询硬件以确定时钟的父时钟。 返回值是对应于父索引的`u8`。 此索引应在`clk_init_data.parent_names`或`clk_init_data.parents`数组中有效。 换句话说，该回调将从硬件读取的父值转换为数组索引。*   `set_rate`：更改给定时钟的速率。 请求的速率应为`.round_rate`调用的返回值才有效。 此回调应在成功路径上返回`0`，否则返回`-EERROR`。*   `init` is a platform-specific clock initialization hook that will be called when the clock is registered to the kernel. For now, no basic clock type implements this callback.

    给小费 / 翻倒 / 倾覆

    由于`.enable`和`.disable`不得休眠(它们是在保持自旋锁的情况下调用的)，连接到可休眠总线(如 SPI 或 I2C)的分立芯片中的时钟供应器不能在保持自旋锁的情况下进行控制，因此应在准备/取消准备挂钩中实现其启用/禁用逻辑。 通用 API 会直接调用相应的操作函数。 这就是为什么在消费者端(基于 CLK 的 API)，调用`clk_enable`之前必须先调用 `clk_prepare()`，调用`clock_disable()`之后必须调用`clock_unprepare()`。** 

 **最后但并非最不重要的一点是，还应注意以下不同之处：

重要音符

SOC-内部时钟可视为快速时钟(通过简单的 MMIO 寄存器写入控制)，因此可实现`.enable`和`.disable`，而基于 SPI/I2C 的时钟可视为慢时钟，应实现`.prepare`和`.unprepare`。

这些功能并不是所有时钟都必须具备的。 根据时钟类型的不同，有些可能是强制的，而另一些可能不是。 以下数组根据硬件功能汇总了哪些`clk_ops`个回调是哪种时钟类型的强制回调：

![Figure 4.1 – Mandatory clk_ops callbacks for clock types ](image/Figure_4.1_B10985.jpg)

图 4.1-时钟类型的强制 clk_ops 回调

在前面的数组中，******标记表示需要`round_rate`或`determine_rate`。

在前面的数组中，**y**表示强制回调，而**n**表示相关回调无效或不必要。 应该将空单元格视为 OP，或者必须在个案的基础上对它们进行求值。

### Clk_hw.init.flag 中的时钟标志

由于我们已经引入了时钟操作结构，现在我们将引入不同的标志(在`include/linux/clk-provider.h`中定义)，看看它们如何影响此结构中某些回调的行为：

```sh
/*must be gated across rate change*/#define CLK_SET_RATE_GATE  BIT(0)
/*must be gated across re-parent*/#define CLK_SET_PARENT_GATE	 BIT(1)
/*propagate rate change up one level */#define CLK_SET_RATE_PARENT	 BIT(2)
/* do not gate even if unused */#define CLK_IGNORE_UNUSED	BIT(3)
/*Basic clk, can't do a to_clk_foo()*/#define CLK_IS_BASIC BIT(5)
/*do not use the cached clk rate*/#define CLK_GET_RATE_NOCACHE BIT(6)
/* don't re-parent on rate change */#define CLK_SET_RATE_NO_REPARENT BIT(7)
/* do not use the cached clk accuracy */#define CLK_GET_ACCURACY_NOCACHE BIT(8)
/* recalc rates after notifications */#define CLK_RECALC_NEW_RATES BIT(9)
/* clock needs to run to set rate */#define CLK_SET_RATE_UNGATE BIT(10)
/* do not gate, ever */#define CLK_IS_CRITICAL	BIT(11)
```

前面的代码显示了可以在`clk_hw->init.flags`字段中设置的不同框架级标志。 您可以通过对多个标志进行“或”运算来指定多个标志。 让我们更详细地看看它们：

*   `CLK_SET_RATE_GATE`：当您更改时钟速率时，必须将其选通(禁用)。 该标志还确保存在速率更改和速率毛刺保护；当时钟设置了`CLK_SET_RATE_GATE`标志并且已经准备好时，`clk_set_rate()`请求将失败。
*   `CLK_SET_PARENT_GATE`：当您更改时钟的父级时，必须对其进行选通。
*   `CLK_SET_RATE_PARENT`: Once you've changed the rate of the clock, the change must be passed to the upper parent. This flag has two effects:

    --当时钟消费者调用`clk_round_rate()`(CCF 内部映射到`.round_rate`)获取近似速率时，如果时钟没有提供`.round_rate`回调，如果没有设置`CLK_SET_RATE_PARENT`，CCF 会立即返回缓存的时钟速率。 然而，如果该标志仍被设置而没有提供`.round_rate`，则请求被路由到时钟父节点。 这意味着查询父时钟并调用`clk_round_rate()`来获取父时钟可以提供的最接近目标速率的值。

    --此标志还修改`clk_set_rate()`接口的行为(CCF 内部映射到`.set_rate`)。 如果设置，则任何速率更改请求都将被上游转发(传递给父时钟)。也就是说，如果父时钟可以获得近似的速率值，那么通过更改父时钟速率，您就可以获得所需的速率。 该标志通常在时钟门和多路复用器上设置。 小心使用这面旗帜。

*   `CLK_IGNORE_UNUSED`：忽略禁用未使用的调用。 当有一个驱动程序没有正确声明时钟，但是引导加载程序让它们保持打开时，这主要是有用的。 它等同于`clk_ignore_unused`内核引导参数，但对于单个时钟。 一般情况下不会使用它，但对于启动和调试，可以选择不选通(而不是禁用)仍在运行的无人认领时钟，这是非常有用的。
*   `CLK_IS_BASIC`：不再使用此选项。
*   `CLK_GET_RATE_NOCACHE`: There are chips where the clock rate can be changed by internal hardware without the Linux clock framework being aware of that change at all. This flag makes sure the clk rate from the Linux clock tree always matches the hardware settings. In other words, the get/set rate does not come from the cache and is calculated at the time.

    重要音符

    在处理选通时钟类型时，请注意选通时钟是禁用时钟，而非选通时钟是启用时钟。 有关详细信息，请参阅[https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L931)和[https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862](https://elixir.bootlin.com/linux/v4.19/source/drivers/clk/clk.c#L862)。

既然我们已经熟悉了时钟标志，以及这些标志可能修改与时钟相关的回调行为的方式，我们就可以遍历每种时钟类型并学习如何提供它们相关的操作。

### 定时钟案例研究及其操作

这是最简单的时钟类型。 因此，我们将使用它来构建一些在编写时钟驱动程序时必须遵守的强指导原则。 此类型时钟的频率不能调整，因为它是固定的。 此外，该类型的时钟不能切换，不能选择其父时钟，也不需要提供`clk_ops`回调函数。

时钟框架使用`struct clk_fixed_rate`结构(如下所述)来抽象该类型的时钟硬件：

```sh
Struct clk_fixed_rate {
    struct clk_hw hw;
    unsigned long fixed_rate;
    u8 flags; [...]
};
#define to_clk_fixed_rate(_hw) \
            container_of(_hw, struct clk_fixed_rate, hw)
```

在前面的结构中，`hw`是基本结构，并确保公共接口和硬件特定接口之间存在链接。 一旦给出了`to_clk_fixed_rate`宏(它基于`container_of`)，您应该得到一个指向`clk_fixed_rate`的指针，它包装了这个`hw`。 `fixed_rate`是时钟装置的恒定(固定)速率。 `flags`表示特定于框架的标志。

让我们看一下下面的节选，它简单地注册了两条假的固定速率时钟线路：

```sh
#include <linux/clk.h>
#include <linux/clk-provider.h>
#include <linux/init.h>
#include <linux/of_address.h>
#include <linux/platform_device.h>
#include <linux/reset-controller.h>
static struct clk_fixed_rate clk_hw_xtal = {
    .fixed_rate = 24000000,
    .hw.init = &(struct clk_init_data){
        .name = 'xtal',
        .num_parents = 0,
        .ops = &clk_fixed_rate_ops,
    },
};
static struct clk_fixed_rate clk_hw_pll = {
    .fixed_rate = 45000000,
    .hw.init = &(struct clk_init_data){
        .name = 'fixed_pll',
        .num_parents = 0,
        .ops = &clk_fixed_rate_ops,
    },
};
static struct clk_hw_onecell_data fake_fixed_hw_onecell_data = {
    .hws = {
        [CLKID_XTAL]	= &clk_hw_xtal.hw,
        [CLKID_PLL_FIXED]	= &clk_hw_pll.hw,
        [CLK_NR_CLKS]	= NULL,
    },
    .num = CLK_NR_CLKS,
};
```

这样，我们就定义了我们的时钟。 以下代码显示如何在系统上注册这些时钟：

```sh
static int fake_fixed_clkc_probe(struct platform_device *pdev)
{
    int ret, i;
    struct device *dev = &pdev->dev;
    for (i = CLKID_XTAL; i < CLK_NR_CLKS; i++) {
        ret = devm_clk_hw_register(dev, 
                            fake_fixed_hw_onecell_data.hws[i]);
        if (ret)
            return ret;
    }
    return devm_of_clk_add_hw_provider(dev,                                   of_clk_hw_onecell_get,
                                  &fake_fixed_hw_onecell_data);
}
static const struct of_device_id fake_fixed_clkc_match_table[] = {
    { .compatible = 'l.abcsmart,fake-fixed-clkc' },
    { }
};
static struct platform_driver meson8b_driver = {
    .probe	= fake_fixed_clkc_probe,
    .driver	= {
        .name	= 'fake-fixed-clkc',
        .of_match_table = fake_fixed_clkc_match_table,
    },
};
```

#### 一般 Simpliﬁ阳离子注意事项

在前面的摘录中，我们使用`clk_hw_register()`来注册时钟。 该接口是基本注册接口，可用于注册任何类型的时钟。 它的主要参数是指向嵌入在底层时钟类型结构中的`struct clk_hw`结构的指针。

通过调用`clk_hw_register()`进行时钟初始化和注册需要填充`struct clk_init_data`(从而实现`clk_ops`)对象，该对象与`clk_hw`捆绑在一起。 或者，您可以使用特定于硬件(即，依赖于时钟类型)的注册功能。 在这里，内核负责在内部调用`clk_hw_register(...)`之前，根据时钟类型从提供给函数的参数构建适当的`init`数据。 在此替代方案中，CCF 将根据时钟硬件类型提供适当的`clk_ops`。

通常，时钟提供程序不需要直接使用或分配基准时钟类型，在本例中为`struct clk_fixed_rate`。 这是因为内核时钟框架为此提供了专用接口。 在实际场景中(有固定时钟)，此专用接口将为`clk_hw_register_fixed_rate()`：

```sh
struct clk_hw *
    clk_hw_register_fixed_rate(struct device *dev,                                const char *name,
                               const char *parent_name,                                unsigned long flags,
                               unsigned long fixed_rate)
```

`clk_register_fixed_rate()`接口使用时钟的`name`、`parent_name`和`fixed_rate`作为参数来创建具有固定频率的时钟。 `flags`表示特定于框架的标志，而`dev`是注册时钟的设备。 时钟的`clk_ops`属性也由时钟框架提供，不需要提供者关心它。 这种时钟的内核时钟 OPS 数据结构为`clk_fixed_rate_ops`。 在`drivers/clk/clk-fixed-rate.c`中定义如下：

```sh
static unsigned long
    clk_fixed_rate_recalc_rate(struct clk_hw *hw,
                               unsigned long parent_rate)
{
    return to_clk_fixed_rate(hw)->fixed_rate;
}
static unsigned long
    clk_fixed_rate_recalc_accuracy(struct clk_hw *hw,
                                unsigned long parent_ accuracy)
{
    return to_clk_fixed_rate(hw)->fixed_accuracy;
}
const struct clk_ops clk_fixed_rate_ops = {
    .recalc_rate = clk_fixed_rate_recalc_rate,
    .recalc_accuracy = clk_fixed_rate_recalc_accuracy,
};
```

`clk_register_fixed_rate()`返回指向固定速率时钟的底层`clk_hw`结构的指针。 然后，代码可以使用`to_clk_fixed_rate`宏来获取指向原始时钟类型结构的指针。

但是，您仍然可以使用低级`clk_hw_register()`注册接口，并重用 CCF 提供的一些操作回调。 CCF 为您的时钟提供了适当的操作结构，但这并不意味着您应该按原样使用它。 您可能不希望使用与时钟类型相关的注册接口(改为使用`clock_hw_register()`)，而是使用 CCF 提供的一个或多个单独的操作。 这不仅适用于可调时钟(如下例所示)，也适用于我们将在本书中讨论的所有其他时钟类型。

让我们来看一个来自`drivers/clk/clk-stm32f4.c`的时钟分频器驱动器的示例：

```sh
static unsigned long stm32f4_pll_div_recalc_rate(                                     struct clk_hw *hw, 
                                     unsigned long parent_rate)
{
    return clk_divider_ops.recalc_rate(hw, parent_rate);
}
static long stm32f4_pll_div_round_rate(struct clk_hw *hw,
                                       unsigned long rate,                                        unsigned long *prate)
{
    return clk_divider_ops.round_rate(hw, rate, prate);
}
static int stm32f4_pll_div_set_rate(struct clk_hw *hw,
                                    unsigned long rate,                                     unsigned long parent_rate)
{
    int pll_state, ret;
    struct clk_divider *div = to_clk_divider(hw);
    struct stm32f4_pll_div *pll_div = to_pll_div_clk(div);
    pll_state = stm32f4_pll_is_enabled(pll_div->hw_pll);
    if (pll_state)
        stm32f4_pll_disable(pll_div->hw_pll);
    ret = clk_divider_ops.set_rate(hw, rate, parent_rate);
    if (pll_state)
        stm32f4_pll_enable(pll_div->hw_pll);
    return ret;
}
static const struct clk_ops stm32f4_pll_div_ops = {
    .recalc_rate = stm32f4_pll_div_recalc_rate,
    .round_rate = stm32f4_pll_div_round_rate,
    .set_rate = stm32f4_pll_div_set_rate,
};
```

在前面的摘录中，驱动器仅实现`.set_rate`运算，并重复使用 CCF 提供的时钟分频器运算(称为`clk_divider_ops`)的`.recalc_rate`和`.round_rate`属性。

#### 固定时钟设备绑定

这种类型的时钟也可以由 DTS 配置原生地直接支持，而无需编写任何代码。 这种基于设备树的接口通常用于提供虚拟时钟。 在某些情况下，设备树中的某些设备可能需要时钟节点来描述它们自己的时钟输入。 例如，*mcp2515*SPI 到 CAN 转换器需要配备时钟，以使其知道所连接的石英的频率。 对于这样的虚拟时钟节点，Compatible 属性应该是`fixed-clock`。 下面是一个这样的例子：

```sh
/* fixed crystal dedicated to mpc251x */
clocks {
    /* fixed crystal dedicated to mpc251x */
    clk8m: clk@1 {
        compatible = 'fixed-clock';
        reg=<0>;
        #clock-cells = <0>;
        clock-frequency = <8000000>;
        clock-output-names = 'clk8m';
    };
};
/* consumer */
can1: can@1 {
    compatible = 'microchip,mcp2515';
    reg = <0>;
    spi-max-frequency = <10000000>;
    clocks = <&clk8m>;
};
```

时钟框架的内核将直接提取 DTS 提供的时钟信息，并自动将其注册到内核，而不需要任何驱动程序支持。 这里`#clock-cells`是 0，因为只提供了一条固定速率线路d，在这种情况下，说明符只需要是提供商的`phandle`。

#### PWM 时钟替代

由于缺少输出时钟源(时钟焊盘)，一些电路板设计者(对或错)使用 PWM 输出焊盘作为外部元件的时钟源。 这种时钟仅从设备树实例化。 此外，由于 PWM 绑定需要指定 PWM 信号的周期，因此`pwm-clock`属于固定速率时钟类别。 这样的实例化示例可以在以下代码中看到，该代码摘录自`imx6qdl-sabrelite.dtsi`：

```sh
mipi_xclk: mipi_xclk {
    compatible = 'pwm-clock';
    #clock-cells = <0>;
    clock-frequency = <22000000>;
    clock-output-names = 'mipi_pwm3';
    pwms = <&pwm3 0 45>; /* 1 / 45 ns = 22 MHz */
    status = 'okay';
};
ov5640: camera@40 {
    compatible = 'ovti,ov5640';
    pinctrl-names = 'default';
    pinctrl-0 = <&pinctrl_ov5640>;
    reg = <0x40>;
    clocks = <&mipi_xclk>;
    clock-names = 'xclk';
    DOVDD-supply = <&reg_1p8v>;
    AVDD-supply = <&reg_2p8v>;
    DVDD-supply = <&reg_1p5v>;
    reset-gpios = <&gpio2 5 GPIO_ACTIVE_LOW>;
    powerdown-gpios = <&gpio6 9 GPIO_ACTIVE_HIGH>;
[...]
};
```

如您所见，`compatible`属性应该是`pwm-clock`，而`#clock-cells`应该是`<0>`。 该时钟类型驱动器位于`drivers/clk/clk-pwm.c`，关于此的进一步读数可在`Documentation/devicetree/bindings/clock/pwm-clock.txt`找到。

### 固定因数时钟驱动器及其运算

这种类型的时钟将父速率除以常量并将其相乘(因此它是固定因数时钟驱动器)。 此时钟无法报时：

```sh
struct clk_fixed_factor {
    struct clk_hw	hw;
    unsigned int		mult;
    unsigned int		div;
};
#define to_clk_fixed_factor(_hw) \
             container_of(_hw, struct clk_fixed_factor, hw)
```

时钟的频率由父时钟的频率决定，乘以`mult`，然后将除以`div`。 它实际上是一个**固定乘法器和除法器**时钟。 固定因子时钟更改其速率的唯一方法是更改其父速率。 在这种情况下，您需要设置`CLK_SET_RATE_PARENT`标志。 由于父时钟的频率可以改变，固定因数时钟的频率也可以改变，因此还提供了`.recalc_rate`/`.set_rate/.round_rate`等回调。 也就是说，如果设置了`CLK_SET_RATE_PARENT`标志，则设置速率请求将向上传播，因此这种时钟的`.set_rate`回调需要返回 0 以确保其调用是有效的**NOP**(**无操作**)：

```sh
static int clk_factor_set_rate(struct clk_hw *hw,                                unsigned long rate,
                               unsigned long parent_rate)
{
    return 0;
}
```

对于这类时钟，最好使用称为`clk_fixed_factor_ops`的时钟框架提供程序助手操作，它在`drivers/clk/clk-fixed-factor.c`中定义和实现如下：

```sh
const struct clk_ops clk_fixed_factor_ops = {
    .round_rate = clk_factor_round_rate,
    .set_rate = clk_factor_set_rate,
    .recalc_rate = clk_factor_recalc_rate,
};
EXPORT_SYMBOL_GPL(clk_fixed_factor_ops);
```

使用它的好处是，您不再需要关心操作，因为内核已经为您设置好了一切。 它的`round_rate`和`recalc_rate`回调甚至会处理`CLK_SET_RATE_PARENT`标志，这意味着我们可以坚持我们的简化路径。 此外，最好使用时钟框架助手接口注册这样的时钟；即`clk_hw_register_fixed_factor()`：

```sh
struct clk_hw *
    clk_hw_register_fixed_factor(struct device *dev,                                  const char *name,
                                 const char *parent_name,                                  unsigned long flags, 
                                 unsigned int mult,                                  unsigned int div)
```

此接口在内部设置一个动态分配的`struct clk_fixed_factor`，然后返回一个指向底层`struct clk_hw`的指针。 您可以将其与`to_clk_fixed_factor`宏一起使用，以获取指向原始固定因数时钟结构的指针。 分配给时钟的操作是`clk_fixed_factor_ops`，正如前面讨论的。 此外，这种类型的接口类似于固定 RaTE 时钟。 您不需要提供驱动程序。 您只需配置设备树。

#### 固定因数时钟的设备树绑定

您可以在内核源代码中找到这种简单的固定因子速率时钟在`Documentation/devicetree/bindings/clock/fixed-factor-clock.txt`的绑定文档。 所需属性如下：

*   `#clock-cells`：根据公共时钟绑定设置为 0。
*   `compatible`：这将是`'fixed-factor-clock'`。
*   `clock-div`：固定分隔器。
*   `clock-mult`：固定乘数。
*   `clocks`：父时钟的`phandle`。

下面是一个例子：

```sh
clock {
    compatible = 'fixed-factor-clock';
    clocks = <&parentclk>;
    #clock-cells = <0>;
    clock-div = <2>;
    clock-mult = <1>;
};
```

既然固定因数时钟已被寻址，下一个逻辑步骤将是查看另一种简单时钟类型--可选通时钟。

### 门控时钟及其操作

这种类型的时钟只能切换，因此只有提供`.enable`/`.disable`回调才能使在这里有意义：

```sh
struct clk_gate {
    struct clk_hw hw;
    void  iomem	*reg;
    u8	bit_idx;
    u8	flags;
    spinlock_t	*lock;
};
#define to_clk_gate(_hw) container_of(_hw, struct clk_gate, hw)
```

让我们更详细地看看前面的结构：

*   `reg`：表示控制时钟开关的寄存器地址(虚拟地址，即 MMIO)。
*   `bit_idx`：这是时钟开关的控制位(可以是 1 或 0，设置门的状态)。
*   `clk_gate_flags`: This represents the gate-specific flags of the gate clock. These are as follows:

    --`CLK_GATE_SET_TO_DISABLE`：这是时钟开关的控制模式。 如果设置，写入`1`将关闭时钟，写入`0`将打开时钟。

    --`CLK_GATE_HIWORD_MASK`：有些寄存器使用`reading-modifying-writing`的概念进行位级操作，而其他寄存器只支持**组字掩码**。 **高位字掩码**是这样一种概念，其中(在 32 位寄存器中)改变给定索引处的位(在`0`和`15`之间)包括改变`16`低位(`0`到 15)中的相应位，并且屏蔽 16 位高位(`16`到`31`，因此是高位字)中的相同位索引，以便指示/验证改变。例如，如果位`b1`需要被设置为栅极， 它还需要通过设置 hiword 掩码来指示更改(`b1 << 16`)。 这意味着门设置真正位于寄存器的较低 16 位，而门位的掩码位于该寄存器的较高`16`位。 设置该标志时，`bit_idx`不应高于`15`。

*   `lock`：这是时钟开关需要互斥时应使用的自旋锁。

正如您可能已经猜到的，此结构假定时钟门寄存器为MMIO。 对于之前的时钟类型，最好使用提供的内核接口来处理这样的时钟，即`clk_hw_register_gate()`：

```sh
struct clk_hw *
    clk_hw_register_gate(struct device *dev, const char *name,
                         const char *parent_name,                          unsigned long flags,
                         void iomem *reg, u8 bit_idx,
                         u8 clk_gate_flags, spinlock_t *lock);
```

此接口的某些参数与我们关于时钟类型结构描述的参数相同。 此外，以下是需要说明的额外参数：

*   `dev`是记录时钟的设备。
*   `name`是时钟的名称。
*   `parent_name`是父时钟的名称，如果没有父时钟，则该名称应为 NULL。
*   `flags`表示此时钟的框架特定标志。 通常为具有父级的门控时钟设置`CLK_SET_RATE_PARENT`标志，以便速率更改请求向上传播一个级别。
*   `clk_gate_flags`对应于时钟类型结构中的`.flags`。

此接口返回指向时钟门结构底层`struct clh_hw`的指针。 在这里，您可以使用`to_clk_gate`帮助器宏获取原始的时钟门结构。

在设置该时钟并在其注册之前，时钟框架将`clk_gate_ops`操作分配给它。 这实际上是门控时钟的默认操作。 它依赖于时钟通过 MMIO 寄存器控制的事实：

```sh
const struct clk_ops clk_gate_ops = {
    .enable = clk_gate_enable,
    .disable = clk_gate_disable,
    .is_enabled = clk_gate_is_enabled,
};
EXPORT_SYMBOL_GPL(clk_gate_ops);
```

整个门时钟 API 在`drivers/clk/clk-gate.c`中定义。 这样的时钟驱动器可以在内核源代码树中的`drivers/clk/clk-asm9260.c`中找到，而它的设备树 binding 可以在`Documentation/devicetree/bindings/clock/alphascale,acc.txt`中找到。

#### 基于 I2C/SPI 的门时钟

不只是 MMIO外围设备可以提供栅极时钟。 I2C/SPI 总线后面也有可提供此类时钟的分立芯片。 显然，您不能依赖我们前面介绍的结构(`struct clk_gate`)或接口助手(`clk_hw_register_gate()`)来开发此类芯片的驱动程序。 主要原因如下：

*   前述接口和数据结构假设时钟门寄存器控制为 MMIO，这里肯定不是这种情况。
*   标准栅极时钟操作为`.enable`和`.disable`。 然而，这些回调不需要休眠，因为它们是在保持自旋锁的情况下调用的，但我们都知道 I2C/SPI 寄存器访问可能会休眠。

这两个限制都有解决办法：

*   与使用特定于门的时钟框架助手不同，您可以使用低级`clk_hw_register()`接口来控制时钟的参数，从其标志到其操作。
*   您可以在`.prepare`/`.unprepare`回调中实现`.enable`/`.disable`逻辑。 记住，`.prepare`/`.unprepare`操作员可以休眠。 这是可以保证工作的，因为消费者侧要求在调用`clk_enable()`之前调用`clk_prepare()`，然后通过调用`clk_unprepare()`来跟随对`clk_disable()`的调用。 通过这样做，任何对`clk_enable()`(映射到提供者的`.enable`回调)的使用者调用都将立即返回。 但是，因为它之前总是有一个对`clk_prepare()`的消费者调用(映射到`.prepare`回调)，所以我们可以确定我们的时钟将被取消门控。 同样的道理也适用于`clk_disable`(映射到`.disable`回调)，它保证我们的时钟将被选通。

该时钟驱动器实现可以在`drivers/clk/clk-max9485.c`中找到，而它的设备树绑定在g 中可以在内核源代码树中的`Documentation/devicetree/bindings/clock/maxim,max9485.txt`中找到。

#### GPIO 门时钟替代方案

这是一个基本的时钟，可以通过 GPIO 输出启用和禁用。 `gpio-gate-clock`实例只能从设备树实例化。 为此，`compatible`属性应为`gpio-gate-clock`，`#clock-cells`应为`<0>`，如以下摘录自`imx6qdl-sr-som-ti.dtsi`所示：

```sh
clk_ti_wifi: ti-wifi-clock {
    compatible = 'gpio-gate-clock';
    #clock-cells = <0>;
    clock-frequency = <32768>;
    pinctrl-names = 'default';
    pinctrl-0 = <&pinctrl_microsom_ti_clk>;
    enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
};
pwrseq_ti_wifi: ti-wifi-pwrseq {
    compatible = 'mmc-pwrseq-simple';
    pinctrl-names = 'default';
    pinctrl-0 = <&pinctrl_microsom_ti_wifi_en>;
    reset-gpios = <&gpio5 26 GPIO_ACTIVE_LOW>;
    post-power-on-delay-ms = <200>;
    clocks = <&clk_ti_wifi>; 
    clock-names = 'ext_clock';
};
```

该时钟类型驱动器位于`drivers/clk/clk-gpio.c`中，更多读数可在`Documentation/devicetree/bindings/clock/gpio-gate-clock.txt`中找到。

### 时钟多路复用器及其运算器

时钟多路复用器具有多个输入时钟信号或父母，其中只能选择一个作为输出。 由于这种类型的时钟可以从多个父级中选择，因此应该实现`.get_parent`/`.set_parent`/`.recalc_rate`回调。 CCF 中的多路复用时钟由`struct clk_mux`的实例表示，如下所示：

```sh
struct clk_mux {
    struct clk_hw hw;
    void __iomem *reg;
    u32	*table;
    u32	mask;
    u8	shift;
    u8	flags;
    spinlock_t	*lock;
};
#define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)
```

让我们看一下前面结构中显示的元素：

*   `table`是对应于父索引的寄存器值的数组。
*   `mask`和`shift`用于在获得适当的值之前修改`reg`位字段。
*   `reg`是用于父母选择的 MMIO 寄存器。 默认情况下，当寄存器的值为 0 时，它对应于第一个父级，依此类推。 如果有例外，可以使用各种`flags`，以及另一个接口。
*   `flags` represents the unique flags of the mux clock, which are as follows:

    --`CLK_MUX_INDEX_BIT`：寄存器值是 2 的幂。我们稍后会看看它是如何工作的。

    --`CLK_MUX_HIWORD_MASK`：这使用了我们前面解释过的 hiword 掩码的概念。

    --`CLK_MUX_INDEX_ONE`：寄存器值不是从 0 开始，而是从 1 开始，这意味着最终的值应该加 1。

    --`CLK_MUX_READ_ONLY`：某些平台具有只读时钟多路复用器，这些时钟多路复用器是在重置时预先配置的，在运行时不能更改。

    --`CLK_MUX_ROUND_CLOSEST`：该标志使用最接近所需频率的父速率。

*   如果提供了`lock`，则用于保护对寄存器的访问。

用于注册这样的时钟的 CCF 助手是`clk_hw_register_mux()`。 如下所示：

```sh
struct clk_hw *
    clk_hw_register_mux(struct device *dev, const char *name,
                        const char * const *parent_names,
                        u8 num_parents, unsigned long flags,
                        void iomem *reg, u8 shift, u8 width,
                        u8 clk_mux_flags, spinlock_t *lock)
```

在描述多路复用时钟结构时，介绍了前面注册接口中的一些参数。 其余参数如下：

*   `parent_names`：这是描述所有可能的父时钟的字符串数组。
*   `num_parents`：指定父时钟数。

在注册这样的时钟时，根据是否设置了`CLK_MUX_READ_ONLY`标志，CCF分配不同的时钟操作。 如果设置，则使用`clk_mux_ro_ops`。 此时钟操作仅实现`.get_parent`操作，因为没有方法来更改父级。 如果未设置，则使用`clk_mux_ops`。 此操作实现`.get_parent`、`.set_parent`和`.determine_rate`，如下所示：

```sh
if (clk_mux_flags & CLK_MUX_READ_ONLY)
    init.ops = &clk_mux_ro_ops;
else
    init.ops = &clk_mux_ops;
```

这些时钟操作定义如下：

```sh
const struct clk_ops clk_mux_ops = {
    .get_parent = clk_mux_get_parent,
    .set_parent = clk_mux_set_parent,
    .determine_rate = clk_mux_determine_rate,
};
EXPORT_SYMBOL_GPL(clk_mux_ops);
const struct clk_ops clk_mux_ro_ops = {
    .get_parent = clk_mux_get_parent,
};
EXPORT_SYMBOL_GPL(clk_mux_ro_ops);
```

在前面的代码中，有一个`.table`字段。 这用于根据父索引提供一组值。 但是，前面的注册接口`clk_hw_register_mux()`并没有为我们提供任何提供该表的方式。

因此，CCF 中有另一个变量允许我们通过该表：

```sh
struct clk *
    clk_register_mux_table(struct device *dev,                            const char *name,
                           const char **parent_names,                            u8 num_parents, 
                           unsigned long flags,                            void iomem *reg, u8 shift, u32 mask,
u8 clk_mux_flags, u32 *table, spinlock_t *lock);
```

接口寄存器多路复用器，通过表控制不规则时钟。 无论注册接口是什么，都使用相同的内部操作。 现在，让我们特别关注最重要的几个，即`.set_parent`和`.get_parent`：

*   `clk_mux_set_parent`：调用此函数时，如果`table`不是`NULL`，则它从`table`中的索引获取寄存器值。 如果`table`为`NULL`并且设置了`CLK_MUX_INDEX_BIT`标志，则这意味着寄存器值是根据`index`的 2 的幂。 然后使用`val = 1 << index`获得该值；如果设置了`CLK_MUX_INDEX_ONE`，则该值加 1。 如果`table`为`NULL`且未设置`CLK_MUX_INDEX_BIT`，则将`index`用作默认值。 在这两种情况下，最终值在`shift`时左移，并在我们获得实际值之前与掩码进行 OR 运算。 应写入`reg`以进行亲本选择：

    ```sh
    unsigned int
       clk_mux_index_to_val(u32 *table, unsigned int flags,                         u8 index)
    {
        unsigned int val = index;
        if (table) {
            val = table[index];
        } else {
            if (flags & CLK_MUX_INDEX_BIT)
                val = 1 << index;
            if (flags & CLK_MUX_INDEX_ONE) val++;
        }
        return val;
    }
    static int clk_mux_set_parent(struct clk_hw *hw,                               u8 index)
    {
        struct clk_mux *mux = to_clk_mux(hw);
        u32 val =
            clk_mux_index_to_val(mux->table, mux->flags,                             index);
        unsigned long flags = 0; u32 reg;
        if (mux->lock)
            spin_lock_irqsave(mux->lock, flags);
        else
            __acquire(mux->lock);
        if (mux->flags & CLK_MUX_HIWORD_MASK) {
            reg = mux->mask << (mux->shift + 16);
        } else {
            reg = clk_readl(mux->reg);
            reg &= ~(mux->mask << mux->shift);
        }
        val = val << mux->shift; reg |= val;
        clk_writel(reg, mux->reg);
        if (mux->lock)
            spin_unlock_irqrestore(mux->lock, flags);
        else
            __release(mux->lock);
        return 0;
    }
    ```

*   `clk_mux_get_parent`：这将读取`reg`中的值，将其`shift`时间右移，并在获得实际值之前对其应用(AND 运算)`mask`。 然后将该值提供给`clk_mux_val_to_index()`帮助器，该帮助器将根据`reg`值返回正确的索引。 `clk_mux_val_to_index()`首先获取给定时钟的父级数。 如果`table`不是`NULL`，则使用该数字作为循环中遍历`table`的上限。 每次迭代将检查当前位置处的`table`值是否与`val`匹配。 如果是，则返回迭代中的当前位置。 如果未找到匹配项，则返回错误。 `ffs()`返回字中设置的第一个(最低有效)位的位置：

    ```sh
    int clk_mux_val_to_index(struct clk_hw *hw, u32 *table,
                             unsigned int flags,                          unsigned int val)
    {
        int num_parents = clk_hw_get_num_parents(hw);
        if (table) {
            int i;
            for (i = 0; i < num_parents; i++)
                if (table[i] == val)
                    return i;
            return -EINVAL;
        }
        if (val && (flags & CLK_MUX_INDEX_BIT))
            val = ffs(val) - 1;
        if (val && (flags & CLK_MUX_INDEX_ONE))
            val--;
        if (val >= num_parents)
            return -EINVAL;
        return val;
    }
    EXPORT_SYMBOL_GPL(clk_mux_val_to_index);
    static u8 clk_mux_get_parent(struct clk_hw *hw)
    {
        struct clk_mux *mux = to_clk_mux(hw);
        u32 val;
        val = clk_readl(mux->reg) >> mux->shift;
        val &= mux->mask;
        return clk_mux_val_to_index(hw, mux->table,                                 mux->flags, val);
    }
    ```

这样的驱动器的示例可以在`drivers/clk/microchip/clk-pic32mzda.c`中找到。

#### 基于 I2C/SPI 的时钟复用器

前述用于处理时钟多路复用的CCF 接口假定控制是通过 MMIO 寄存器提供的。 但是，有些基于 I2C/SPI 的时钟多路复用器芯片必须依赖低电平`clk_hw`(使用基于`clk_hw_register()`寄存器的接口)接口，并根据每个时钟的属性注册每个时钟，然后才能提供适当的操作。

每个多路复用器输入时钟都应该是多路复用器输出的父时钟，多路复用器输出必须至少有`.set_parent`和`.get_parent`个操作。 其他操作也是允许的，但不是强制性的。 一个具体的例子是 Silicon Labs 的`Si5351a/b/c`可编程 I2C 时钟发生器的 Linux 驱动程序，可在内核源代码的`drivers/clk/clk-si5351.c`中找到。 它的设备树绑定在`Documentation/devicetree/bindings/clock/silabs,si5351.txt`中可用。

重要音符

要编写这样的时钟驱动程序，您必须了解`clk_hw_register_mux`是如何实现的，并基于 yo您的注册函数，而不是 MMIO/Spinlock 部分，然后根据时钟的属性提供您自己的操作。

#### GPIO 多路复用器时钟替代方案

GPIO 多路复用器时钟可以用表示如下：

![Figure 4.2 – GPIO mux clock ](image/Figure_4.2_B10985.jpg)

图 4.2-GPIO 复用器时钟

对于仅接受两个父级的时钟多路复用而言，这是一种有限的替代方案，如`drivers/clk/clk-gpio.c`中提供的以下驱动器摘录所述。 在这种情况下，父选择取决于正在使用的 GPIO 的值：

```sh
struct clk_hw *clk_hw_register_gpio_mux(struct device *dev,
                                   const char *name,
                                   const char *                                    const *parent_names,
                                   u8 num_parents,
                                   struct gpio_desc *gpiod,
                                   unsigned long flags)
{
    if (num_parents != 2) {
        pr_err('mux-clock %s must have 2 parents\n', name);
        return ERR_PTR(-EINVAL);
    }
    return clk_register_gpio(dev, name, parent_names,                              num_parents,
                             gpiod, flags, &clk_gpio_mux_ops);
}
EXPORT_SYMBOL_GPL(clk_hw_register_gpio_mux);
```

根据其绑定，它只能在设备树中实例化。 这个绑定可以在内核源代码的`Documentation/devicetree/bindings/clock/gpio-mux-clock.txt`中找到。 以下示例显示如何使用它：

```sh
clocks {
    /* fixed clock oscillators */
    parent1: oscillator22 {
        compatible = 'fixed-clock';
        #clock-cells = <0>;
        clock-frequency = <22579200>;
    };
    parent2: oscillator24 {
        compatible = 'fixed-clock';
        #clock-cells = <0>;
        clock-frequency = <24576000>;
    };
    /* gpio-controlled clock multiplexer */
    mux: multiplexer {
        compatible = 'gpio-mux-clock';
        clocks = <&parent1>, <&parent2>;
        /* parent clocks */
        #clock-cells = <0>;
        select-gpios = <&gpio 42 GPIO_ACTIVE_HIGH>;
    };
};
```

这里，我们看了一下时钟多路复用器，它允许我们从 API 和设备树绑定中选择时钟源。 此外，我们还引入了基于 GPIO 的时钟多路复用器替代方案，它不需要我们编写任何代码。 本系列中的下一个 c锁类型是分频器时钟，顾名思义，它将父速率除以给定的比率。

### (可调)分频器时钟及其操作

这种类型的时钟对父速率进行分频，不能选通。 由于您可以设置分频器比率，因此必须提供`.recalc_rate`/`.set_rate`/`.round_rate`回调。 时钟分频器在内核中表示为`struct clk_divider`的实例。 这可以定义为：

```sh
struct clk_divider {
    struct clk_hw  hw;
    void iomem	*reg;
    u8	shift;
    u8	width;
    u8	flags;
    const struct clk_div_table	*table;
    spinlock_t	*lock;
};
#define to_clk_divider(_hw) container_of(_hw,                                          struct clk_divider,                                          hw)
```

让我们来看看这个结构中的元素：

*   `hw`：定义提供程序端的底层`clock_hw`结构。
*   `reg`：这是控制时钟分频比的寄存器。 默认情况下，实际分频器值是寄存器值加 1。 如果有其他例外，可以参考`flags`字段描述进行适配。
*   `shift`：这控制寄存器中分频比位的偏移量。
*   `width`：这是分频器位字段的宽度。 它控制分频比的位数。 例如，如果`width`是 4，这意味着分频比被编码在 4 比特上。
*   `flags`: This is the divider-clock-specific flag of the clock. Various flags can be used here, some of which are as follows:

    --`CLK_DIVIDER_ONE_BASED`：设置时，这意味着除数是从寄存器读取的原始值，因为默认除数是从寄存器读取的值加 1。 这也意味着 0 无效，除非设置了`CLK_DIVIDER_ALLOW_ZERO`标志。

    --`CLK_DIVIDER_ROUND_CLOSEST`：当我们希望能够将分隔符舍入到最接近且计算得最好的分隔符时，而不是仅四舍五入(默认行为)时，应使用此选项。

    --`CLK_DIVIDER_POWER_OF_TWO`：实际分频器值为 2 的幂的寄存器值。

    --`CLK_DIVIDER_ALLOW_ZERO`：分频器值可以为 0(不变，取决于硬件支持)。

    --`CLK_DIVIDER_HIWORD_MASK`：有关此标志的更多详细信息，请参阅*可选通时钟及其操作*部分。

    --`CLK_DIVIDER_READ_ONLY`：该标志表示时钟有预先配置的设置，并指示框架不要更改任何内容。 此标志还会影响已分配给时钟的操作。

    `CLK_DIVIDER_MAX_AT_ZERO`：这允许时钟分频器在设置为零时具有最大除数。 因此，如果字段值为零，则除数值的宽度应为 2 位。 例如，让我们考虑一个具有 2 位字段的除数时钟：

    ```sh
    Value		divisor
    0		4
    1		1
    2		2
    3		3
    ```

*   `table`：这是一个值/分隔符对的数组，其最后一个条目应为`div = 0`。 我们将很快对此进行描述。
*   `lock`：与其他时钟数据结构一样，如果提供，它用于保护对寄存器的访问。
*   `clk_hw_register_divider()`：这是此类时钟最常用的注册接口。 其定义如下：

```sh
struct clk_hw *
    clk_hw_register_divider(struct device *dev,
                            const char *name,                             const char *parent_name, 
                            unsigned long flags,                             void iomem *reg,
                            u8 shift, u8 width,                             u8 clk_divider_flags, 
                            spinlock_t *lock)
```

此函数向系统注册分频器时钟，并返回指向底层`clk_hw`字段的指针。 在这里，您可以使用`to_clk_divider`宏来获取指向包装器的`clk_divider`结构的指针。 除了分别表示时钟名称和父级名称的`name`和`parent_name`之外，此函数中的其他参数都与`struct clk_divider`结构中描述的字段匹配。

您可能已经注意到，这里没有使用`.table`字段。 此字段有些特殊，因为它用于分频比不常见的时钟分频器。 实际上，存在时钟分频器，其中每条单独的时钟线具有多个与彼此的时钟线无关的分频比。 有时，每个比率与寄存器值之间甚至没有任何线性关系。 对于这种情况，最好的解决方案是为每条时钟线提供一个表，其中每个比率对应于其寄存器值。 这需要我们引入一个新的注册接口来接受这样的表；即`clk_hw_register_divider_table`。 这可以定义为：

```sh
struct clk_hw *
     clk_hw_register_divider_table(                            struct device *dev,
                            const char *name,                             const char *parent_name, 
                            unsigned long flags,                             void iomem *reg,
                            u8 shift, u8 width,                             u8 clk_divider_flags, 
                            const struct clk_div_table *table, 
                            spinlock_t *lock)
```

与前面的接口相比，该接口用于寄存具有不规则分频比的时钟。 区别 I在于分频器的值和寄存器的值之间的关系由`struct clk_div_table`类型的表确定。 此表结构可以定义如下：

```sh
struct clk_div_table {
    unsigned int	val;
    unsigned int	div;
};
```

在前面的代码中，`val`表示寄存器值，而`div`表示分频比。 它们的关系也可以通过使用`clk_divider_flags`来更改。 无论使用什么寄存器接口，`CLK_DIVIDER_READ_ONLY`标志确定要分配给时钟的操作，如下所示：

```sh
if (clk_divider_flags & CLK_DIVIDER_READ_ONLY)
    init.ops = &clk_divider_ro_ops;
else
    init.ops = &clk_divider_ops;
```

这两个时钟操作都在`drivers/clk/clk-divider.c`中定义，如下所示：

```sh
const struct clk_ops clk_divider_ops = {
    .recalc_rate = clk_divider_recalc_rate,
    .round_rate = clk_divider_round_rate,
    .set_rate = clk_divider_set_rate,
};
EXPORT_SYMBOL_GPL(clk_divider_ops);
const struct clk_ops clk_divider_ro_ops = {
    .recalc_rate = clk_divider_recalc_rate,
    .round_rate = clk_divider_round_rate,
};
EXPORT_SYMBOL_GPL(clk_divider_ro_ops);
```

前者可以设置时钟频率，而后者不能。

重要音符

同样，到目前为止，使用内核提供的依赖于时钟类型的注册接口要求您的时钟是 MMIO。 为非基于 MMIO(SPI 或 I2C)的时钟实现这样的时钟驱动器需要使用低电平`hw_clk`寄存器接口并实现适当的操作。 在`drivers/clk/clk-max9485.c`中可以找到用于基于 I2C 的时钟的这种驱动器的示例，以及所实现的适当操作 c。 它的绑定可以在`Documentation/devicetree/bindings/clock/maxim,max9485.txt`中找到。 这是一个比分频器更具可调性的时钟驱动器。

可调节的时钟对我们来说再也没有秘密了。 已经描述了它的 API和操作，以及它是如何处理不规则比率的。 接下来，我们来看一下最后的时钟类型，它混合了我们到目前为止看到的所有时钟类型：复合时钟。

### 复合钟及其运算

此时钟用于组合使用多路复用器、分频器和门组件的时钟分支。 大多数 RockChip SoC 都是这种情况。 时钟框架通过`struct clk_composite`对这些时钟进行抽象，如下所示：

```sh
struct clk_composite {
    struct clk_hw	hw;
    struct clk_ops	ops;
    struct clk_hw	*mux_hw;
    struct clk_hw	*rate_hw;
    struct clk_hw	*gate_hw;
    const struct clk_ops	*mux_ops;
    const struct clk_ops	*rate_ops;
    const struct clk_ops	*gate_ops;
};
#define to_clk_composite(_hw) container_of(_hw,                                           struct clk_composite,                                          hw)
```

此数据结构中的字段非常简单明了，如下所示：

*   与其他时钟结构一样，`hw`是公共接口和硬件特定接口之间的句柄。
*   `mux_hw`表示多路复用器时钟。
*   `rate_hw`表示分频器时钟。
*   `gate_hw`表示门控时钟。
*   `mux_ops`、`rate_ops`和`gate_ops`分别是多路复用器、速率和门的时钟操作。

这样的时钟可以通过以下接口注册：

```sh
struct clk_hw *clk_hw_register_composite(
             struct device *dev, const char *name,
             const char * const *parent_names, int num_parents,
             struct clk_hw *mux_hw,              const struct clk_ops *mux_ops,
             struct clk_hw *rate_hw,              const struct clk_ops *rate_ops,
             struct clk_hw *gate_hw,              const struct clk_ops *gate_ops,
             unsigned long flags)
```

这看起来可能有点复杂，但是如果您看过上一个时钟，这个时钟将或多或少地对您来说是显而易见的。 请看内核源代码中的`drivers/clk/sunxi/clk-a10-hosc.c`，以获得复合时钟驱动程序的示例。

## 将其整合在一起-全球概述

如果你还不明白，那就看看下面的图表吧：

![Figure 4.3 – Clock tree example ](image/Figure_4.3_B10985.jpg)

图 4.3-时钟树示例

前面的时钟树显示了为三个 PLL(即`pll1`、`pll2`和`pll3`)供电的振荡器时钟以及一个多路复用器。 根据多路复用器(MUX)，可以从`pll2`、`pll3`或`osc`时钟导出`hw3_clk`。

以下设备树摘录可用于模拟前面的时钟树：

```sh
osc: oscillator {
    #clock-cells = <0>;
    compatible = 'fixed-clock';
    clock-frequency = <20000000>;
    clock-output-names = 'osc20M';
};
pll2: pll2 {
    #clock-cells = <0>;
    compatible = 'abc123,pll2-clock';
    clock-frequency = <23000000>; clocks = <&osc>;
    [...]
};
pll3: pll3 {
    #clock-cells = <0>;
    compatible = 'abc123,pll3-clock';
    clock-frequency = <23000000>; clocks = <&osc>;
    [...]
};
hw3_clk: hw3_clk {
    #clock-cells = <0>;
    compatible = 'abc123,hw3-clk';
    clocks = <&pll2>, <&pll3>, <&osc>;
    clock-output-names = 'hw3_clk';
};
```

说到源代码，下面的摘录显示了如何将`hw_clk3`注册为多路复用器(时钟多路复用器)，并指出了`pll2`、`pll3`和`osc`的父关系：

```sh
of_property_read_string(node, 'clock-output-names', &clk_name); 
parent_names[0] = of_clk_get_parent_name(node, 0);
parent_names[1] = of_clk_get_parent_name(node, 1);
parent_names[2] = of_clk_get_parent_name(node, 2); /* osc */
clk = clk_register_mux(NULL, clk_name, parent_names,  
                       ARRAY_SIZE(parent_names), 0, regs_base,
                       offset_bit, one_bit, 0, NULL);
```

下游时钟提供程序应使用`of_clk_get_parent_name()`获取其父时钟名称。 对于具有多个输出的块，`of_clk_get_parent_name()`可以返回有效的时钟名称，但仅当存在`clock-output-names`属性时才能返回。

现在，我们可以通过 CCF*sysfs*接口`/sys/kernel/debug/clk/clk_summary`查看时钟树摘要。 这一点可以在下面的摘录中看到：

```sh
$ mount -t debugfs none /sys/kernel/debug
# cat /sys/kernel/debug/clk/clk_summary
[...]
```

到此为止，我们已经完成了时钟制造商这一方面的工作。 我们已经了解了它的 API，并在设备树中讨论了它的 d说明。 此外，我们还了解了如何从*sysfs*转储它们的拓扑。 现在，让我们来看看时钟消费者 API。

时钟消费者 API 简介

如果没有另一端的消费者来利用已暴露的时钟线，时钟生产者设备驱动程序就毫无用处。 这种驱动器的主要目的是将它们的时钟源线分配给消费者。 然后，这些时钟线用于多种目的，Linux 内核提供相应的 API 和帮助器来实现所需的目标。 消费者驱动程序需要在其代码中包含`<linux/clk.h>`，才能使用其 API。 此外，如今，时钟消费者接口完全依赖于设备树，这意味着应该从设备树中为消费者分配他们需要的时钟。 使用者绑定应该遵循提供者的绑定，因为使用者说明符是由提供者的`#clock-cells`属性确定的。 请看下面的 UART 节点描述，它需要两条时钟线：

```sh
uart1: serial@02020000 {
    compatible = 'fsl,imx6sx-uart', 'fsl,imx21-uart';
    reg = <0x02020000 0x4000>;
    interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6SX_CLK_UART_IPG>,
             <&clks IMX6SX_CLK_UART_SERIAL>;
    clock-names = 'ipg', 'per';
    dmas = <&sdma 25 4 0>, <&sdma 26 4 0>;
    dma-names = 'rx', 'tx';
    status = 'disabled';
};
```

这表示具有两个时钟输入的器件。 前面的节点摘录允许我们介绍时钟使用者的设备树绑定，它至少应该具有以下属性：

*   `clocks`属性是您应该根据提供程序的`#clock-cells`属性指定设备的源时钟线的位置。
*   `clock-names` is the property used to name clocks in the same way they are listed in `clocks`. In other words, this property should be used to list the input name(s) for the clock(s) with respect to the consuming node. This name(s) should reflect the consumer input signal name(s) and can/must be used in the code (see `[devm_]clk_get()`) so that it matches the corresponding clock.

    重要音符

    时钟使用者节点绝不能直接引用提供者的`clock-output-names`属性。

消费者具有基于底层硬件时钟的任何精简且可移植的 API。 接下来，我们将看看消费者驱动程序执行的常见操作，以及及其相关 API。

## 抓取和释放时钟

下列函数允许我们在给定时钟`id`的情况下捕获和释放时钟：

```sh
struct clk *clk_get(struct device *dev, const char *id);
void clk_put(struct clk *clk);
struct clk *C(struct device *dev, const char *id)
```

`dev`是使用此时钟的设备，而`id`是在设备树中为时钟指定的名称。 如果成功，`clk_get`将返回指向`struct clk`的指针。 这可以提供给任何其他`clk-consumer`API。 `clk_put`实际上释放了时钟线。 前面代码中的前两个 API 在`drivers/clk/clkdev.c`中定义。 但是，在`drivers/clk/clk.c`中定义了其他时钟消费者 API。 `devm_clk_get`只是`clk_get`的托管版本。

## 准备/取消准备时钟

要准备好时钟以供使用，您可以使用`clk_prepare()`，如下所示：

```sh
void clk_prepare(struct clk *clk);
void clk_unprepare(struct clk *clk);
```

这些函数可能处于休眠状态，这意味着它们不能从原子上下文中调用。 总是在`clock_enable()`之前调用`clk_prepare()`是值得的。 如果底层时钟在 SLOw 总线(SPI/I2C)之后，这可能是有用的，因为这样的 clock 驱动器必须从准备/取消准备操作(其被允许休眠)内实现它们的使能/禁用(不能休眠)代码。

启用/禁用

当您需要选通/取消选通时钟时，可以使用以下接口：

```sh
int clk_enable(struct clk *clk);
void clk_disable(struct clk *clk);
```

`clk_enable`不得休眠，并实际打开时钟。 如果成功则返回 0，否则返回错误。 `clk_disable`则相反。 为了强制在调用 Enable 之前调用 Prepare 这一事实，时钟框架提供了`clk_prepare_enable`API，该 API 在内部调用两者。 相反，使用`clk_disable_unprepare`可以做到这一点：

```sh
int clk_prepare_enable(struct clk *clk)
void clk_disable_unprepare(struct clk *clk)
```

## 速率函数

对于速率可以更改的时钟，可以使用以下函数获取/设置时钟速率：

```sh
unsigned long clk_get_rate(struct clk *clk);
int clk_set_rate(struct clk *clk, unsigned long rate);
long clk_round_rate(struct clk *clk, unsigned long rate);
```

`clk_get_rate()`如果`clk`为`NULL`，则返回 0；否则，它将返回时钟速率，即缓存速率。 但是，如果设置了`CLK_GET_RATE_NOCACHE`标志，则将进行新的计算(通过`recalc_rate()`)以返回实际时钟频率。 另一方面，`clk_set_rate()`将设置时钟的速率。 但是，它的 rate 参数不能取任何值。 要查看时钟是否支持或允许您的目标速率，您应该使用`clk_round_rate()`，以及时钟指针和目标速率(以 Hz 为单位)，如下所示。

```sh
rounded_rate = clk_round_rate(clkp, target_rate);
```

这是必须赋给`clk_set_rate()`的`clk_round_rate(`的返回值，如下所示：

```sh
ret = clk_set_rate(clkp, rounded_rate);
```

在以下情况下，更改时钟频率可能会失败：

*   时钟从固定速率时钟源(例如，`OSC0`、`OSC1`、`XREF`等)提取其源。
*   时钟被多个模块/子模块使用，这意味着`usecount`大于 1。
*   多个子级正在使用时钟源。

请注意，如果未实现`.round_rate()`，则返回父费率。

## 父函数

有些时钟是其他时钟的子时钟，因此创建了父/子关系。 要获取/设置给定时钟的父时钟，可以使用以下函数：

```sh
int clk_set_parent(struct clk *clk, struct clk *parent);
struct clk *clk_get_parent(struct clk *clk);
```

`clk_set_parent()`实际设置给定时钟的父时钟，而`clk_get_parent()`返回当前父时钟。

## 把这一切放在一起

要总结这一点，请看下面的 i.MX 串行驱动程序(`drivers/tty/serial/imx.c`)的节选，它处理前面的设备节点：

```sh
sport->clk_per = devm_clk_get(&pdev->dev, 'per');
if (IS_ERR(sport->clk_per)) {
    ret = PTR_ERR(sport->clk_per);
    dev_err(&pdev->dev, 'failed to get per clk: %d\n', ret);
    return ret;
}
sport->port.uartclk = clk_get_rate(sport->clk_per);
/*  * For register access, we only need to enable the ipg clock.  */
ret = clk_prepare_enable(sport->clk_ipg);
if (ret)
    return ret;
```

在前面的代码摘录中，我们可以看到驱动程序如何抓取时钟及其当前速率，然后使能它。

简略的 / 概括的 / 简易判罪的 / 简易的

在本章中，我们介绍了 Linux 公共时钟框架。 我们介绍了提供商和消费者端，以及用户空间界面。 然后我们讨论了不同的时钟类型，并学习了如何为每种类型编写合适的 Linux 驱动程序。

下一章将介绍 ALSA SoC，这是一个用于音频的 Linux 内核框架。 例如，该框架严重依赖时钟框架来采样音频。**