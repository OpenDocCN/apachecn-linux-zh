# 替代语法

到目前为止，在脚本编写过程中，我们已经看到可以使用`test`命令来确定一个条件状态。 我们更进一步，发现我们还可以利用单个方括号。 在这里，我们将回顾一下`test`命令，并更详细地查看单个方括号。 在学习了更多关于方括号的知识之后，我们将转向更高级的变量或参数管理，从而提供默认值和低估引用问题。

最后，我们将看到在 bash、Korn 和 Zsh 等高级 shell 中，我们可以使用双括号! 使用双圆括号和双方括号可以简化整个语法，并允许数学符号的使用标准化。

在本章中，我们将涵盖以下主题:

*   总结`test`
*   提供参数默认值
*   当有疑问时——引用!
*   使用`[[`进行高级测试
*   使用`((`进行算术运算

# 技术要求

本章的源代码可以从这里下载:

[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05)

# 再次回顾 test 命令

到目前为止，我们使用内置的`test`命令来驱动条件语句。 使用`test`的其他选项，我们可以查看返回值来确定文件系统中文件的状态。 不带任何选项运行`test`命令将返回 false 输出:

```
$ test
```

# 测试文件

通常，我们可以使用`test`来检查基于文件的条件。 例如，要测试一个文件是否存在，可以使用`-e`选项。 下面的命令将测试`/etc/hosts`文件是否存在:

```
test -e /etc/hosts
```

我们可以再次运行这个`test`，但这一次检查该文件不仅存在，而且是一个常规文件，而不是具有某些特殊目的。 特定的文件类型可以是目录、管道和链接等等。 普通文件的选项是`-f`:

```
$ test -f /etc/hosts
```

# 添加逻辑

如果我们需要从我们的脚本中打开一个文件，我们将测试该文件是否是一个常规文件并且具有读权限集。 为了通过`test`实现这一点，我们还可以将`-a`选项包含在`AND`多个条件中。 在下面的示例命令中，我们将使用`-r`条件来检查文件是否可读:

```
$ test -f /etc/hosts -a -r /etc/hosts
```

类似地，对于表达式中的`OR`两个条件，也支持使用`-o`。

# 方括号是前所未见的

作为`test`命令的替代方法，我们可以使用单个方括号实现相同的条件测试。 重复前面的条件`test`并省略命令本身。 我们将重写它，如下面的命令所示:

```
 $ [ -f /etc/hosts -a -r /etc/hosts ]
```

很多时候，即使是有经验的管理员，我们也习惯于语言元素，并接受它们的本来面目。 我觉得许多 Linux 管理员会惊讶地发现，`[`既是内置 shell 的命令，也是独立文件的命令。 使用`type`命令，我们可以验证:

```
$ type -a [
```

我们可以在下面的截图中看到这个命令的输出，确认其存在:

![](Images/af5fd18f-715b-4990-8093-d42b9adefdcb.png)

内置的`[`命令模仿`test`命令，但它需要一个右括号。

现在我们对 bash 和早期的 Bourne shell 中的`[`命令了解了一些，现在我们可以继续添加一点命令行列表语法。 除了命令行列表，我们还可以在下面的命令示例中看到所需的功能:

```
$ FILE=/etc/hosts
$ [ -f $FILE -a -r $FILE ] && cat $FILE
```

在设置参数`FILE`变量之后，我们可以在列出文件内容之前测试它是否是一个常规文件，并且用户能够读取它。 通过这种方式，脚本变得更加健壮，而不需要复杂的脚本逻辑。 我们可以在下面的截图中看到正在使用的代码:

![](Images/9c04243c-1855-4723-b90a-44d825d28e77.png)

这类缩写很常见，也很容易辨认。 如果缩写不能增加可读性，我们应该始终谨慎使用它们。 我们使用脚本的目的应该是编写清晰易懂的代码，并避免使用捷径，如果它们不能达到这个目的的话。

# 提供参数默认值

在 bash 参数中，内存中有一些命名空间，允许我们访问存储的值。 参数有两种类型:

*   变量
*   特殊的参数

# 变量

我们已经在[第 1 章](05.html)、*Bash 脚本的内容和原因*中描述了变量是什么以及如何定义它们。

刷新一下你的记忆，你可以通过给一个值赋值来定义一个变量，这个值带有等号，不带任何空格，像这样:

```
#!/bin/bash
myvar=15
myvar2="welcome"
```

这没什么新鲜的。

# 特殊的参数

特殊参数是第二种参数类型，由 shell 本身管理，并且表示为只读。 我们以前在参数(如`$0`)中遇到过这些，但是让我们来看看另一个`$-`。 我们可以通过使用`echo`命令展开这些参数以了解它们的用途:

```
$ echo "My shell is $0 and the shell options are: $-"
```

从我添加的带注释的文本中，我们可以理解`$-`选项表示已配置的 shell 选项。 可以使用 set`-o`命令显示这些信息，但也可以使用`$-`以编程方式读取这些信息。

我们可以在下面的截图中看到这一点:

![](Images/b4b7bb52-bd42-4f29-acf6-01839cf6d812.png)

此处设置的选项如下:

*   `h`:这是 hashall 的缩写; 它允许使用`PATH`参数找到程序
*   `i`:这表明这是一个交互式 shell
*   `m`:是 monitor 的简称; 它允许使用`bg`和`fg`命令来将命令导入或退出后台
*   `B`:这允许支具展开或`mkdirdir{1,2}`，其中我们创建`dir1`和`dir2`
*   `H`:这允许对正在运行的命令进行历史扩展，例如`!501`来重复历史上的命令

# 设置默认值

使用`test`命令或括号，我们可以为变量(包括命令行参数)提供默认值。 使用前面使用过的`hello4.sh`脚本，我们可以修改它，并在`name`参数为零字节时设置它:

```
#!/bin/bash
name=$1
[ -z $name ] && name="Anonymous"
echo "Hello $name"
exit 0
```

这段代码是功能性的，但是我们可以选择如何使用默认值进行编码。 我们也可以直接给参数赋一个默认值。 考虑以下命令，其中直接进行默认赋值:

```
name=${1-"Anonymous"}
```

在 bash 中，这被称为**参数替换**，可以写成以下伪代码:

```
${parameter-default}
```

如果一个变量(`parameter`)没有被声明且为空值，那么将使用默认值。 如果参数显式地声明为空值，我们将使用`:-`语法，如下例所示:

```
parameter=
${parameter:-default}
```

现在通过编辑脚本，我们可以创建`hello8.sh`来利用 bash 参数替换来提供默认值:

```
#!/bin/bash
#Use parameter substitution to provide default value
name=${1-"Anonymous"} 
echo "Hello $name"
exit 0
```

这个脚本和它的输出，包括有和没有提供的值，如下截图所示:

![](Images/22032c85-3f5a-457b-bf7f-e7307cb9988e.png)

`hello8.sh`脚本提供了我们需要的功能，并将逻辑直接构建到参数赋值中。 逻辑和赋值现在是脚本中的一行代码，这是保持脚本简单和保持可读性的主要步骤。

# 当有疑问时——引用!

在确定变量是一种参数类型之后，我们应该始终牢记这一点，尤其是在阅读手册和*HOWTOs*时。 文档通常引用参数，在此过程中，它们包括变量以及 bash 特殊参数，如`$1`等等。 为了与此保持一致，我们将研究为什么在命令行或脚本中使用参数时推荐引用它们。 现在了解这一点可以为我们以后节省很多痛苦和心痛，尤其是当我们开始查看循环时。

首先，我们应该使用的读取变量值的正确术语是**参数展开**。 对你和我来说，这是读取一个变量，但要破坏它就太简单了。 正确名称的赋值(比如参数展开)减少了其含义的任何歧义，但同时增加了复杂性。 在下面的示例中，第一行命令将`fred`的值赋给`name`参数。 第二行命令使用参数展开从内存中打印存储的值。 符号`$`用于允许参数展开:

```
$ name=fred
$ echo "The value is: $name"
```

在本例中，我们使用双引号允许`echo`打印单个字符串，因为我们使用了空格。 如果不使用引号，`echo`可能会将其视为多个参数，空格是大多数 shell(包括 bash)中的默认字段分隔符。 通常，当我们不想使用引号时，我们不会直接看到空格。 下面是我们之前使用的命令行代码的摘录:

```
$ FILE=/etc/hosts
$ [ -f $FILE -a -r $FILE ] && cat $FILE
```

即使这样做成功了，我们也可能有点幸运，特别是如果我们从一个不是我们自己创建的文件列表填充`FILE`参数。 可以想象，文件的名称中可以有空格。 现在让我们使用一个不同的文件重播这个命令。 考虑以下命令:

```
$ FILE="my file"
$ [ -f $FILE -a -r $FILE ] && cat $FILE
```

尽管在结构上没有对代码进行更改，但它现在失败了。 这是因为我们为`[`命令提供了太多的参数。 即使使用`test`命令，失败的结果也会相同。

尽管我们正确地用引号将文件名赋值给参数`FILE`，但是当参数被扩展时，我们并没有保护空格。 我们可以看到代码失败了，如下面的截图所示:

![](Images/93d92de0-8e42-4c20-99b3-575ecdcf2121.png)

我们可以看到，这不会为我们的脚本做好准备。 唉，我们曾经认为强大的东西现在已经支离破碎，就像泰坦尼克号一样，我们的代码已经沉没了。

然而，一个简单的解决方案是恢复引用参数展开，除非特别不需要。 我们可以让这艘船不沉，只需对代码进行简单编辑:

```
$ FILE="my file"
$ [ -f "$FILE" -a -r "$FILE" ] && cat "$FILE"
```

我们现在可以自豪地站在白星航运公司的码头上，因为我们看到下面的代码示例中泰坦尼克 2 号下水了，下面的截图捕捉到了它:

![](Images/c81415b8-5644-400f-8caf-8364adcd5986.png)

这些小小的名言所能产生的影响实在是令人惊奇，有时甚至有点难以置信。 在展开变量时，我们永远不应该忽略引号。 为了确保深入了解这一点，我们可以在另一个更简单的例子中突出这一现象。 让我们以现在只想删除文件的场景为例。 在第一个例子中，我们没有使用引号:

```
$ rm $FILE
```

这段代码将产生失败，因为参数扩展将导致以下感知命令:

```
$ rm my file
```

代码将失败，因为它无法找到`my`文件或`file`文件。 更糟糕的是，如果可能意外解析任何名称，我们可能会删除不正确的文件。 然而，引用参数展开将会扭转乾坤，正如我们在第二个例子中看到的:

```
$ rm "$FILE"
```

这被正确地扩展为我们在下面的命令示例中演示的所需命令:

```
$ rm "my file"
```

我当然希望这些示例说明在扩展参数时需要小心，并使您意识到陷阱。

# 高级测试使用[[

使用双括号`[[ condition ]]`允许我们进行更高级的条件测试，但它与 Bourne shell 不兼容。 双括号最初是作为 KornShell 中定义的关键字引入的，在 bash 和 Zsh 中也可以使用。 与单括号不同，这不是命令而是关键字。 使用`type`命令可以确认这一点:

```
$ type [[ 
```

# 空白

`[[`不是命令这一事实对于空格来说是很重要的。 作为一个关键字，`[[`在 bash 展开参数之前解析它们。 因此，单个参数将始终表示为单个参数。 尽管它违背了最佳实践，但`[[`可以缓解与参数值中的空白相关的一些问题。 重新考虑前面测试的条件，我们可以在使用`[[`时省略引号，如下例所示:

```
$ echo "The File Contents">"my file"
$ FILE="my file"
$ [[ -f $FILE && -r $FILE ]] && cat "$FILE"
```

如您所见，在使用`cat`时，我们仍然需要引用参数，我们可以在双括号内使用引号，但它们是可选的。 注意，我们还可以使用更传统的`&&`和`||`分别表示`-a`和`-o`。

# 其他高级功能

这些是我们可以用双括号包含的一些额外功能。 即使我们在使用它们时失去了可移植性，但仍有一些很棒的功能可以克服这种损失。 请记住，如果我们只使用 bash，那么我们可以使用双括号，但不能在 Bourne shell 中运行脚本。 我们获得的高级特性包括模式匹配和正则表达式，这些特性将在下面几节中介绍。

# 模式匹配

使用双括号，我们可以做的不仅仅是匹配字符串，我们还可以使用模式匹配。 例如，我们可能需要专门处理以`.pl`结尾的 Perl 脚本和文件。 通过包含模式作为匹配，我们可以在一个条件中轻松实现这一点，如下面的示例所示:

```
$ [[ $FILE = *.pl ]] && cp"$FILE" scripts/
```

# 正则表达式

我们将在[第 11 章](11.html)、*正则表达式*中深入讨论正则表达式，但是现在让我们稍微看一下。

我们可以使用正则表达式重写上一个例子:

```
$ [[ $FILE =~ \.pl$ ]] && cp "$FILE" scripts/
```

由于单个点或句点在正则表达式中具有特殊含义，我们需要使用`\`对其进行转义。

下面的屏幕截图显示了与一个名为`my.pl`的文件和另一个名为`my.apl`的文件匹配的正则表达式。 匹配正确地显示了以`.pl`结尾的文件:

![](Images/84268ff7-79fb-4aa0-8205-1edb1d9f5a3c.png)

# 正则表达式的脚本

使用正则表达式进行条件测试的另一个简单演示是暴露*color*的美国和英国拼写，分别为*color*和*colour*。 我们可以提示用户，如果他们想要一个颜色或单一输出的脚本，但同时满足两种拼写。 在脚本中执行工作的行如下:

```
if [[ $REPLY =~ colou?r ]] ; then
```

通过将`u`改为`u?`，正则表达式满足了*color*的两种拼写。 此外，通过设置 shell 选项，我们可以禁用区分大小写，允许*COLOR*和*COLOR*:

```
shopt -s nocasematch
```

该选项可以在脚本结束时使用以下命令再次禁用:

```
shopt -u nocasematch 
```

当我们使用命名为`$GREEN`和`$RESET`的变量参数时，我们会影响输出的颜色。 绿色将只显示在我们获取颜色定义文件的地方。 这是在我们选择颜色显示时设置的。 选择 mono 将确保变量参数为空且不起作用。

完整的脚本如下截图所示:

![](Images/75571831-e4dd-4318-bd61-47d8dd661620.png)

# 使用(()进行算术运算

在使用 bash 和其他一些高级 shell 时，我们可以使用`(( ))`符号来简化脚本中的数学操作。

# 简单的数学

bash 中的双括号结构允许算术展开。 以最简单的格式使用它，我们可以很容易地进行整数算术。 这将替代内置的`let`。 下面的例子展示了使用`let`命令和双括号来实现相同的结果:

```
$ a=(( 2 + 3 ))
$ let a=2+3
```

在这两种情况下，参数`a`都是用`2 + 3`的和填充的。 如果你想在 shell 脚本中写它，你需要在圆括号前添加一个美元符号:

```
#!/bin/bash
echo $(( 2 + 3 ))
```

# 参数操作

也许在脚本中对我们更有用的是 c 风格的参数操作，我们可以使用双括号来包含它。 我们通常可以使用它在循环中增加一个计数器，也可以限制循环迭代的次数。 考虑以下命令:

```
$ COUNT=1
$ (( COUNT++ ))
echo $COUNT
```

在本例中，我们首先将`COUNT`设置为`1`，然后使用`++`操作符对其进行加 1。 当它在最后一行中被回显时，该参数的值为`2`。 我们可以在下面的截图中看到结果:

![](Images/7cf03547-dc20-44b4-8601-79f0c49c00ec.png)

我们可以通过使用下面的语法来实现同样的结果:

```
$ COUNT=1
$ (( COUNT=COUNT+1 ))
echo $COUNT
```

当然，这允许`COUNT`参数的任意增加，而不仅仅是单个单位的增加。 类似地，我们可以使用`--`操作符进行倒计时，如下例所示:

```
$ COUNT=10
$ (( COUNT-- ))
echo $COUNT
```

我们开始使用一个值`10`，在双括号中减去`1`。

注意，我们没有使用`$`展开圆括号中的参数。 它们用于参数操作，因此，我们不需要显式地展开参数。

# 标准算术测试

我们可以从这些双括号中获得的另一个好处是测试。 与其使用`-gt`表示大于，我们可以简单地使用`>`。 我们可以在下面的代码中演示:

```
$(( COUNT > 1 )) && echo "Count is greater than 1"
```

下面的截图演示了这一点:

![](Images/65fa7cb8-2ece-45dd-abaf-9d71392808d6.png)

正是这种标准化，在 c 风格的操作和测试中，使得双括号对我们如此有用。 这种用法扩展到命令行和脚本。 在研究循环结构时，我们将广泛地使用这个特性。

# 总结

在这一章里，我真的希望我们已经向你们介绍了许多新的和有趣的选择。 在这个领域，我们首先回顾了`test`的使用，发现`[`是一个命令，而不是一个语法结构。 这是一个命令的主要影响是空白，我们看到了引用变量的需要。

尽管我们通常称变量为变量，但我们也看到了它们的正确名称，尤其是在文档中，是参数。 读取变量是一个参数展开。 理解参数展开可以帮助我们理解关键词`[[`的使用。 双方括号不是命令，也不展开参数。 这意味着我们不需要引用变量，即使它们包含空格。 此外，我们还可以使用带有双方括号的高级测试，例如模式匹配或正则表达式。

最后，我们看了算术展开和使用双括号符号的参数操作。 它提供的最大特性是可以轻松地增加和减少计数器。

在下一章中，我们将继续讨论 bash 中的循环结构，并利用本章中新发现的一些技能。

# 问题

1.  如何使用 shell 脚本从 25 中减去 8 ?
2.  下面的代码有什么问题? 你怎么能解决它呢?

```
$ rm my file
```

3.  下面的代码有什么问题?

```
#!/bin/bash
a=(( 8 + 4 ))
echo $a
```

# 进一步的阅读

请参阅以下有关本章的资料:

*   [http://tldp.org/LDP/abs/html/arithexp.html](http://tldp.org/LDP/abs/html/arithexp.html)
*   [http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)