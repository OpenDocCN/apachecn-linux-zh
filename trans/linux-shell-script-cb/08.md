# 八、老男孩网络

在本章中，我们将介绍以下食谱:

*   设置网络
*   让我们平吧！
*   追踪 IP 路由
*   列出网络上所有可用的计算机
*   使用 SSH 在远程主机上运行命令
*   在远程机器上运行图形命令
*   通过网络传输文件
*   连接到无线网络
*   通过 SSH 实现无密码自动登录
*   使用 SSH 的端口转发
*   在本地挂载点挂载远程驱动器
*   网络流量和端口分析
*   测量网络带宽
*   创建任意套接字
*   造桥
*   共享互联网连接
*   基本防火墙使用`iptables`
*   创建虚拟专用网络

# 介绍

联网是连接计算机以允许它们交换信息的行为。最广泛使用的网络堆栈是 TCP/IP，其中每个节点都被分配一个唯一的 IP 地址以供识别。如果你已经熟悉网络，你可以跳过这个介绍。

TCP/IP 网络通过在节点之间传递数据包来工作。每个数据包都包含其目的地的 IP 地址和可以处理该数据的应用的端口号。

当一个节点收到一个数据包时，它会检查它是否是这个数据包的目的地。如果是，节点检查端口号并调用适当的应用来处理数据。如果该节点不是目的地，它会评估自己对网络的了解，并将数据包传递给更靠近最终目的地的节点。

Shell 脚本可用于配置网络中的节点、测试机器的可用性、在远程主机上自动执行命令等等。本章提供了介绍与网络相关的工具和命令的方法，并展示了如何有效地使用它们。

# 设置网络

在深入研究基于网络的方法之前，有必要对设置网络、术语以及分配 IP 地址、添加路由等命令有一个基本的了解。本食谱概述了在 GNU/Linux 网络中使用的命令。

# 准备好

网络接口通过有线或无线链接将机器物理连接到网络。Linux 使用诸如`eth0`、`eth1`或`enp0s25`等名称来表示网络接口(指以太网接口)。其他接口，即`usb0`、`wlan0`和`tun0`，分别可用于 USB 网络接口、无线局域网和隧道。

在本食谱中，我们将使用这些命令:`ifconfig`、`route`、`nslookup`和`host`。

`ifconfig`命令用于配置和显示网络接口、子网掩码等详细信息。应该在`/sbin/ifconfig`有。

# 怎么做...

1.  列出当前网络接口配置:

```sh
 $ ifconfig 
 lo        Link encap:Local Loopback 
 inet addr:127.0.0.1  Mask:255.0.0.0 
 inet6addr: ::1/128 Scope:Host 
 UP LOOPBACK RUNNING  MTU:16436  Metric:1 
 RX packets:6078 errors:0 dropped:0 overruns:0 frame:0 
 TX packets:6078 errors:0 dropped:0 overruns:0 carrier:0 
 collisions:0 txqueuelen:0 
 RX bytes:634520 (634.5 KB)  TX bytes:634520 (634.5 KB) 
 wlan0     Link encap:EthernetHWaddr 00:1c:bf:87:25:d2 
 inet addr:192.168.0.82  Bcast:192.168.3.255  Mask:255.255.252.0 
 inet6addr: fe80::21c:bfff:fe87:25d2/64 Scope:Link 
 UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1 
 RX packets:420917 errors:0 dropped:0 overruns:0 frame:0 
 TX packets:86820 errors:0 dropped:0 overruns:0 carrier:0 
 collisions:0 txqueuelen:1000 
 RX bytes:98027420 (98.0 MB)  TX bytes:22602672 (22.6 MB) 

```

ifconfig 输出中最左边的列列出了网络接口的名称，右边的列显示了与相应网络接口相关的详细信息。

2.  要设置网络接口的 IP 地址，请使用以下命令:

```sh
 # ifconfig wlan0 192.168.0.80 

```

您需要以 root 用户身份运行前面的命令

`192.168.0.80`被定义为无线设备 wlan0 的地址

要设置子网掩码和 IP 地址，请使用以下命令:

```sh
 # ifconfig wlan0 192.168.0.80  netmask 255.255.252.0 

```

3.  许多网络使用**动态主机配置协议** ( **DHCP** )在计算机连接到网络时自动分配 IP 地址。当您的机器连接到自动分配 IP 地址的网络时，`dhclient`命令分配 IP 地址。如果地址是通过 DHCP 分配的，请使用`dhclient`而不是手动选择可能与网络上另一台机器冲突的地址。许多 Linux 发行版在检测到网络电缆连接时会自动调用`dhclient`

```sh
 # dhclient eth0 

```

# 还有更多...

`ifconfig`命令可以与其他 shell 工具结合，生成特定的报告。

# 打印网络接口列表

此单行命令序列显示系统上可用的网络接口:

```sh
$ ifconfig | cut -c-10 | tr -d ' ' | tr -s 'n' 
lo 
wlan0 

```

`ifconfig`输出每行前十个字符留作写网络接口名称。因此，我们使用`cut`来提取每行的前十个字符。`tr -d ' '`删除每行中的每个空格字符。现在，使用`tr -s 'n'`挤压`n`换行符，产生一个接口名称列表。

# 显示 IP 地址

`ifconfig`命令显示系统上可用的每个活动网络接口的详细信息。但是，我们可以使用以下命令将其限制在特定的接口上:

```sh
$ ifconfig iface_name 

```

考虑这个例子:

```sh
$ ifconfig wlan0 
wlan0     Link encap:EthernetHWaddr 00:1c:bf:87:25:d2 
inet addr:192.168.0.82 Bcast:192.168.3.255 Mask:255.255.252.0 
inet6 addr: fe80::3a2c:4aff:6e6e:17a9/64 Scope:Link 
UP BROADCAST RUNNINT MULTICAST  MTU:1500 Metric:1 
RX Packets... 

```

要控制设备，我们需要 IP 地址、广播地址、硬件地址和子网掩码:

*   `HWaddr 00:1c:bf:87:25:d2`:这是硬件地址(MAC 地址)
*   `inet addr:192.168.0.82`:这是 IP 地址
*   `Bcast:192.168.3.255`:这是广播地址
*   `Mask:255.255.252.0`:这是子网掩码

要从`ifconfig`输出中提取 IP 地址，请使用以下命令:

```sh
$ ifconfig wlan0 | egrep -o "inetaddr:[^ ]*" | grep -o "[0-9.]*" 
192.168.0.82 

```

`egrep -o "inetaddr:[^ ]*"`命令返回`inet addr:192.168.0.82`。该模式以`inetaddr:`开始，以任何非空格字符序列(由`[^ ]*`指定)结束。下一个命令`grep -o "[0-9.]*"`将其输入减少到只有数字和句点，并打印出一个 IP4 地址。

# 欺骗硬件地址(媒体访问控制地址)

当身份验证或过滤基于硬件地址时，我们可以使用硬件地址欺骗。硬件地址在`ifconfig`输出中显示为`HWaddr 00:1c:bf:87:25:d2`。

`ifconfig`的`hw`子命令将定义设备类别和媒体访问控制地址:

```sh
# ifconfig eth0 hw ether 00:1c:bf:87:25:d5 

```

在前面的命令中，`00:1c:bf:87:25:d5`是要分配的新 MAC 地址。当我们需要通过 MAC 认证的服务提供商访问互联网时，这很有用，这些服务提供商为单台机器提供互联网访问。

Note: this definition only lasts until a machine restarts.

# 名称服务器和域名服务

互联网的底层寻址方案是点分十进制形式(如`83.166.169.231`)。人类更喜欢用文字而不是数字，所以互联网上的资源都是用名为**网址**或**域名**的字符串来标识的。例如，[www.packtpub.com](http://www.packtpub.com)是一个域名，对应一个 IP 地址。站点可以通过数字或字符串名称来标识。

这种将 IP 地址映射到符号名称的技术被称为**域名服务** ( **域名系统**)。当我们进入[www.google.com](http://www.google.com)时，我们的计算机使用域名服务器将域名解析成相应的 IP 地址。在本地网络中，我们设置本地域名系统，用符号名命名本地机器。

名称服务器在`/etc/resolv.conf`中定义:

```sh
$ cat /etc/resolv.conf 
# Local nameserver 
nameserver 192.168.1.1 
# External nameserver 
nameserver 8.8.8.8 

```

我们可以通过编辑该文件或用一行代码手动添加名称服务器:

```sh
# sudo echo nameserver IP_ADDRESS >> /etc/resolv.conf 

```

获取 IP 地址最简单的方法就是使用`ping`命令访问域名。回复包括 IP 地址:

```sh
$ ping google.com 
PING google.com (64.233.181.106) 56(84) bytes of data. 

```

数字`64.233.181.106`是 google.com 服务器的 IP 地址。

一个域名可能映射到多个 IP 地址。在这种情况下，`ping`显示了 IP 地址列表中的一个地址。要获得分配给域名的所有地址，我们应该使用域名系统查找工具。

# DNS 查找

几个 DNS 查找实用程序从命令行提供名称和 IP 地址解析。`host`和`nslookup`命令是两个常用的实用程序。

`host`命令列出了附加到域名的所有 IP 地址:

```sh
$ host google.com 
google.com has address 64.233.181.105 
google.com has address 64.233.181.99 
google.com has address 64.233.181.147 
google.com has address 64.233.181.106 
google.com has address 64.233.181.103 
google.com has address 64.233.181.104 

```

`nslookup`命令将名称映射到 IP 地址，并将 IP 地址映射到名称:

```sh
$ nslookup google.com 
Server:    8.8.8.8 
Address:  8.8.8.8#53 

Non-authoritative answer: 
Name:  google.com 
Address: 64.233.181.105 
Name:  google.com 
Address: 64.233.181.99 
Name:  google.com 
Address: 64.233.181.147 
Name:  google.com 
Address: 64.233.181.106 
Name:  google.com 
Address: 64.233.181.103 
Name:  google.com 
Address: 64.233.181.104 

Server:    8.8.8.8 

```

前面命令行片段中的最后一行对应于用于解析的默认名称服务器。

通过在`/etc/hosts`文件中添加条目，可以在 IP 地址解析中添加一个符号名称。

`/etc/hosts follow this format`中的条目:

```sh
IP_ADDRESS name1 name2 ... 

```

可以这样更新`/etc/hosts`:

```sh
# echo IP_ADDRESS symbolic_name>> /etc/hosts 

```

考虑这个例子:

```sh
# echo 192.168.0.9 backupserver>> /etc/hosts 

```

添加该条目后，每当解析到`backupserver`时，都会解析到`192.168.0.9`。

如果`backupserver`有多个名称，可以将它们包含在同一行:

```sh
# echo 192.168.0.9 backupserver backupserver.example.com >> /etc/hosts 

```

# 显示路由表信息

互连网络很常见。例如，工作或学校的不同部门可能在不同的网络上。当一个网络上的设备想要与另一个网络上的设备通信时，它需要通过两个网络共用的设备发送数据包。这个设备被称为`gateway`，它的功能是将数据包路由到不同的网络和从不同的网络路由数据包。

操作系统维护一个名为`routing table`的表，其中包含了数据包如何通过网络上的机器转发的信息。`route`命令显示路由表:

```sh
$ route 
Kernel IP routing table 
Destination      Gateway   GenmaskFlags  Metric  Ref  UseIface 
192.168.0.0         *      255.255.252.0  U     2      0     0wlan0 
link-local          *      255.255.0.0    U     1000   0     0wlan0 
default          p4.local  0.0.0.0        UG    0      0     0wlan0 

```

或者，您也可以使用这个:

```sh
$ route -n 
Kernel IP routing table 
Destination   Gateway      Genmask       Flags Metric Ref  UseIface 
192.168.0.0   0.0.0.0      255.255.252.0   U     2     0     0   wlan0 
169.254.0.0   0.0.0.0      255.255.0.0     U     1000  0     0   wlan0 
0.0.0.0       192.168.0.4  0.0.0.0         UG    0     0     0   wlan0 

```

使用`-n`指定显示数字地址。默认情况下，路由会将数字地址映射到名称。

当您的系统不知道到达目的地的路由时，它会将数据包发送到默认网关。默认网关可能是互联网链接或跨部门路由器。

`route add`命令可以添加默认网关:

```sh
# route add default gw IP_ADDRESS INTERFACE_NAME 

```

考虑这个例子:

```sh
# route add default gw 192.168.0.1 wlan0 

```

# 请参见

*   *使用变量和环境变量[第 1 章](01.html)*的*配方，解释了`PATH`变量*
*   *用[第四章](04.html)、*发短信和开车*的 grep* 配方搜索和挖掘文件中的文本，解释了`grep`命令

# 让我们平吧！

`ping`命令是一个基本的网络命令，所有主要操作系统都支持。Ping 用于验证网络中主机之间的连通性，并识别可访问的机器。

# 怎么做...

ping 命令使用**互联网控制消息协议** ( **ICMP** )数据包来检查网络上两台主机的连通性。当这些回应数据包被发送到目标时，如果连接完成，目标会以回复进行响应。如果没有到目标的路由，或者没有从目标返回请求者的已知路由，ping 请求可能会失败。

ping 地址将检查主机是否可达:

```sh
$ ping ADDRESS 

```

`ADDRESS`可以是主机名、域名或 IP 地址本身。

默认情况下，`ping`会持续发送数据包，回复信息打印在终端上。按下 *Ctrl* + *C* 停止 pinging 过程。

考虑以下示例:

*   当可以访问主机时，输出将类似于以下内容:

```sh
 $ ping 192.168.0.1 
 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 
 64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=1.44 ms 
 ^C 
 --- 192.168.0.1 ping statistics --- 
 1 packets transmitted, 1 received, 0% packet loss, time 0ms 
 rtt min/avg/max/mdev = 1.440/1.440/1.440/0.000 ms 

 $ ping google.com 
 PING google.com (209.85.153.104) 56(84) bytes of data. 
 64 bytes from bom01s01-in-f104.1e100.net (209.85.153.104):    
        icmp_seq=1 ttl=53 time=123 ms 
 ^C 
 --- google.com ping statistics --- 
 1 packets transmitted, 1 received, 0% packet loss, time 0ms 
 rtt min/avg/max/mdev = 123.388/123.388/123.388/0.000 ms 

```

*   当主机不可访问时，输出如下所示:

```sh
 $ ping 192.168.0.99 
 PING 192.168.0.99 (192.168.0.99) 56(84) bytes of data. 
 From 192.168.0.82 icmp_seq=1 Destination Host Unreachable 
 From 192.168.0.82 icmp_seq=2 Destination Host Unreachable 

```

如果无法到达目标，ping 会返回`Destination Host Unreachable`错误消息。

Network administrators generally configure devices such as routers not to respond to `ping`. This is done to lower security risks, as `ping` can be used by attackers (using brute-force) to find out IP addresses of machines.

# 还有更多...

除了检查网络中两点之间的连通性外，`ping`命令还返回其他信息。往返时间和数据包丢失报告可用于确定网络是否正常工作。

# 往返时间

`ping`命令显示发送和返回的每个数据包的**往返时间** ( **RTT** )。RTT 以毫秒为单位报告。在内部网络中，小于 1 毫秒的 RTT 是常见的。在互联网上 ping 一个站点时，RTT 通常为 10-400 毫秒，可能超过 1000 毫秒:

```sh
--- google.com ping statistics --- 
5 packets transmitted, 5 received, 0% packet loss, time 4000ms 
rtt min/avg/max/mdev = 118.012/206.630/347.186/77.713 ms 

```

这里，最小 RTT 为`118.012 ms`，平均 RTT 为`206.630` ms，最大 RTT 为`347.186ms`。ping 输出中的`mdev` ( `77.713ms`)参数代表平均偏差。

# 序号

ping 发送的每个数据包都会被分配一个编号，从 1 开始，直到 ping 停止。如果网络接近饱和，数据包可能会因冲突和重试而无序返回，或者完全丢弃:

```sh
$> ping example.com 
64 bytes from example.com (1.2.3.4): icmp_seq=1 ttl=37 time=127.2 ms 
64 bytes from example.com (1.2.3.4): icmp_seq=3 ttl=37 time=150.2 ms 
64 bytes from example.com (1.2.3.4): icmp_seq=2 ttl=30 time=1500.3 ms 

```

在本例中，第二个数据包被丢弃，然后在超时后重试，导致它无序返回，往返时间更长。

# 该活下去了

每个 ping 数据包在被丢弃之前都有一个预定义的跳数。每台路由器将该值递减 1。此值显示系统和您要 ping 的站点之间有多少路由器。初始**生存时间** ( **TTL** )值可能因您的平台或 ping 版本而异。您可以通过 ping 环回连接来确定初始值:

```sh
$> ping 127.0.0.1 
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.049 ms 
$> ping www.google.com 
64 bytes from 173.194.68.99: icmp_seq=1 ttl=45 time=49.4 ms 

```

在本例中，我们 ping 环回地址，以确定无跳的 TTL 是多少(本例中为 64)。然后，我们 ping 一个远程站点，从无跳值中减去该 TTL 值，以确定两个站点之间有多少跳。在这种情况下，64-45 是 19 跳。

两个站点之间的 TTL 值通常是恒定的，但是当条件需要替代路径时，该值会发生变化。

# 限制要发送的数据包数量

`ping`命令发送回声包，无限期等待回声的回复，直到按下 *Ctrl* + *C* 停止。`-c`标志将限制要发送的回声包的数量:

```sh
-c COUNT 

```

考虑这个例子:

```sh
$ ping 192.168.0.1 -c 2  
PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.  
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=4.02 ms 
64 bytes from 192.168.0.1: icmp_seq=2 ttl=64 time=1.03 ms 

--- 192.168.0.1 ping statistics ---  
2 packets transmitted, 2 received, 0% packet loss, time 1001ms  
rtt min/avg/max/mdev = 1.039/2.533/4.028/1.495 ms 

```

在前面的例子中，`ping`命令发送两个回声包并停止。当我们需要通过脚本从 IP 地址列表中 ping 通多台机器并检查它们的状态时，这非常有用。

# 返回 ping 命令的状态

`ping`命令成功时返回退出状态`0`，失败时返回非零。`Successful`表示目的主机可达，而`Failure`表示目的主机不可达。

返回状态可以通过以下方式获得:

```sh
$ ping domain -c2 
if [ $? -eq0 ]; 
then 
 echo Successful ; 
else 
 echo Failure 
fi 

```

# 追踪 IP 路由

当应用通过互联网请求服务时，服务器可能位于远处，并通过许多网关或路由器连接。`traceroute`命令显示数据包到达目的地之前访问的所有中间网关的地址。`traceroute`信息帮助我们了解每个数据包到达目的地需要多少跳。中间网关的数量代表网络中两个节点之间的有效距离，它可能与物理距离无关。旅行时间随着每一跳而增加。路由器接收、解密和传输数据包需要时间。

# 怎么做...

`traceroute`命令的格式如下:

```sh
traceroute destinationIP 

```

`destinationIP`可以是数字或字符串:

```sh
$ traceroute google.com 
traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets 
1  gw-c6509.lxb.as5577.net (195.26.4.1)  0.313 ms  0.371 ms  0.457 ms 
2  40g.lxb-fra.as5577.net (83.243.12.2)  4.684 ms  4.754 ms  4.823 ms 
3  de-cix10.net.google.com (80.81.192.108)  5.312 ms  5.348 ms  5.327 ms 
4  209.85.255.170 (209.85.255.170)  5.816 ms  5.791 ms 209.85.255.172 (209.85.255.172)  5.678 ms 
5  209.85.250.140 (209.85.250.140)  10.126 ms  9.867 ms  10.754 ms 
6  64.233.175.246 (64.233.175.246)  12.940 ms 72.14.233.114 (72.14.233.114)  13.736 ms  13.803 ms 
7  72.14.239.199 (72.14.239.199)  14.618 ms 209.85.255.166 (209.85.255.166)  12.755 ms 209.85.255.143 (209.85.255.143)  13.803 ms 
8  209.85.255.98 (209.85.255.98)  22.625 ms 209.85.255.110 (209.85.255.110)  14.122 ms 
*  
9  ew-in-f104.1e100.net (74.125.77.104)  13.061 ms  13.256 ms  13.484 ms 

```

Modern Linux distributions also ship with an `mtr` command, which is similar to traceroute but shows real-time data that keeps refreshing. It is useful for checking your network carrier quality.

# 列出网络上所有可用的计算机

当我们监控一个大型网络时，我们需要检查所有机器的可用性。机器不可用可能有两个原因:它没有通电，或者网络出现问题。我们可以编写一个 shell 脚本来确定和报告网络上哪些机器可用。

# 准备好

在这个食谱中，我们演示了两种方法。第一种方法使用 ping，第二种方法使用`fping`。`fping`命令对脚本来说更容易，比 ping 命令有更多的功能。它可能不是您的 Linux 发行版的一部分，但是可以用您的包管理器安装。

# 怎么做...

下一个示例脚本将使用 ping 命令找到网络上可见的机器:

```sh
#!/bin/bash 
#Filename: ping.sh 
# Change base address 192.168.0 according to your network. 

for ip in 192.168.0.{1..255} ; 
do 
 ping $ip -c 2 &> /dev/null ; 

 if [ $? -eq 0 ]; 
 then 
 echo $ip is alive 
 fi 
done 

```

输出如下所示:

```sh
$ ./ping.sh 
192.168.0.1 is alive 
192.168.0.90 is alive 

```

# 它是如何工作的...

该脚本使用`ping`命令找出网络上可用的机器。它使用`for`循环来遍历由表达式`192.168.0.{1..255}`生成的 IP 地址列表。`{start..end}`符号生成开始和结束之间的值。在这种情况下，它会创建从`192.168.0.1`到`192.168.0.255`的 IP 地址。

`ping $ip -c 2 &> /dev/null`对相应的 IP 地址运行`ping`命令。`-c`选项使 ping 只发送两个数据包。`&> /dev/null`重定向`stderr`和`stdout to /dev/null`，因此终端上不打印任何内容。脚本使用`$?`评估退出状态。如果成功，退出状态为`0`，打印回复我们 ping 的 IP 地址。

在这个脚本中，一个接一个地为每个地址执行单独的`ping`命令。这导致当 IP 地址没有回复时，脚本运行缓慢，因为每次 ping 都必须等待超时，然后才能开始下一次 ping。

# 还有更多...

接下来的食谱展示了对 ping 脚本的增强以及如何使用`fping`。

# 平行销

前面的脚本按顺序测试每个地址。每次测试的延迟会累积并变大。并行运行 ping 命令会使速度更快。将循环体封闭在`{}&`中会使`ping`命令并行运行。`( )`封装一组命令作为子 Shell 运行，`&`将其发送到后台:

```sh
#!/bin/bash 
#Filename: fast_ping.sh 
# Change base address 192.168.0 according to your network. 

for ip in 192.168.0.{1..255} ; 
do 
   ( 
      ping $ip -c2 &> /dev/null ; 

      if [ $? -eq0 ]; 
      then 
       echo $ip is alive 
      fi 
   )& 
  done 
wait 

```

在`for`循环中，我们执行许多后台进程并退出循环，终止脚本。`wait`命令防止脚本终止，直到其所有子进程退出。

The output will be in the order that pings reply. This will not be the numeric order in which they were sent if some machines or network segments are slower than others.

# 使用 fping

第二种方法使用不同的命令`fping`。`fping`命令生成 ICMP 消息到多个 IP 地址，然后等待看哪个回复。它比第一个脚本运行得快得多。

`fping`可用的选项包括:

*   带有`fping`的`-a`选项指定显示可用机器的 IP 地址
*   带有`fping`的`-u`选项指定显示不可到达的机器
*   `-g`选项指定从指定为 IP/掩码或起始和结束 IP 地址的斜线子网掩码符号生成一系列 IP 地址:

```sh
 $ fping -a 192.160.1/24 -g 

```

或者，这可以用于:

```sh
 $ fping -a 192.160.1 192.168.0.255 -g 

```

*   `2>/dev/null`用于将由于主机不可达而打印的错误消息转储到空设备

也可以通过`stdin`手动指定一个 IP 地址列表作为命令行参数或列表。考虑以下示例:

```sh
$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6 
# Passes IP address as arguments 
$ fping -a <ip.list 
# Passes a list of IP addresses from a file 

```

# 请参见

*   [第一章](01.html)、*中的*玩转文件描述符和重定向*食谱解释了数据重定向*
*   [第一章](01.html)*中的*比较和测试*食谱解释了数字比较*

# 使用 SSH 在远程主机上运行命令

**SSH** 代表**安全壳**。它通过加密隧道连接两台计算机。SSH 让您可以访问远程计算机上的 Shell，您可以在其中交互运行单个命令并接收结果或启动交互会话。

# 准备好了

SSH 并没有预装在所有的 GNU/Linux 发行版中。您可能需要使用软件包管理器安装`openssh-server`和`openssh-client`软件包。默认情况下，SSH 运行在端口号`22`上。

# 怎么做...

1.  要在 SSH 服务器运行的情况下连接到远程主机，请使用以下命令:

```sh
 $ ssh username@remote_host 

```

该命令中的选项如下:

*   `username`是存在于远程主机上的用户

*   `remote_host`可以是域名或 IP 地址

考虑这个例子:

```sh
 $ ssh mec@192.168.0.1 
 The authenticity of host '192.168.0.1 (192.168.0.1)' can't be   
        established. 
 RSA key fingerprint is   
        2b:b4:90:79:49:0a:f1:b3:8a:db:9f:73:2d:75:d6:f9. 
 Are you sure you want to continue connecting (yes/no)? yes 
 Warning: Permanently added '192.168.0.1' (RSA) to the list of   
        known hosts. 
 Password: 

 Last login: Fri Sep  3 05:15:21 2010 from 192.168.0.82 
 mec@proxy-1:~$ 

```

SSH 将要求输入密码，成功认证后，它将连接到远程机器上的登录 Shell。

SSH performs a fingerprint verification to make sure we are actually connecting to the remote computer we want. This is to avoid what is called a **man-in-the-middle attack**, where an attacker tries to impersonate another computer. SSH will, by default, store the fingerprint the first time we connect to a server and verify that it does not change for future connections.

默认情况下，SSH 服务器运行在端口`22`。但是，某些服务器在不同的端口运行 SSH 服务。在这种情况下，使用`-p port_num`和`ssh`命令来指定端口。

2.  连接到运行在端口`422`的 SSH 服务器:

```sh
 $ ssh user@locahost -p 422 

```

在 shell 脚本中使用`ssh`时，我们不需要交互 shell，我们只想在远程系统上执行命令并处理命令的输出。

Issuing a password every time is not practical for an automated script, so password-less login using SSH keys should be configured. The *P*a*ssword-less auto-login with SSH* recipe in this chapter explains the SSH commands to set this up.

3.  要在远程主机上运行命令并在本地 shell 上显示其输出，请使用以下语法:

```sh
 $ sshuser@host 'COMMANDS' 

```

考虑这个例子:

```sh
 $ ssh mec@192.168.0.1 'whoami' 
 mec

```

您可以通过用分号分隔命令来提交多个命令:

```sh
 $ ssh user@host "command1 ; command2 ; command3" 

```

考虑以下示例:

```sh
 $ ssh mec@192.168.0.1  "echo user: $(whoami);echo OS: $(uname)" 
 Password: user: mec OS: Linux 

```

在本例中，在远程主机上执行的命令如下:

```sh
 echo user: $(whoami); 
 echo OS: $(uname) 

```

我们可以使用`( )`子壳运算符在命令序列中传递一个更复杂的子壳。

3.  下一个示例是基于 SSH 的 shell 脚本，用于收集远程主机列表的正常运行时间。正常运行时间是指自上次通电以来的时间长度。由`uptime`命令返回。

假设`IP_LIST`中的所有系统都有一个共同的用户`test`。

```sh
 #!/bin/bash 
 #Filename: uptime.sh 
 #Description: Uptime monitor 

 IP_LIST="192.168.0.1 192.168.0.5 192.168.0.9" 
 USER="test" 

 for IP in $IP_LIST; 
 do 
 utime=$(ssh ${USER}@${IP} uptime  |awk '{ print $3 }' ) 
 echo $IP uptime:  $utime 
 done 

```

预期产出:

```sh
 $ ./uptime.sh 
 192.168.0.1 uptime: 1:50, 
 192.168.0.5 uptime: 2:15, 
 192.168.0.9 uptime: 10:15, 

```

# 还有更多...

可以通过几个附加选项来执行`ssh`命令。

# 带压缩的 SSH

SSH 协议支持压缩数据传输。当带宽有问题时，这个特性就派上用场了。使用`-C`选项和`ssh`命令启用压缩:

```sh
$ ssh -C user@hostname COMMANDS 

```

# 将数据重定向到远程主机 Shell 命令的标准输入中

SSH 允许您将本地系统上任务的输出用作远程系统上的输入:

```sh
$ echo 'text' | ssh user@remote_host 'echo' 
text 

```

或者，这可以用于:

```sh
# Redirect data from file as: 
$ ssh user@remote_host 'echo'  < file 

```

远程主机上的`echo`打印通过`stdin`接收的数据，该数据又从本地主机传递到`stdin`。

该工具可用于将 tar 档案从本地主机传输到远程主机。这在[第 7 章](07.html)*后备计划*中有详细描述:

```sh
$> tar -czf - LOCALFOLDER | ssh 'tar -xzvf-' 

```

# 在远程机器上运行图形命令

如果您试图在使用图形窗口的远程机器上运行命令，您将看到类似于`cannot open display`的错误。这是因为`ssh`Shell 正在尝试(并且失败)连接到远程机器上的 X 服务器。

# 怎么做...

要在远程服务器上运行图形应用，您需要设置`$DISPLAY`变量来强制应用连接到本地机器上的 X 服务器:

```sh
ssh user@host "export DISPLAY=:0 ; command1; command2""" 

```

这将在远程机器上启动图形输出。

如果您想在本地计算机上显示图形输出，请使用 SSH 的 X11 转发选项:

```sh
ssh -X user@host "command1; command2" 

```

这将在远程计算机上运行命令，但会在您的计算机上显示图形。

# 请参见

*   本章中的*无密码 SSH 自动登录*食谱解释了如何配置自动登录来执行命令而不提示输入密码

# 通过网络传输文件

联网计算机的一个主要用途是资源共享。文件是一种公共共享资源。在系统之间传输文件有不同的方法，从 u 盘和`sneakernet`到网络链接，如 NFS 和桑巴。这些菜谱描述了如何使用常见协议 FTP、s FTP、RSYNC 和 SCP 传输文件。

# 准备好

默认情况下，在 Linux 安装中，通过网络执行文件传输的命令大多可用。可以使用传统的`ftp`命令或更新的`lftp`通过文件传输协议传输文件，或者使用`scp`或`sftp`通过 SSH 连接传输文件。文件可以通过`rsync`命令跨系统同步。

# 怎么做...

**文件传输协议** ( **FTP** )比较老，很多公共网站都用它来共享文件。该服务通常在端口`21`上运行。FTP 要求在远程计算机上安装并运行 FTP 服务器。我们可以使用传统的`ftp`命令或更新的`lftp`命令来访问支持文件传输协议的服务器。`ftp`和`lftp`都支持以下命令。许多公共网站都使用 FTP 来共享文件。

要连接到 FTP 服务器并在其中来回传输文件，请使用以下命令:

```sh
$ lftpusername@ftphost 

```

它将提示输入密码，然后显示登录提示:

```sh
lftp username@ftphost:~> 

```

您可以在此提示符下键入命令，如下所示:

*   `cd directory`:这会改变远程系统上的目录
*   `lcd:`这将改变本地机器上的目录
*   `mkdir`:这将在远程机器上创建一个目录
*   `ls`:这将列出远程机器上当前目录中的文件
*   `get FILENAME`:这将把一个文件下载到本地机器上的当前目录:

```sh
 lftp username@ftphost:~> get filename 

```

*   `put filename`:这将从远程机器上的当前目录上传文件:

```sh
 lftp username@ftphost:~> put filename 

```

*   `quit`命令将终止`lftp`会话

`lftp`提示支持自动完成

# 还有更多...

让我们来看一下用于通过网络传输文件的其他技术和命令。

# 自动文件传输协议传输

`lftp`和`ftp`命令打开与用户的交互会话。我们可以通过一个 shell 脚本自动执行 FTP 文件传输:

```sh
#!/bin/bash 

#Automated FTP transfer 
HOST=example.com' 
USER='foo' 
PASSWD='password' 
lftp  -u ${USER}:${PASSWD} $HOST <<EOF 

binary 
cd /home/foo 
put testfile.jpg 

quit 
EOF 

```

前面的脚本具有以下结构:

```sh
<<EOF 
DATA 
EOF 

```

用于通过`stdin`向`lftp`命令发送数据。*玩转文件描述符和重定向[第一章](01.html)、*Shell 化*的*配方，解释了重定向到 *stdin* 的各种方法。

`-u`选项使用我们定义的`USER`和`PASSWD`登录到远程站点。`binary`命令将文件模式设置为二进制。

# SFTP

SFTP 是一个文件传输系统，运行在 SSH 连接之上，模拟 FTP 接口。它需要远程系统上的 SSH 服务器，而不是 FTP 服务器。它提供带有`sftp`提示的交互会话。

Sftp 支持与`ftp`和`lftp`相同的命令。

要启动`sftp`会话，请使用以下命令:

```sh
$ sftp user@domainname 

```

类似于`lftp`，通过键入`quit`命令可以终止`sftp`会话。

有时，SSH 服务器不会在默认端口`22`运行。如果它在不同的端口运行，我们可以将该端口与`sftp`一起指定为`-oPort=PORTNO`。考虑这个例子:

```sh
$ sftp -oPort=422 user@slynux.org 

```

`-oPort`应该是`sftp`命令的第一个参数。

# rsync 命令

`rsync`命令广泛用于通过网络复制文件和拍摄备份快照。这在*使用 rsync 备份快照*中有详细描述

[第七章](07.html)*备用计划*的配方。

# 安全复制程序

SCP 是一个安全的文件复制命令，类似于旧的、不安全的远程复制工具`rcp`。使用 SSH 通过加密通道传输文件:

```sh
$ scp filename user@remotehost:/home/path 

```

这将提示输入密码。像`ssh`一样，可以通过自动登录 SSH 技术进行无密码传输。本章中的*无密码 SSH 自动登录*食谱解释了 SSH 自动登录。SSH 登录自动化后，无需交互式密码提示即可执行 scp 命令。

`remotehost`可以是一个 IP 地址或域名。`scp`命令的格式如下:

```sh
$ scp SOURCE DESTINATION 

```

`SOURCE`或`DESTINATION`可以是`username@host:/path`格式:

```sh
$ scp user@remotehost:/home/path/filename filename 

```

前面的命令使用给定的文件名将文件从远程主机复制到当前目录。

如果 SSH 运行在不同于`22`的端口，请使用相同语法的`-oPort``sftp`。

# scp 递归复制

`-r`参数告诉`scp`在两台机器之间递归复制一个目录:

```sh
$ scp -r /home/usernameuser@remotehost:/home/backups 
# Copies the directory /home/usernameto the remote backup 

```

`-p`参数会使`scp`在复制文件时保留权限和模式。

# 请参见

*   [第 1 章](01.html)、*中的*玩文件描述符和重定向*食谱解释了使用 EOF 的标准输入*

# 连接到无线网络

以太网连接易于配置，因为它是通过有线电缆连接的，没有身份验证等特殊要求。然而，无线局域网需要一个**扩展服务集标识**网络标识符(**ESID**)并且可能还需要一个密码。

# 准备好了

要连接到有线网络，我们只需使用`ifconfig`实用程序分配一个 IP 地址和子网掩码。无线网络连接需要`iwconfig`和`iwlist`实用程序。

# 怎么做...

该脚本将使用 **WEP** ( **有线等效隐私**)连接到无线局域网:

```sh
#!/bin/bash 
#Filename: wlan_connect.sh 
#Description: Connect to Wireless LAN 

#Modify the parameters below according to your settings 
######### PARAMETERS ########### 
IFACE=wlan0 
IP_ADDR=192.168.1.5 
SUBNET_MASK=255.255.255.0 
GW=192.168.1.1 
HW_ADDR='00:1c:bf:87:25:d2' 
#Comment above line if you don't want to spoof mac address 

ESSID="homenet" 
WEP_KEY=8b140b20e7 
FREQ=2.462G 
################################# 

KEY_PART="" 

if [[ -n $WEP_KEY ]]; 
then 
 KEY_PART="key $WEP_KEY" 
fi 

if [ $UID -ne 0 ]; 
then 
 echo "Run as root" 
 exit 1; 
fi 

# Shut down the interface before setting new config 
/sbin/ifconfig $IFACE down 

if [[ -n $HW_ADDR  ]]; 
then 
 /sbin/ifconfig $IFACE hw ether $HW_ADDR 
 echo Spoofed MAC ADDRESS to $HW_ADDR 
fi 

/sbin/iwconfig $IFACE essid $ESSID $KEY_PART freq $FREQ 

/sbin/ifconfig $IFACE $IP_ADDR netmask $SUBNET_MASK 

route add default gw $GW $IFACE 

echo Successfully configured $IFACE 

```

# 它是如何工作的...

`ifconfig`、`iwconfig`和`route`命令必须以 root 用户身份运行。因此，在脚本中执行任何操作之前，都会对根用户进行检查。

无线局域网需要`essid`、`key`、`frequency`等参数连接网络。`essid`是要连接的无线网络的名称。一些网络使用 WEP 密钥进行身份验证，该密钥通常是五个或十个字母的十六进制密码。`iwconfig`命令要求分配给网络的频率，以便将无线卡连接到适当的无线网络。

`iwlist`实用程序将扫描并列出可用的无线网络:

```sh
# iwlist scan 
wlan0     Scan completed : 
 Cell 01 - Address: 00:12:17:7B:1C:65 
 Channel:11 
 Frequency:2.462 GHz (Channel 11) 
 Quality=33/70  Signal level=-77 dBm 
 Encryption key:on 
 ESSID:"model-2" 

```

`Frequency`参数可以从扫描结果中提取，从`Frequency:2.462 GHz (Channel 11)`线提取。

WEP is used in this example for simplicity. Note that WEP is insecure. If you are administering the wireless network, use a variant of **Wi-Fi Protected Access2** (**WPA2**).

# 请参见

*   [第一章](01.html)*的*比较和测试*食谱解释了字符串比较*

# 通过 SSH 实现无密码自动登录

SSH 被广泛用于自动化脚本，因为它可以在远程主机上远程执行命令并读取它们的输出。通常，SSH 使用用户名和密码进行身份验证，这是在 SSH 命令执行过程中提示的。在自动脚本中提供密码是不切实际的，因此我们需要自动登录。SSH 有一个允许会话自动登录的功能。这个食谱描述了如何为自动登录创建 SSH 密钥。

# 准备好

SSH 使用一种称为非对称密钥的加密技术，由两个密钥组成——一个公钥和一个私钥，用于自动身份验证。`ssh-keygen`应用创建一个认证密钥对。要自动进行身份验证，必须将公钥放在服务器上(通过将公钥附加到`~/.ssh/authorized_keys`文件中)，并且这对密钥的私钥文件应该出现在客户端机器上用户的`~/.ssh`目录中。SSH 配置选项(例如，`authorized_keys`文件的路径和名称)可以通过更改`/etc/ssh/sshd_config`配置文件来修改。

# 怎么做...

使用 SSH 实现自动身份验证有两个步骤。它们如下:

*   在本地计算机上创建 SSH 密钥
*   将公钥传送到远程主机并附加到`~/.ssh/authorized_keys`(需要访问远程机器)

要创建 SSH 密钥，请使用指定为 RSA 的加密算法类型运行`ssh-keygen`命令:

```sh
$ ssh-keygen -t rsa 
Generating public/private rsa key pair.  
Enter file in which to save the key (/home/username/.ssh/id_rsa):  
Created directory '/home/username/.ssh'.  
Enter passphrase (empty for no passphrase):  
Enter same passphrase again:  
Your identification has been saved in /home/username/.ssh/id_rsa.  
Your public key has been saved in /home/username/.ssh/id_rsa.pub.  
The key fingerprint is:  
f7:17:c6:4d:c9:ee:17:00:af:0f:b3:27:a6:9c:0a:05 username@slynux-laptop 
The key'srandomart image is:  
+--[ RSA 2048]----+  
|           .     |  
|            o . .| 
|     E       o o.| 
|      ...oo |  
|       .S .+  +o.|  
|      .  . .=....|  
|     .+.o...|  
|      . . + o.  .| 
|       ..+       |  
+-----------------+  

```

您需要输入密码来生成公钥-私钥对。无需输入密码即可生成密钥对，但这是不安全的。

如果您打算编写使用自动登录多台计算机的脚本，您应该将密码留空，以防止脚本在运行时要求输入密码。

`ssh-keygen`程序创建两个文件。`~/.ssh/id_rsa.pub``~/.ssh/id_rsa:id_rsa.pub`是生成的公钥，`id_rsa`是私钥。公钥必须附加到远程服务器上的`~/.ssh/authorized_keys`文件中，我们需要从当前主机自动登录。

该命令将附加一个密钥文件:

```sh
$ ssh USER@REMOTE_HOST \
    "cat >> ~/.ssh/authorized_keys" < ~/.ssh/id_rsa.pub
Password:

```

在前面的命令中提供登录密码。

自动登录已经从现在开始设置，所以 SSH 在执行过程中不会提示输入密码。使用以下命令进行测试:

```sh
$ ssh USER@REMOTE_HOST uname 
Linux 

```

系统不会提示您输入密码。大多数 Linux 发行版都包含`ssh-copy-id`，它会将您的私钥附加到远程服务器上适当的`authorized_keys`文件中。这比前面描述的`ssh`技术要短:

```sh
ssh-copy-id USER@REMOTE_HOST 

```

# 使用 SSH 的端口转发

端口转发是一种将 IP 连接从一台主机重定向到另一台主机的技术。例如，如果您使用 Linux/Unix 系统作为防火墙，您可以将端口`1234`的连接重定向到内部地址，如`192.168.1.10:22`，以提供从外部世界到内部机器的`ssh`隧道。

# 怎么做...

您可以将本地机器上的端口转发到另一台机器，也可以将远程机器上的端口转发到另一台机器。在下面的示例中，一旦转发完成，您将获得一个 shell 提示。保持这个 Shell 打开以使用端口转发，并在您想要停止端口转发时退出它。

1.  该命令会将本地机器上的端口`8000`转发到[www.kernel.org](http://www.kernel.org)上的端口`80`:

```sh
 ssh -L 8000:www.kernel.org:80user@localhost 

```

用本地计算机上的用户名替换用户。

2.  该命令将远程机器上的端口 8000 转发到 www.kernel.org 的端口`80`:

```sh
 ssh -L 8000:www.kernel.org:80user@REMOTE_MACHINE 

```

在这里，将`REMOTE_MACHINE`替换为远程机器的主机名或 IP 地址，将`user`替换为您可以通过 SSH 访问的用户名。

# 还有更多...

使用非交互模式或反向端口转发时，端口转发更有用。

# 非交互式端口转发

如果您只想设置端口转发，而不是在端口转发有效时保持 Shell 打开，请使用以下形式的`ssh`:

```sh
ssh -fL8000:www.kernel.org:80user@localhost -N 

```

`-f`选项指示`ssh`在执行命令之前分叉到后台。`-N`告诉`ssh`没有跑的命令；我们只想转发端口。

# 反向端口转发

反向端口转发是 SSH 最强大的功能之一。这在您的计算机不能从互联网公开访问，但您希望其他人能够访问该计算机上的服务的情况下非常有用。在这种情况下，如果您可以通过 SSH 访问可在互联网上公开访问的远程计算机，您可以在该远程计算机上设置一个反向端口，以转发到运行该服务的本地计算机。

```sh
ssh -R 8000:localhost:80 user@REMOTE_MACHINE 

```

该命令将远程机器上的端口`8000`转发到本地机器上的端口`80`。不要忘记将`REMOTE_MACHINE`替换为远程机器的 IP 地址的主机名。

使用这种方法，如果您浏览到远程机器上的`http://localhost:8000`，您将连接到运行在本地机器端口`80`上的网络服务器。

# 在本地挂载点挂载远程驱动器

拥有本地装载点来访问远程主机文件系统有助于读写数据传输操作。SSH 是常见的传输协议。`sshfs`应用使用 SSH 使您能够在本地挂载点挂载远程文件系统。

# 准备好了

`sshfs`默认情况下不会出现在 GNU/Linux 发行版中。用包管理器安装`sshfs`。`sshfs`是 FUSE 文件系统包的扩展，允许用户像本地文件系统一样装载各种各样的数据。Linux、Unix、Mac OS/X、Windows 等都支持 FUSE 的变体。

For more information on FUSE, visit its website at [http://fuse.sourceforge.net/](http://fuse.sourceforge.net/).

# 怎么做...

要将远程主机上的文件系统位置装载到本地装载点，请执行以下操作:

```sh
# sshfs -o allow_otheruser@remotehost:/home/path /mnt/mountpoint 
Password: 

```

出现提示时，发出密码。接受密码后，可以通过本地挂载点`/mnt/mountpoint`访问远程主机上`/home/path`的数据。

要卸载，请使用以下命令:

```sh
# umount /mnt/mountpoint 

```

# 请参见

*   本章中的*使用 SSH* 在远程主机上运行命令解释了`ssh`命令

# 网络流量和端口分析

每个访问网络的应用都是通过端口来访问网络的。列出开放端口、使用端口的应用和运行应用的用户是跟踪系统预期和意外使用的一种方式。这些信息可用于分配资源以及检查 rootkits 或其他恶意软件。

# 准备好

各种命令可用于列出网络节点上运行的端口和服务。大多数 GNU/Linux 发行版上都有`lsof`和`netstat`命令。

# 怎么做...

`lsof`(列出打开的文件)命令将列出打开的文件。`-i`选项限制其打开网络连接:

```sh
$ lsof -i 
COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE 
    NAME

firefox-b 2261 slynux   78u  IPv4  63729      0t0  TCP 
    localhost:47797->localhost:42486 (ESTABLISHED)

firefox-b 2261 slynux   80u  IPv4  68270      0t0  TCP 
    slynux-laptop.local:41204->192.168.0.2:3128 (CLOSE_WAIT)

firefox-b 2261 slynux   82u  IPv4  68195      0t0  TCP 
    slynux-laptop.local:41197->192.168.0.2:3128 (ESTABLISHED)

ssh       3570 slynux    3u  IPv6  30025      0t0  TCP 
    localhost:39263->localhost:ssh (ESTABLISHED)

ssh       3836 slynux    3u  IPv4  43431      0t0  TCP 
    slynux-laptop.local:40414->boney.mt.org:422 (ESTABLISHED)

GoogleTal 4022 slynux   12u  IPv4  55370      0t0  TCP 
    localhost:42486 (LISTEN)

GoogleTal 4022 slynux   13u  IPv4  55379      0t0  TCP 
    localhost:42486->localhost:32955 (ESTABLISHED)

```

`lsof`输出中的每个条目对应一个具有活动网络端口的服务。输出的最后一列由类似如下的行组成:

```sh
laptop.local:41197->192.168.0.2:3128 

```

在该输出中，`laptop.local:41197`对应于`localhost`，`192.168.0.2:3128`对应于远程主机。`41197`是当前机器上使用的端口，`3128`是服务在远程主机上连接的端口。

要列出当前机器上打开的端口，请使用以下命令:

```sh
$ lsof -i | grep ":[0-9a-z]+->" -o | grep "[0-9a-z]+" -o  | sort | uniq 

```

# 它是如何工作的...

grep 的`:[0-9a-z]+->`正则表达式从`lsof`输出中提取主机端口部分`(:34395-> or :ssh->)`。下一个`grep`删除左冒号和右箭头，留下端口号(由字母数字组成)。多个连接可能通过同一个端口出现，因此，同一端口的多个条目可能出现。输出经过排序并通过`uniq`显示每个端口一次。

# 还有更多...

有更多的实用程序报告开放端口和网络流量的相关信息。

# 使用 netstat 打开端口和服务

`netstat`还返回网络服务统计。它有许多超出本食谱范围的特点。

使用`netstat -tnp`列出已开通的端口和服务:

```sh
$ netstat -tnp 
Proto Recv-Q Send-Q Local Address           Foreign Address         
    State       PID/Program name 

tcp        0      0 192.168.0.82:38163      192.168.0.2:3128        
    ESTABLISHED 2261/firefox-bin 

tcp        0      0 192.168.0.82:38164      192.168.0.2:3128        
    TIME_WAIT   -               

tcp        0      0 192.168.0.82:40414      193.107.206.24:422      
    ESTABLISHED 3836/ssh

tcp        0      0 127.0.0.1:42486         127.0.0.1:32955         
    ESTABLISHED 4022/GoogleTalkPlug

tcp        0      0 192.168.0.82:38152      192.168.0.2:3128        
    ESTABLISHED 2261/firefox-bin 

tcp6       0      0 ::1:22                  ::1:39263               
    ESTABLISHED -               

tcp6       0      0 ::1:39263               ::1:22                  
    ESTABLISHED 3570/ssh

```

# 测量网络带宽

之前对`ping`和`traceroute`的讨论是关于测量网络的延迟和节点之间的跳数。

`iperf`应用为网络性能提供了更多指标。默认情况下不安装`iperf`应用，但它由大多数发行版的包管理器提供。

# 怎么做...

`iperf`应用必须安装在链路的两端(主机和客户端)。一旦安装了`iperf`，启动服务器端:

```sh
$ iperf -s 

```

然后运行客户端来生成吞吐量统计:

```sh
$ iperf -c 192.168.1.36 
------------------------------------------------------------ 
Client connecting to 192.168.1.36, TCP port 5001 
TCP window size: 19.3 KByte (default) 
------------------------------------------------------------ 
[  3] local 192.168.1.44 port 46526 connected with 192.168.1.36 port 5001 
[ ID] Interval       Transfer     Bandwidth 
[  3]  0.0-10.0 sec   113 MBytes  94.7 Mbits/sec 

```

`-m`选项指示`iperf`也找到**最大传输大小** ( **MTU** ):

```sh
$ iperf -mc 192.168.1.36 
------------------------------------------------------------ 
Client connecting to 192.168.1.36, TCP port 5001 
TCP window size: 19.3 KByte (default) 
------------------------------------------------------------ 
[  3] local 192.168.1.44 port 46558 connected with 192.168.1.36 port 5001 
[ ID] Interval       Transfer     Bandwidth 
[  3]  0.0-10.0 sec   113 MBytes  94.7 Mbits/sec 
[  3] MSS size 1448 bytes (MTU 1500 bytes, ethernet) 

```

# 创建任意套接字

对于文件传输、安全 shell 等操作，有 ftp、`ssh`等预建工具。我们还可以编写自定义脚本作为网络服务。下一个方法演示了如何创建简单的网络套接字并将其用于通信。

# 准备好

`netcat`或`nc`命令将创建网络套接字，通过 TCP/IP 网络传输数据。我们需要两个套接字:一个监听连接，另一个连接到监听器。

# 怎么做...

1.  使用以下命令设置侦听套接字:

```sh
 nc -l 1234 

```

这将在本地机器的端口`1234`上创建一个监听套接字。

2.  使用以下命令连接到套接字:

```sh
 nc HOST 1234 

```

如果您在与监听套接字相同的机器上运行此程序，请将`HOST`替换为 localhost，否则将其替换为机器的 IP 地址或主机名。

3.  在执行第 2 步的终端上输入内容并按下*进入*。该消息将出现在您执行步骤 1 的终端上。

# 还有更多...

网络插座不仅可以用于文本通信，如以下部分所示。

# 通过网络快速复制文件

我们可以利用`netcat`和 shell 重定向在网络上复制文件。该命令将向监听机器发送一个文件:

1.  在侦听计算机上，运行以下命令:

```sh
 nc -l 1234 >destination_filename 

```

2.  在发送方计算机上，运行以下命令:

```sh
 nc HOST 1234 <source_filename 

```

# 创建广播服务器

可以使用`netcan`创建自定义服务器。下一个食谱展示了一个每 10 秒发送一次时间的服务器。通过 telnet 的客户端`nc`会话连接到端口可以接收时间:

```sh
# A script to echo the date out a port 
while [ 1 ] 
do 
 sleep 10 
 date 
done | nc -l 12345  
echo exited 

```

# 它是如何工作的...

使用`nc`复制文件是可行的，因为 ns 将一个套接字的输入与另一个套接字的输出相呼应。

广播服务器稍微复杂一点。`while [ 1 ]`循环将永远运行。在循环中，脚本休眠 10 秒，然后调用日期命令并将输出传送到`nc`命令。

您可以使用`nc`创建客户端，如下所示:

```sh
$ nc 127.0.0.1 12345 

```

# 造桥

如果您有两个独立的网络，您可能需要一种将数据从一个网络传递到另一个网络的方法。这通常通过用路由器、集线器或交换机连接两个子网来实现。

Linux 系统可以用作网桥。

网桥是一种低级连接，它根据数据包的媒体访问控制地址传递数据包，而不是通过 IP 地址进行识别。因此，它需要更少的机器资源，效率更高。

您可以使用网桥来链接私有非路由网络上的虚拟机，或者链接公司中的独立子网，例如，将制造子网链接到运输子网，以便共享生产信息。

# 准备好

从 2.2 内核开始，Linux 内核就支持网桥。当前定义桥的工具是 iproute2 ( `ip`)命令。这是大多数发行版的标准。

# 怎么做...

ip 命令使用命令/子命令模型执行几个操作。要创建桥，我们使用`ip link`命令。

The Ethernet adapter being attached to the bridge should not be configured with an IP address when it is added to the bridge. The bridge is configured with an address, not the NIC.

在本例中，有两张网卡:`eth0`已配置并连接到`192.168.1.0`子网，而 eth1 未配置，但将通过网桥连接到`10.0.0.0`子网:

```sh
 # Create a new bridge named br0 
 ip link add br0 type bridge 

 # Add an Ethernet adapter to the bridge 
 ip link set dev eth1 master br0 

 # Configure the bridge's IP address 
 ifconfig br0 10.0.0.2 

 # Enable packet forwarding 
 echo 1 >/proc/sys/net/ipv4/ip_forward 

```

这就创建了一个网桥，允许数据包从`eth0`发送到`eth1`并返回。在网桥有用之前，我们需要将这个网桥添加到路由表中。

在`10.0.0.0/24`网络中的机器上，我们向`192.168.1.0/16`网络添加一条路由:

```sh
route add -net 192.168.1.0/16 gw 10.0.0.2 

```

`192.168.1.0/16`子网的机器需要知道如何找到`10.0.0.0/24`子网。如果为 IP 地址`192.168.1.2`配置了`eth0`卡，路由命令如下:

```sh
route add -net 10.0.0.0/24 gw 192.168.1.2 

```

# 共享互联网连接

大多数防火墙/路由器都能够与您家中或办公室的设备共享互联网连接。这叫做**网络地址转换** ( **NAT** )。一台带有两张**网络接口卡** ( **网卡**)的 Linux 电脑可以充当路由器，提供防火墙保护和连接共享。

内核内置的 iptables 支持提供了防火墙和 NAT 支持。这个食谱介绍了`iptables`的一个食谱，通过无线接口共享一台计算机的以太网链接到互联网，让其他无线设备通过主机的以太网网卡访问互联网。

# 准备好了

本食谱使用`iptables`定义一个**网络地址转换** ( **NAT** ，它让一个网络设备与其他设备共享一个连接。您将需要无线接口的名称，该名称由`iwconfig`命令报告。

# 怎么做...

1.  连接到互联网。在本食谱中，我们假设主有线网络连接`eth0`连接到互联网。根据您的设置进行更改。
2.  使用发行版的网络管理工具，使用以下设置创建一个新的临时无线连接:

    *   IP 地址:10.99.66.55

*   子网掩码:255.255.0.0 (16)

3.  使用以下 Shell 脚本共享互联网连接:

```sh
 #!/bin/bash 
        #filename: netsharing.sh

        echo 1 > /proc/sys/net/ipv4/ip_forward 

        iptables -A FORWARD -i $1 -o $2 \
            -s 10.99.0.0/16 -m conntrack --ctstate NEW -j ACCEPT 

        iptables -A FORWARD -m conntrack --ctstate \
            ESTABLISHED,RELATED -j ACCEPT

        iptables -A POSTROUTING -t nat -j MASQUERADE 

```

4.  运行脚本:

```sh
 ./netsharing.sh eth0 wlan0 

```

这里`eth0`是连接到互联网的接口，`wlan0`是应该与其他设备共享互联网的无线接口。

5.  使用以下设置将您的设备连接到刚刚创建的无线网络:
    *   IP 地址:10.99.66.56(以此类推)
    *   子网掩码:255.255.0.0

To make this more convenient, you might want to install a DHCP and DNS server on your machine, so it's not necessary to configure IPs on devices manually. A handy tool for this is `dnsmasq`, which performs both DHCP and DNS operations.

# 它是如何工作的

有三组供非路由使用的 IP 地址。这意味着互联网上没有可见的网络接口可以使用它们。它们仅由本地内部网络上的机器使用。地址为`10.x.x.x`、`192.168.x.x`和`172.16.x.x-> 172.32.x.x`。在这个食谱中，我们使用了内部网络的一部分`10.x.x.x`地址空间。

默认情况下，Linux 系统会接受或生成数据包，但不会回应它们。这由值`in/proc/sys/net/ipv4/ip_forward`控制。

将`1`回显到该位置会告诉 Linux 内核转发它无法识别的任何数据包。这允许`10.99.66.x`子网上的无线设备使用`10.99.66.55`作为它们的网关。他们将发送一个以互联网网站为目的地的数据包到`10.99.66.55`，然后由`eth0`的网关转发到互联网，再路由到目的地。

`iptables`命令是我们与 Linux 内核的 iptables 子系统交互的方式。这些命令添加了将所有数据包从内部网络转发到外部世界以及将预期的数据包从外部世界转发到我们的内部网络的规则。

下一个食谱将讨论更多使用 iptables 的方法。

# 使用 iptables 的基本防火墙

防火墙是一种网络服务，用于过滤网络流量中不需要的流量，阻止它，并允许需要的流量通过。Linux 的标准防火墙工具是`iptables`，在最近的版本中集成到内核中。

# 怎么做...

`iptables`在所有现代 Linux 发行版上默认存在。很容易针对常见场景进行配置:

1.  如果不想联系给定的站点(例如，已知的恶意软件站点)，您可以阻止到该 IP 地址的流量:

```sh
 #iptables -A OUTPUT -d 8.8.8.8 -j DROP 

```

如果您在另一个终端中使用`PING 8.8.8.8`，那么通过运行`iptables`命令，您将看到以下内容:

```sh
 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 
 64 bytes from 8.8.8.8: icmp_req=1 ttl=56 time=221 ms 
 64 bytes from 8.8.8.8: icmp_req=2 ttl=56 time=221 ms 
 ping: sendmsg: Operation not permitted 
 ping: sendmsg: Operation not permitted 

```

这里，ping 第三次失败，因为我们使用`iptables`命令将所有流量丢弃到`8.8.8.8`。

2.  您还可以阻止到特定端口的流量:

```sh
 #iptables -A OUTPUT -p tcp -dport 21 -j DROP 
 $ ftp ftp.kde.org 
 ftp: connect: Connection timed out 

```

如果你在你的`/var/log/secure`或`var/log/messages`文件中发现这样的信息，你有一个小问题:

```sh
 Failed password for abel from 1.2.3.4 port 12345 ssh2 
 Failed password for baker from 1.2.3.4 port 12345 ssh2 

```

这些信息意味着一个机器人正在你的系统中寻找弱密码。您可以使用输入规则阻止机器人访问您的站点，该规则将丢弃该站点的所有流量。

```sh
 #iptables -I INPUT -s 1.2.3.4 -j DROP 

```

# 它是如何工作的...

`iptables`是用于在 Linux 上配置防火墙的命令。`iptables`中的第一个参数是-A，它指示`iptables`将新规则附加到链中，或者是-I，它将新规则放在规则集的开头。下一个参数定义了链。链是规则的集合，在早期的配方中，我们使用了`OUTPUT`链，它是针对传出流量进行评估的，而最后一个配方使用了`INPUT`链，它是针对传入流量进行评估的。

`-d`参数指定与正在发送的数据包相匹配的目的地，`-s`指定数据包的来源。最后，`-j`参数指示`iptables`跳到特定动作。在这些示例中，我们使用 DROP 操作来丢弃数据包。其他动作包括`ACCEPT`和`REJECT`。

在第二个例子中，我们使用`-p`参数来指定这个规则只匹配用`-dport`指定的端口上的 TCP。这只会阻碍`FTP`的对外交通。

# 还有更多...

您可以使用`-flush`参数清除对`iptables`链所做的更改:

```sh
#iptables -flush 

```

# 创建虚拟专用网络

一个**虚拟专用网** ( **虚拟专用网**)是一个跨公共网络运行的加密通道。加密使您的信息保密。VPN 用于连接远程办公室、分布式制造站点和远程工作人员。

我们已经和`nc`，或者`scp`，或者`ssh`讨论过复制文件。使用虚拟专用网络，您可以通过 NFS 安装远程驱动器，并像访问本地资源一样访问远程网络上的资源。

Linux 有几个 VPN 系统的客户端，以及 OpenVPN 的客户端和服务器支持。

本节的食谱将描述如何设置 OpenVPN 服务器和客户端。这个方法是配置单个服务器，以在中心和分支模型中服务多个客户端。OpenVPN 支持更多超出本章范围的拓扑。

# 准备好

OpenVPN 不是大多数 Linux 发行版的一部分。您可以使用软件包管理器安装它:

```sh
apt-get install openvpn 

```

或者，也可以使用此命令:

```sh
yum install openvpn 

```

请注意，您需要在服务器和每个客户端上执行此操作。

确认隧道设备(`/dev/net/tun`)存在。在服务器和客户端系统上进行测试。在现代 Linux 系统上，隧道应该已经存在:

```sh
ls /dev/net/tun 

```

# 怎么做...

设置 OpenVPN 网络的第一步是为服务器和至少一个客户端创建证书。处理这种情况最简单的方法是使用 OpenVPN 2.3 版之前版本中包含的`easy-rsa`包制作自签名证书。如果您有更高版本的 OpenVPN，`easy-rsa`应该可以通过包管理器获得。

这个包大概安装在`/usr/share/easy-rsa`里。

# 创建证书

首先，确保您有一个干净的记录，没有以前安装留下的任何东西:

```sh
# cd /usr/share/easy-rsa 
# . ./vars 
# ./clean-all 

```

NOTE: If you run `./clean-all`, I will be doing a `rm -rf` on `/usr/share/easy-rsa/keys`.

接下来，使用`build-ca`命令创建**证书颁发机构**密钥。该命令将提示您输入站点的信息。你必须多次输入这个信息。用您的姓名、电子邮件、网站名称等代替这个食谱中的值。命令之间所需的信息略有不同。只有独特的部分将在这些食谱中重复:

```sh
# ./build-ca 
Generating a 2048 bit RSA private key 
......+++ 
.....................................................+++ 
writing new private key to 'ca.key' 
----- 
You are about to be asked to enter information that will be incorporated 
into your certificate request. 
What you are about to enter is what is called a Distinguished Name or a DN. 
There are quite a few fields but you can leave some blank 
For somefieldsthere will be a default value, 
If you enter '.', the field will be left blank. 
----- 
Country Name (2 letter code) [US]: 
State or Province Name (full name) [CA]:MI 
Locality Name (eg, city) [SanFrancisco]:WhitmoreLake 
Organization Name (eg, company) [Fort-Funston]:Example 
Organizational Unit Name (eg, section) [MyOrganizationalUnit]:Packt 
Common Name (eg, your name or your server's hostname) [Fort-Funston CA]:vpnserver 
Name [EasyRSA]: 
Email Address [me@myhost.mydomain]:admin@example.com 

Next, build the server certificate with the build-key command: 
# ./build-key server 
Generating a 2048 bit RSA private key 
..................................+++ 
.....................+++ 
writing new private key to 'server.key' 
----- 
You are about to be asked to enter information that will be incorporated 
into your certificate request.... 

Please enter the following 'extra' attributes 
to be sent with your certificate request 
A challenge password []: 

```

为至少一个客户端创建证书。对于希望连接到此 OpenVPN 服务器的每台计算机，您需要一个单独的客户端证书:

```sh
# ./build-key client1 
Generating a 2048 bit RSA private key 
.......................+++ 
.................................................+++ 
writing new private key to 'client1.key' 
----- 
You are about to be asked to enter information that will be incorporated 
into your certificate request. 
...  

Please enter the following 'extra' attributes 
to be sent with your certificate request 
A challenge password []: 
An optional company name []: 
Using configuration from /usr/share/easy-rsa/openssl-1.0.0.cnf 
Check that the request matches the signature 
Signature ok 
The Subject's Distinguished Name is as follows 
countryName  :PRINTABLE:'US' 
stateOrProvinceName  :PRINTABLE:'MI' 
localityName  :PRINTABLE:'WhitmoreLake' 
organizationName  :PRINTABLE:'Example' 
organizationalUnitName:PRINTABLE:'Packt' 
commonName  :PRINTABLE:'client1' 
name                  :PRINTABLE:'EasyRSA' 
emailAddress:IA5STRING:'admin@example.com' 
Certificate is to be certified until Jan  8 15:24:13 2027 GMT (3650 days) 
Sign the certificate? [y/n]:y 

1 out of 1 certificate requests certified, commit? [y/n]y 
Write out database with 1 new entries 
Data Base Updated 

```

最后，用`build-dh`命令生成**迪菲-赫尔曼**。这将需要几秒钟的时间，并会生成几个充满点和加号的屏幕:

```sh
# ./build-dh 
Generating DH parameters, 2048 bit long safe prime, generator 2 
This is going to take a long time 
......................+............+........ 

```

这些步骤将在密钥文件夹中创建几个文件。下一步是将它们复制到将要使用的文件夹中。

将服务器密钥复制到`/etc/openvpn`:

```sh
# cp keys/server* /etc/openvpn 
# cp keys/ca.crt /etc/openvpn 
# cp keys/dh2048.pem /etc/openvpn 

```

将客户端密钥复制到客户端系统:

```sh
# scp keys/client1* client.example.com:/etc/openvpn 
# scp keys/ca.crt client.example.com:/etc/openvpn 

```

# 在服务器上配置 OpenVPN

OpenVPN 包括几乎可以使用的示例配置文件。您只需要为您的环境定制几行代码。文件常见于`/usr/share/doc/openvpn/examples/sample-config-files`:

```sh
# cd /usr/share/doc/openvpn/examples/sample-config-files 
# cp server.conf.gz /etc/openvpn 
# cd /etc/openvpn 
# gunzip server.conf.gz 
# vim server.conf 

```

设置要监听的本地 IP 地址。这是连接到网络的网卡的 IP 地址，您打算通过它来允许 VPN 连接:

```sh
local 192.168.1.125 
Modify the paths to the certificates: 

ca /etc/openvpn/ca.crt 
cert /etc/openvpn/server.crt 
key /etc/openvpn/server.key  # This file should be kept secret 

```

最后，检查`diffie-hellman`参数文件是否正确。OpenVPN 示例`config`文件可以指定一个 1024 位长度的密钥，而`easy-rsa`创建一个 2048 位(更安全)的密钥。

```sh
#dh dh1024.pem 
dh dh2048.pem 

```

# 在客户端配置 OpenVPN

每个客户端上都有一组类似的配置。

将客户端配置文件复制到`/etc/openvpn`:

```sh
# cd /usr/share/doc/openvpn/examples/sample-config-files 
# cpclient.conf /etc/openvpn 

```

编辑`client.conf`文件:

```sh
# cd /etc/openvpn 
# vim client.conf 

```

将证书的路径更改为指向正确的文件夹:

```sh
ca /etc/openvpn/ca.crt 
cert /etc/openvpn/server.crt 
key /etc/openvpn/server.key  # This file should be kept secret 

```

为您的服务器设置远程站点:

```sh
#remote my-server-1 1194 
remote server.example.com 1194 

```

# 启动服务器

服务器现在可以启动了。如果一切配置正确，您将看到它输出几行输出。要找的重要线是`Initialization Sequence Completed`线。如果缺少该选项，请在输出中查找前面的错误消息:

```sh
# openvpnserver.conf 
Wed Jan 11 12:31:08 2017 OpenVPN 2.3.4 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6] built on Nov 12 2015 
Wed Jan 11 12:31:08 2017 library versions: OpenSSL 1.0.1t  3 May 2016, LZO 2.08... 

Wed Jan 11 12:31:08 2017 client1,10.8.0.4 
Wed Jan 11 12:31:08 2017 Initialization Sequence Completed 

```

使用`ifconfig`，可以确认服务器正在运行。您应该会看到列出的隧道设备(调谐器):

```sh
$ ifconfig 
tun0      Link encap:UNSPECHWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00   
inet addr:10.8.0.1  P-t-P:10.8.0.2  Mask:255.255.255.255 
 UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1 
 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
 collisions:0 txqueuelen:100 
 RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B) 

```

# 启动和测试客户端

服务器运行后，您可以启动客户端。和服务器一样，OpenVPN 的客户端是用`openvpn`命令创建的。同样，该输出的重要部分是`Initialization Sequence Completed`线:

```sh
# openvpn client.conf 
Wed Jan 11 12:34:14 2017 OpenVPN 2.3.4 i586-pc-linux-gnu [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6] built on Nov 19 2015 
Wed Jan 11 12:34:14 2017 library versions: OpenSSL 1.0.1t  3 May 2016, LZO 2.08... 

Wed Jan 11 12:34:17 2017 /sbin/ipaddr add dev tun0 local 10.8.0.6 peer 10.8.0.5 
Wed Jan 11 12:34:17 2017 /sbin/ip route add 10.8.0.1/32 via 10.8.0.5 
Wed Jan 11 12:34:17 2017 Initialization Sequence Completed 

```

使用`ifconfig`命令，可以确认隧道已经初始化:

```sh
$ /sbin/ifconfig 

tun0      Link encap:UNSPECHWaddr 00-00-00-00-00-00-00-00...00-00-00-00   
inet addr:10.8.0.6  P-t-P:10.8.0.5  Mask:255.255.255.255 
 UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1 
 RX packets:2 errors:0 dropped:0 overruns:0 frame:0 
 TX packets:4 errors:0 dropped:0 overruns:0 carrier:0 
 collisions:0 txqueuelen:100 
 RX bytes:168 (168.0 B)  TX bytes:336 (336.0 B) 

```

使用`netstat`命令确认新网络路由正确:

```sh
$ netstat -rn 
Kernel IP routing table 
Destination   Gateway       Genmask         Flags   MSS Window  irttIface 
0.0.0.0       192.168.1.7   0.0.0.0         UG        0 0          0 eth0 
10.8.0.1      10.8.0.5      255.255.255.255 UGH       0 0          0 tun0 
10.8.0.5      0.0.0.0       255.255.255.255 UH        0 0          0 tun0 
192.168.1.0   0.0.0.0       255.255.255.0   U         0 0          0 eth0 

```

该输出显示连接到`10.8.0.x`网络的隧道设备，网关为`10.8.0.1`。

最后，您可以使用`ping`命令测试连通性:

```sh
$ ping 10.8.0.1 
PING 10.8.0.1 (10.8.0.1) 56(84) bytes of data. 
64 bytes from 10.8.0.1: icmp_seq=1 ttl=64 time=1.44 ms 

```