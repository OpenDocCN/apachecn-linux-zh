# 一、使用 Shell 输出一些东西

在本章中，我们将介绍以下食谱:

*   在终端中显示输出
*   使用变量和环境变量
*   附加到环境变量的函数
*   带壳的数学
*   玩文件描述符和重定向
*   数组和关联数组
*   访问别名
*   获取关于终端的信息
*   获取和设置日期和延迟
*   调试脚本
*   函数和参数
*   从一个命令向另一个命令发送输出
*   不按回车键读取`n`字符
*   运行命令直到成功
*   字段分隔符和迭代器
*   比较和测试
*   使用配置文件定制 bash

# 介绍

最初，计算机从卡片或磁带上读取程序，并生成一份报告。没有操作系统，没有图形显示器，甚至没有交互式提示。

到了 20 世纪 60 年代，计算机支持交互式终端(通常是电传打字机或美化的打字机)来调用命令。

当贝尔实验室为全新的 Unix 操作系统创建交互式用户界面时，它有一个独特的功能。它可以从文本文件(称为Shell脚本)中读取和评估相同的命令，就像它接受在终端上键入一样。

这个设施是生产力的巨大飞跃。程序员不用键入几个命令来执行一组操作，而是可以将命令保存在一个文件中，稍后只需击几下键就可以运行它们。shell 脚本不仅可以节省时间，还可以记录您所做的事情。

最初，Unix 支持一个由斯蒂芬·伯恩编写的交互式Shell，并将其命名为**伯恩Shell** ( **sh** )。

1989 年，GNU 项目的布莱恩·福克斯从许多用户界面中提取功能，并创建了一个新的Shell——伯恩再一次Shell(T1)(**bash**)。bash shell 理解伯恩 shell 的所有构造，并添加了 csh、ksh 和其他的特性。

随着 Linux 成为像操作系统一样的 Unix 最流行的实现，bash shell 已经成为 Unix 和 Linux 上事实上的标准 shell。

这本书的重点是 Linux 和 bash。即便如此，这些脚本中的大多数都将在 Linux 和 Unix 上运行，使用 bash、sh、ash、dash、ksh 或其他 sh 风格的Shell。

本章将让读者深入了解 shell 环境，并演示一些基本的 shell 特性。

# 在终端中显示输出

用户通过终端会话与Shell环境交互。如果您运行的是基于图形用户界面的系统，这将是一个终端窗口。如果您在没有 GUI(生产服务器或 ssh 会话)的情况下运行，您一登录就会看到 shell 提示。

在终端中显示文本是大多数脚本和实用程序需要定期执行的任务。Shell支持几种显示文本的方法和不同格式。

# 准备好

命令在终端会话中键入和执行。打开终端时，会显示提示。提示可以通过多种方式进行配置，但通常类似于以下内容:

```sh
username@hostname$

```

或者，也可以将其配置为`root@hostname #`或简单地配置为`$`或`#`。

`$`字符代表普通用户，`#`代表管理用户根。Root 是 Linux 系统中最有特权的用户。

It is a bad idea to directly use the shell as the root user (administrator) to perform tasks. Typing errors have the potential to do more damage when your shell has more privileges. It is recommended that you log in as a regular user (your shell may denote this as `$` in the prompt), and use tools such as `sudo` to run privileged commands. Running a command as `sudo <command> <arguments>` will run it as root.

shell 脚本通常以一个 shebang 开头:

```sh
#!/bin/bash

```

Shebang 是一行，在该行上`#!`是解释器路径的前缀。`/bin/bash`是 Bash 的解释器命令路径。以`#`符号开头的一行被 bash 解释器视为注释。只有脚本的第一行可以有一个 shebang 来定义用于评估脚本的解释器。

脚本可以通过两种方式执行:

1.  将脚本的名称作为命令行参数传递:

```sh
 bash myScript.sh

```

2.  设置脚本文件的执行权限，使其可执行:

```sh
 chmod 755 myScript.sh ./myScript.sh.

```

如果脚本作为`bash`的命令行参数运行，则不需要 shebang。shebang 有助于独立运行脚本。可执行脚本使用 shebang 后面的解释器路径来解释脚本。

使用`chmod`命令可执行脚本:

```sh
$ chmod a+x sample.sh

```

此命令使脚本可由所有用户执行。该脚本可以按如下方式执行:

```sh
$ ./sample.sh #./ represents the current directory

```

或者，脚本可以这样执行:

```sh
$ /home/path/sample.sh # Full path of the script is used

```

内核会读取第一行，看到 shebang 是`#!/bin/bash`。它将识别`/bin/bash`并执行如下脚本:

```sh
$ /bin/bash sample.sh

```

当交互式Shell启动时，它会执行一组命令来初始化设置，如提示文本、颜色等。这些命令是从位于用户主目录的`~/.bashrc`(或登录Shell的`~/.bash_profile`)Shell脚本中读取的。Bash shell 在`~/.bash_history`文件中维护用户运行命令的历史记录。

The `~` symbol denotes your home directory, which is usually `/home/user`, where user is your username or `/root` for the root user. A login shell is created when you log in to a machine. However, terminal sessions you create while logged in to a graphical environment (such as GNOME, KDE, and so on), are not login shells. Logging in with a display manager such as GDM or KDM may not read a `.profile` or `.bash_profile` (most don't), but logging in to a remote system with ssh will read the `.profile`. The shell delimits each command or command sequence with a semicolon or a new line. Consider this example: `$ cmd1 ; cmd2`
This is equivalent to these: 
`$ cmd1`
`$ cmd2`

注释从`#`开始，一直到行尾。注释行最常用于描述代码，或者在调试期间禁用一行代码的执行:

```sh
# sample.sh - echoes "hello world" echo "hello world"

```

现在让我们进入本章的基本食谱。

# 怎么做...

`echo`命令是终端打印最简单的命令。

默认情况下，`echo`在每次回显调用结束时添加一个换行符:

```sh
$ echo "Welcome to Bash" Welcome to Bash

```

简单来说，在`echo`命令中使用双引号文本会在终端中打印文本。同样，没有双引号的文本也会给出相同的输出:

```sh
$ echo Welcome to Bash Welcome to Bash

```

完成相同任务的另一种方法是使用单引号:

```sh
$ echo 'text in quotes'

```

这些方法看似相似，但都有特定的目的和副作用。双引号允许 shell 解释字符串中的特殊字符。单引号禁止这种解释。

考虑以下命令:

```sh
$ echo "cannot include exclamation - ! within double quotes"

```

这将返回以下输出:

```sh
bash: !: event not found error

```

如果需要打印特殊字符，如`!`，必须不使用任何引号，使用单引号，或者用反斜杠(`\`)转义特殊字符:

```sh
$ echo Hello world ! 

```

或者，使用以下方法:

```sh
$ echo 'Hello world !'

```

或者，它可以这样使用:

```sh
$ echo "Hello World\!" #Escape character \ prefixed.

```

使用不带引号的`echo`时，我们不能使用分号，因为分号是 Bash shell 中命令之间的分隔符:

```sh
echo hello; hello 

```

从上一行来看，Bash 将`echo hello`作为一个命令，将第二个`hello`作为第二个命令。

变量替换，将在下一个配方中讨论，不会在单引号中起作用。

终端打印的另一个命令是`printf`。它使用与 C 库`printf`函数相同的参数。考虑这个例子:

```sh
$ printf "Hello world"

```

`printf`命令接受由空格分隔的引用文本或参数。它支持格式化字符串。格式字符串指定字符串宽度、左对齐或右对齐等。默认情况下，`printf`不追加换行符。我们必须在需要时指定一个换行符，如以下脚本所示:

```sh
#!/bin/bash #Filename: printf.sh printf  "%-5s %-10s %-4s\n" No Name  Mark printf  "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456 printf  "%-5s %-10s %-4.2f\n" 2 James 90.9989 printf  "%-5s %-10s %-4.2f\n" 3 Jeff 77.564

```

我们将收到以下格式化输出:

```sh
No    Name       Mark 1     Sarath     80.35 2     James      91.00 3     Jeff       77.56

```

# 它是如何工作的...

`%s`、`%c`、`%d`和`%f`字符是格式替换字符，它们定义了以下参数的打印方式。`%-5s`字符串定义了左对齐(`-`代表左对齐)和`5`字符宽度的字符串替换。如果没有指定`-`，字符串将会向右对齐。宽度指定为字符串保留的字符数。对于`Name`，预留宽度为`10`。因此，任何名称都将位于为其保留的 10 个字符的宽度内，该行的其余部分将由空格填充，总共最多 10 个字符。

对于浮点数，我们可以传递额外的参数来舍入小数位数。

对于标记部分，我们将字符串格式化为`%-4.2f`，其中`.2`指定舍入到两位小数。请注意，对于格式字符串的每一行，都会发出一个换行符(`\n`)。

# 还有更多...

在使用`echo`和`printf`的标志时，将标志放在命令中的任何字符串之前，否则 Bash 会将标志视为另一个字符串。

# 在回声中转义换行符

默认情况下，`echo`在其输出文本的末尾追加一个换行符。用`-n`标志禁用换行符。`echo`命令接受双引号字符串中的转义序列作为参数。使用转义序列时，使用`echo`作为`echo -e "string containing escape sequences"`。考虑以下示例:

```sh
echo -e "1\t2\t3" 1  2  3

```

# 打印彩色输出

脚本可以使用转义序列在终端上生成彩色文本。

文本的颜色由颜色代码表示，包括重置= 0、黑色= 30、红色= 31、绿色= 32、黄色= 33、蓝色= 34、洋红色= 35、青色= 36 和白色= 37。

要打印彩色文本，请输入以下命令:

```sh
echo -e "\e[1;31m This is red text \e[0m"

```

这里，`\e[1;31m`是将颜色设置为红色的转义字符串，`\e[0m`将颜色重置回来。将`31`替换为所需的颜色代码。

对于彩色背景，重置= 0、黑色= 40、红色= 41、绿色= 42、黄色= 43、蓝色= 44、洋红色= 45、青色= 46 和白色=47 是常用的颜色代码。

要打印彩色背景，请输入以下命令:

```sh
echo -e "\e[1;42m Green Background \e[0m"

```

这些例子涵盖了转义序列的一个子集。可以通过`man console_codes`查看文档。

# 使用变量和环境变量

所有编程语言都使用变量来保存数据，以备以后使用或修改。与编译语言不同，大多数脚本语言在创建变量之前不需要类型声明。类型由用法决定。变量值通过在变量名前面加一个美元符号来访问。Shell定义了几个变量，用于配置和可用打印机、搜索路径等信息。这些被称为**环境变量**。

# 准备好了

变量被命名为字母、数字和下划线的序列，没有空格。常见的约定是环境变量使用大写，脚本中使用的变量使用小写。

所有应用和脚本都可以访问环境变量。要查看当前 shell 中定义的所有环境变量，请发出`env`或`printenv`命令:

```sh
$> env 
PWD=/home/clif/ShellCookBook 
HOME=/home/clif 
SHELL=/bin/bash 
# ... And many more lines

```

要查看其他进程的环境，请使用以下命令:

```sh
cat /proc/$PID/environ

```

用进程的进程标识设置`PID`(`PID`为整数值)。

假设一个名为`gedit`的应用正在运行。我们通过`pgrep`命令获取`gedit`的进程标识:

```sh
$ pgrep gedit 12501

```

我们通过执行以下命令来查看与流程相关的环境变量:

```sh
$ cat /proc/12501/environ GDM_KEYBOARD_LAYOUT=usGNOME_KEYRING_PID=1560USER=slynuxHOME=/home/slynux

```

Note that the previous output has many lines stripped for convenience. The actual output contains more variables.
The `/proc/PID/environ` special file contains a list of environment variables and their values. Each variable is represented as a name=value pair, separated by a null character (`\0`). This is not easily human readable.

要制作人性化的报告，将`cat`命令的输出输送到`tr`，用`\n`代替`\0`字符:

```sh
$ cat /proc/12501/environ  | tr '\0' '\n'

```

# 怎么做...

使用等号运算符为变量赋值:

```sh
varName=value

```

变量的名称是`varName`，`value`是要分配给它的值。如果`value`不包含任何空格字符(如空格)，则不需要用引号括起来，否则必须用单引号或双引号括起来。

Note that `var = value` and `var=value` are different. It is a usual mistake to write `var = value` instead of `var=value`. An equal sign without spaces is an assignment operation, whereas using spaces creates an equality test.

通过在变量名前加一个美元符号(`$`)来访问变量的内容。

```sh
var="value" #Assign "value" to var echo $var

```

你也可以这样使用它:

```sh
echo ${var}

```

将显示以下输出:

```sh
value

```

双引号内的变量值可以和`printf`、`echo`以及其他 shell 命令一起使用:

```sh
#!/bin/bash #Filename :variables.sh fruit=apple count=5 echo "We have $count ${fruit}(s)"

```

输出如下:

```sh
We have 5 apple(s)

```

因为 shell 用一个空格来划字，我们需要加花括号让 shell 知道变量名是`fruit`，而不是`fruit(s)`。

环境变量继承自父进程。例如，`HTTP_PROXY`是一个环境变量，它定义了用于互联网连接的代理服务器。

通常设置如下:

```sh
HTTP_PROXY=192.168.1.23:3128 export HTTP_PROXY

```

`export`命令声明一个或多个将被子任务继承的变量。导出变量后，从当前 shell 脚本中执行的任何应用都会收到该变量。shell 创建并使用了许多标准环境变量，我们可以导出自己的变量。

例如，`PATH`变量列出了文件夹，shell 将在其中搜索应用。典型的`PATH`变量将包含以下内容:

```sh
$ echo $PATH 
/home/slynux/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games

```

目录路径由`:`字符分隔。通常，`$PATH`在`/etc/environment`、`/etc/profile`或`~/.bashrc`中定义。

要向`PATH`环境添加新路径，请使用以下命令:

```sh
export PATH="$PATH:/home/user/bin"

```

或者，使用以下命令:

```sh
$ PATH="$PATH:/home/user/bin" 
$ export PATH 
$ echo $PATH 
/home/slynux/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/user/bin

```

这里我们在`PATH`中增加了`/home/user/bin`。

一些众所周知的环境变量是`HOME`、`PWD`、`USER`、`UID`和`SHELL`。

使用单引号时，变量不会展开，而是按原样显示。这意味着，`$ echo '$var'`将显示`$var`。

反之，`$ echo "$var"`将显示`$var`变量的值(如果已定义)，或者不显示(如果未定义)。

# 还有更多...

Shell有更多的内置功能。这里还有一些:

# 寻找字符串的长度

使用以下命令获取变量值的长度:

```sh
length=${#var}

```

考虑这个例子:

```sh
$ var=12345678901234567890$ echo ${#var} 20

```

`length`参数是字符串中的字符数。

# 识别当前Shell

要识别当前正在使用的Shell，使用`SHELL environment`变量。

```sh
echo $SHELL

```

或者，使用以下命令:

```sh
echo $0

```

考虑这个例子:

```sh
$ echo $SHELL /bin/bash

```

同样，通过执行`echo $0`命令，我们将获得相同的输出:

```sh
$ echo $0 /bin/bash

```

# 正在检查超级用户

`UID`环境变量保存用户标识。使用此值检查当前脚本是作为根用户还是常规用户运行。考虑这个例子:

```sh
If [ $UID -ne 0 ]; then 
  echo Non root user. Please run as root. 
else 
  echo Root user 
fi

```

注意`[`实际上是一个命令，必须用空格与字符串的其余部分隔开。我们也可以将前面的脚本编写如下:

```sh
if test $UID -ne 0:1 
  then 
    echo Non root user. Please run as root 
  else 
    echo Root User 
fi

```

根用户的`UID`值为`0`。

# 修改 Bash 提示字符串(用户名@主机名:~$)

当我们打开一个终端或者运行一个 shell 时，会看到`user@hostname: /home/$`这样的提示。不同的 GNU/Linux 发行版有不同的提示和不同的颜色。`PS1`环境变量定义主要提示。默认提示由`~/.bashrc`文件中的一行定义。

*   查看用于设置`PS1`变量的线:

```sh
        $ cat ~/.bashrc | grep PS1 
        PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

```

*   要修改提示，请输入以下命令:

```sh
        slynux@localhost: ~$ PS1="PROMPT> " # Prompt string changed 
        PROMPT> Type commands here.

```

*   我们可以使用特殊的转义序列来使用彩色文本，如`\e[1;31`(参见本章的*在终端显示输出*配方)。

某些特殊字符扩展到系统参数。例如，`\u`扩展为用户名，`\h`扩展为主机名，`\w`扩展为当前工作目录。

# 附加到环境变量的函数

环境变量通常用于存储搜索可执行文件、库等的路径列表。例如`$PATH`和`$LD_LIBRARY_PATH`，它们通常类似于:

```sh
PATH=/usr/bin;/bin 
LD_LIBRARY_PATH=/usr/lib;/lib

```

这意味着每当 shell 必须执行一个应用(二进制或脚本)时，它将首先查找`/usr/bin`，然后搜索`/bin`。

当从源代码构建和安装程序时，我们经常需要为新的可执行文件和库添加自定义路径。例如，我们可以在`/opt/myapp`中安装`myapp`，二进制文件在`/opt/myapp/bin`文件夹中，库在`/opt/myapp/lib`中。

# 怎么做...

此示例显示如何向环境变量的开头添加新路径。第一个示例展示了如何使用到目前为止已经介绍过的内容来实现这一点，第二个示例演示了创建一个函数来简化对变量的修改。本章稍后将介绍函数。

```sh
export PATH=/opt/myapp/bin:$PATH 
export LD_LIBRARY_PATH=/opt/myapp/lib;$LD_LIBRARY_PATH

```

`PATH`和`LD_LIBRARY_PATH`变量现在看起来应该是这样的:

```sh
PATH=/opt/myapp/bin:/usr/bin:/bin 
LD_LIBRARY_PATH=/opt/myapp/lib:/usr/lib;/lib

```

我们可以通过在`.bashrc`文件中定义一个前置函数来使添加新路径变得更容易。

```sh
prepend() { [ -d "$2" ] && eval $1=\"$2':'\$$1\" && export $1; }

```

这可以通过以下方式使用:

```sh
prepend PATH /opt/myapp/bin 
prepend LD_LIBRARY_PATH /opt/myapp/lib

```

# 它是如何工作的...

`prepend()`函数首先确认函数第二个参数指定的目录存在。如果是这样，`eval`表达式设置变量，第一个参数中的名称等于第二个参数字符串，后跟`:`(路径分隔符)，然后是变量的原始值。

如果我们尝试前置时变量为空，那么末尾会有一个尾随的`:`。要解决此问题，请将函数修改为:

```sh
prepend() { [ -d "$2" ] && eval $1=\"$2\$\{$1:+':'\$$1\}\" && export $1 ; }

```

In this form of the function, we introduce a shell parameter expansion of the form:
`${parameter:+expression}`
This expands to expression if parameter is set and is not null.
With this change, we take care to try to append `:` and the old value if, and only if, the old value existed when trying to prepend.

# 带壳的数学

Bash shell 使用`let`、`(( ))`和`[]`命令执行基本的算术运算。`expr`和`bc`实用程序用于执行高级操作。

# 怎么做...

1.  数值赋给变量的方式与字符串赋给变量的方式相同。该值将被访问它的方法视为一个数字:

```sh
 #!/bin/bash no1=4; no2=5;

```

2.  `let`命令用于直接执行基本操作。在`let`命令中，我们使用不带`$`前缀的变量名。考虑这个例子:

```sh
 let result=no1+no2 echo $result 

```

`let`命令的其他用途如下:

*   将此用于增量:

```sh
 $ let no1++

```

*   对于减量，请使用以下内容:

```sh
 $ let no1--

```

*   用这些来对付人手不足的人:

```sh
 let no+=6 let no-=6

```

这些分别等于`let no=no+6`和`let no=no-6`。

*   替代方法如下:

`[]`操作符的使用方式与`let`命令相同:

```sh
 result=$[ no1 + no2 ]

```

在[]运算符中使用$前缀是合法的；考虑这个例子:

```sh
 result=$[ $no1 + 5 ]

```

也可以使用`(( ))`运算符。在`(( ))`操作符中用`$`作为变量名的前缀:

```sh
 result=$(( no1 + 50 ))

```

`expr`表达式可用于基本操作:

```sh
 result=`expr 3 + 4` result=$(expr $no1 + 5)

```

前面的方法不支持浮点数，
，只对整数进行运算。

3.  `bc`应用，精密计算器，是数学运算的高级工具。它有多种选择。我们可以执行浮点运算并使用高级功能:

```sh
 echo "4 * 0.56" | bc 2.24 no=54; result=`echo "$no * 1.5" | bc` echo $result 81.0

```

`bc`应用接受前缀来控制操作。这些用分号隔开。

*   **小数位数用 bc** 表示:在下面的例子中，`scale=2`参数将小数位数设置为`2`。因此，`bc`的输出将包含一个有两位小数的数字:

```sh
 echo "scale=2;22/7" | bc 3.14

```

*   **用 bc** 进行基数转换:我们可以从一个基数系统转换到另一个基数系统。此代码将数字从十进制转换为二进制，从二进制转换为十进制:

```sh
 #!/bin/bash Desc: Number conversion no=100 echo "obase=2;$no" | bc 1100100 no=1100100 echo "obase=10;ibase=2;$no" | bc 100

```

*   以下示例演示了如何计算平方和平方根:

```sh
 echo "sqrt(100)" | bc #Square root echo "10^10" | bc #Square

```

# 玩文件描述符和重定向

文件描述符是与输入和输出流相关联的整数。最著名的文件描述符是`stdin`、`stdout`和`stderr`。一个流的内容可以重定向到另一个流。这个方法展示了如何用文件描述符操纵和重定向的例子。

# 准备好

Shell 脚本经常使用标准输入(`stdin`)、标准输出(`stdout`)和标准错误(`stderr`)。脚本可以将输出重定向到带有大于号的文件。命令生成的文本可能是正常输出或错误消息。默认情况下，正常输出(`stdout`)和错误消息(`stderr`)都会发送到显示屏。这两个流可以通过为每个流指定特定的描述符来分开。

文件描述符是与打开的文件或数据流相关联的整数。文件描述符 0、1 和 2 被保留，如下所示:

*   0: `stdin`
*   1: `stdout`
*   2: `stderr`

# 怎么做...

1.  使用大于号将文本追加到文件中:

```sh
 $ echo "This is a sample text 1" > temp.txt

```

这将回显的文本存储在`temp.txt`中。如果`temp.txt`已经存在，单个大于号将删除之前的任何内容。

2.  使用双大于将文本追加到文件中:

```sh
 $ echo "This is sample text 2" >> temp.txt

```

3.  使用`cat`查看文件内容:

```sh
 $ cat temp.txt This is sample text 1 This is sample text 2

```

接下来的食谱演示了重定向`stderr`。当命令产生错误消息时，消息被打印到`stderr`流。考虑以下示例:

```sh
$ ls + ls: cannot access +: No such file or directory

```

这里`+`是一个无效的参数，因此返回一个错误。

Successful and unsuccessful commands
When a command exits because of an error, it returns a nonzero exit status. The command returns zero when it terminates after successful completion. The return status is available in the special variable `$?` (run echo `$?` immediately after the command execution statement to print the exit status).

以下命令将`stderr`文本打印到屏幕上而不是文件中(因为没有`stdout`输出，`out.txt`将为空):

```sh
$ ls + > out.txt ls: cannot access +: No such file or directory 

```

在下面的命令中，我们使用`2>`(两个大于)将`stderr`重定向到`out.txt`:

```sh
$ ls + 2> out.txt # works

```

您可以将`stderr`重定向到一个文件，将`stdout`重定向到另一个文件。

```sh
$ cmd 2>stderr.txt 1>stdout.txt

```

通过使用以下首选方法将`stderr`转换为`stdout`，也可以将`stderr`和`stdout`重定向到单个文件:

```sh
$ cmd 2>&1 allOutput.txt

```

这甚至可以通过另一种方法来实现:

```sh
$ cmd &> output.txt 

```

如果您不想看到或保存任何错误消息，您可以将 stderr 输出重定向到`/dev/null`，这将完全删除它。例如，假设我们有三个文件`a1`、`a2`和`a3`。但是，`a1`没有用户的读写执行权限。要打印以字母`a`开头的所有文件的内容，我们使用`cat`命令。按照以下步骤设置测试文件:

```sh
$ echo A1 > a1 $ echo A2 > a2 $ echo A3 > a3 $ chmod 000 a1  #Deny all permissions

```

使用通配符(`a*`)显示文件的内容将会为`a1`文件生成一条错误消息，因为该文件没有正确的读取权限:

```sh
$ cat a* cat: a1: Permission denied A2 A3

```

这里，`cat: a1: Permission denied`属于`stderr`数据。我们可以将`stderr`数据重定向到文件中，同时将`stdout`发送到终端。

```sh
$ cat a* 2> err.txt #stderr is redirected to err.txt A2 A3 $ cat err.txt cat: a1: Permission denied

```

有些命令会生成我们想要处理的输出，并保存起来以备将来参考或进行其他处理。`stdout`流是一个单一的流，我们可以将其重定向到一个文件或管道到另一个程序。你可能认为我们没有办法既吃蛋糕又吃它。

但是，有一种方法可以将数据重定向到文件，同时将重定向数据的副本作为`stdin`提供给管道中的下一个命令。`tee`命令读取`stdin`并将输入数据重定向至`stdout`和一个或多个文件。

```sh
command | tee FILE1 FILE2 | otherCommand

```

在下面的代码中，`stdin`数据由`tee`命令接收。它将`stdout`的一个副本写入`out.txt`文件，并将另一个副本作为`stdin`发送给下一个命令。`cat -n`命令为从`stdin`接收的每一行输入一个行号，并将其写入`stdout`:

```sh
$ cat a* | tee out.txt | cat -n cat: a1: Permission denied
 1 A2 2 A3

```

使用`cat`检查`out.txt`的内容:

```sh
$ cat out.txt A2 A3

```

Observe that `cat: a1: Permission denied` does not appear, because it was sent to `stderr`. The `tee` command reads only from `stdin`.

默认情况下，`tee`命令覆盖文件。包含`-a`选项将强制其追加新数据。

```sh
$ cat a* | tee -a out.txt | cat -n

```

带有参数的命令遵循以下格式:`command FILE1 FILE2 ...`或简称为`command FILE`。

要向`stdout`发送两份输入，请使用`-`作为文件名参数:

```sh
$ cmd1 | cmd2 | cmd -

```

考虑这个例子:

```sh
$ echo who is this | tee - who is this who is this

```

或者，我们可以使用`/dev/stdin`作为输出文件名来使用`stdin`。
同样，标准误差使用`/dev/stderr`，标准输出使用`/dev/stdout`。这些是对应于`stdin`、`stderr`和`stdout`的特殊设备文件。

# 它是如何工作的...

重定向操作符(`>`和`>>`)将输出发送到文件，而不是终端。`>`和`>>`操作员的行为略有不同。两者都将输出重定向到文件，但是单个大于符号(`>`)清空文件，然后写入文件，而双个大于符号(`>>`)将输出添加到现有文件的末尾。

默认情况下，重定向在标准输出上运行。要显式获取特定的文件描述符，您必须在操作符前面加上描述符编号。

`>`运算符相当于`1>`，同样适用于`>>`(相当于`1>>`)。

处理错误时，`stderr`输出转储到`/dev/null`文件。`./dev/null`文件是一个特殊的设备文件，文件接收到的任何数据都会被丢弃。空设备通常被称为**黑洞**，因为进入其中的所有数据都将永远丢失。

# 还有更多...

从`stdin`读取输入的命令可以多种方式接收数据。可以使用`cat`和管道指定我们自己的文件描述符。考虑这个例子:

```sh
$ cat file | cmd $ cmd1 | cmd2

```

# 从文件重定向到命令

我们可以将文件中的数据读取为带有小于符号(`<`)的`stdin`:

```sh
$ cmd < file

```

# 从包含在脚本中的文本块重定向

文本可以从脚本重定向到文件中。要在自动生成的文件顶部添加警告，请使用以下代码:

```sh
#!/bin/bash 
cat<<EOF>log.txt 
This is a generated file. Do not edit. Changes will be overwritten. 
EOF

```

出现在`cat <<EOF >log.txt`和下一条`EOF`线之间的线将显示为`stdin`数据。`log.txt`的内容如下所示:

```sh
$ cat log.txt 
This is a generated file. Do not edit. Changes will be overwritten. 

```

# 自定义文件描述符

文件描述符是访问文件的抽象指示符。每个文件访问都与一个称为文件描述符的特殊数字相关联。0、1 和 2 是为`stdin`、`stdout`和`stderr`保留的描述符编号。

`exec`命令可以创建新的文件描述符。如果您熟悉其他编程语言中的文件访问，您可能会熟悉打开文件的模式。通常使用这三种模式:

*   读取模式
*   用追加模式写入
*   以截断模式写入

`<`操作员从文件中读取到`stdin`。`>`操作符通过截断写入文件(数据在截断内容后写入目标文件)。`>>`操作符追加写入文件(数据追加到已有文件内容，目标文件内容不会丢失)。文件描述符是用三种模式之一创建的。

创建用于读取文件的文件描述符:

```sh
$ exec 3<input.txt # open for reading with descriptor number 3

```

我们可以通过以下方式使用它:

```sh
$ echo this is a test line > input.txt $ exec 3<input.txt

```

现在你可以使用文件描述符`3`和命令。例如，我们将使用`cat<&3`:

```sh
$ cat<&3 this is a test line

```

如果需要二次读取，我们不能重用文件描述符`3`。我们必须用`exec`创建一个新的文件描述符(也许是 4)，以便从另一个文件中读取或者从第一个文件中重新读取。

创建用于写入的文件描述符(截断模式):

```sh
$ exec 4>output.txt # open for writing

```

考虑这个例子:

```sh
$ exec 4>output.txt $ echo newline >&4 $ cat output.txt newline

```

现在创建一个用于写入的文件描述符(追加模式):

```sh
$ exec 5>>input.txt

```

考虑以下示例:

```sh
$ exec 5>>input.txt $ echo appended line >&5 $ cat input.txt newline appended line

```

# 数组和关联数组

数组允许脚本使用索引将数据集合存储为单独的实体。Bash 既支持使用整数作为数组索引的常规数组，也支持使用字符串作为数组索引的关联数组。当数据以数字方式组织时，应该使用常规数组，例如，一组连续的迭代。当数据由字符串(例如主机名)组织时，可以使用关联数组。在这个食谱中，我们将看到如何使用这两者。

# 准备好

要使用关联数组，您必须拥有 Bash 版本 4 或更高版本。

# 怎么做...

可以使用不同的技术定义数组:

1.  使用单行值列表定义数组:

```sh
 array_var=(test1 test2 test3 test4) #Values will be stored in consecutive locations starting 
        from index 0.

```

或者，将数组定义为一组索引值对:

```sh
 array_var[0]="test1" array_var[1]="test2" array_var[2]="test3" array_var[3]="test4" array_var[4]="test5" array_var[5]="test6"

```

2.  使用以下命令打印给定索引处的数组内容:

```sh
 echo ${array_var[0]} test1 index=5 echo ${array_var[$index]} test6

```

3.  使用以下命令将数组中的所有值打印为列表:

```sh
 $ echo ${array_var[*]} test1 test2 test3 test4 test5 test6

```

或者，您可以使用以下命令:

```sh
 $ echo ${array_var[@]} test1 test2 test3 test4 test5 test6

```

4.  打印数组的长度(数组中元素的数量):

```sh
 $ echo ${#array_var[*]}6

```

# 还有更多...

关联数组已从 4.0 版引入 Bash。当索引是字符串(站点名称、用户名、非顺序数字等)时，关联数组比数字索引数组更容易处理。

# 定义关联数组

关联数组可以使用任何文本数据作为数组索引。需要声明语句将变量名定义为关联数组:

```sh
$ declare -A ass_array

```

声明后，使用以下两种方法之一将元素添加到关联数组中:

*   内联索引值列表方法:

```sh
 $ ass_array=([index1]=val1 [index2]=val2)

```

*   单独的索引值分配:

```sh
 $ ass_array[index1]=val1 $ ass_array'index2]=val2

```

例如，考虑水果的价格分配，使用关联数组:

```sh
$ declare -A fruits_value $ fruits_value=([apple]='100 dollars' [orange]='150 dollars')

```

显示数组的内容:

```sh
$ echo "Apple costs ${fruits_value[apple]}" Apple costs 100 dollars

```

# 数组索引列表

数组有索引来索引每个元素。普通数组和关联数组在索引类型方面有所不同。

获取数组中的索引列表。

```sh
$ echo ${!array_var[*]}

```

或者，我们也可以使用以下命令:

```sh
$ echo ${!array_var[@]}

```

在前面的`fruits_value`数组示例中，考虑以下命令:

```sh
$ echo ${!fruits_value[*]} orange apple

```

这也适用于普通阵列。

# 访问别名

别名是代替输入长命令序列的快捷方式。在本食谱中，我们将看到如何使用`alias`命令创建别名。

# 怎么做...

以下是您可以对别名执行的操作:

1.  创建别名:

```sh
 $ alias new_command='command sequence'

```

本示例为`apt-get install`命令创建一个快捷方式:

```sh
 $ alias install='sudo apt-get install'

```

一旦定义了别名，我们就可以输入`install`而不是`sudo apt-get install`。

2.  `alias`命令是暂时的:别名存在，直到我们关闭当前终端。要使别名对所有 shells 可用，请将此语句添加到`~/.bashrc`文件中。`~/.bashrc`中的命令总是在新的交互式 shell 进程产生时执行:

```sh
 $ echo 'alias cmd="command seq"' >> ~/.bashrc

```

3.  要删除别名，请从`~/.bashrc`中删除其条目(如果有)或使用`unalias`命令。或者，`alias example=`应该取消别名`example`的设置。
4.  本示例为`rm`创建一个别名，该别名将删除原始文件并在备份目录中保留一份副本:

```sh
 alias rm='cp $@ ~/backup && rm $@'

```

When you create an alias, if the item being aliased already exists, it will be replaced by this newly aliased command for that user.

# 还有更多...

以特权用户身份运行时，别名可能会破坏安全。为了避免危及您的系统，您应该退出命令。

# 转义别名

鉴于创建别名来伪装成本机命令是多么容易，您不应该以特权用户的身份运行别名命令。我们可以通过转义想要运行的命令来忽略当前定义的任何别名。考虑这个例子:

```sh
$ \command

```

`\`字符会转义该命令，运行该命令时不会有任何别名更改。在不受信任的环境中运行特权命令时，通过在命令前面加上`\`来忽略别名始终是一种很好的安全做法。攻击者可能用他/她自己的自定义命令来混淆特权命令，以窃取用户向该命令提供的关键信息。

# 列出别名

`alias`命令列出了当前定义的别名:

```sh
$ aliasalias lc='ls -color=auto' alias ll='ls -l' alias vi='vim'

```

# 获取关于终端的信息

在编写命令行 shell 脚本时，我们经常需要操作关于当前终端的信息，如列数、行数、光标位置、屏蔽的密码字段等。该方法有助于收集和操作终端设置。

# 准备好

`tput`和`stty`命令是用于终端操作的实用程序。

# 怎么做...

以下是`tput`命令的一些功能:

*   返回终端中的列数和行数:

```sh
 tput cols tput lines

```

*   返回当前终端名称:

```sh
 tput longname

```

*   将光标移动到 100，100 位置:

```sh
 tput cup 100 100

```

*   设置终端背景颜色:

```sh
 tput setb n

```

`n`的值可以是 0 到 7 范围内的值

*   设置终端前景色:

```sh
 tput setf n

```

`n`的值可以是 0 到 7 范围内的值

Some commands including the common `color ls` may reset the foreground and background color.

*   使用以下命令将文本加粗:

```sh
 tput bold

```

*   执行开始和结束下划线:

```sh
 tput smul tput rmul

```

*   要从光标处删除到行尾，请使用以下命令:

```sh
 tput ed

```

*   输入密码时，脚本不应显示字符。以下示例演示了使用`stty`命令禁用字符回声:

```sh
 #!/bin/sh #Filename: password.sh echo -e "Enter password: " # disable echo before reading password stty -echo read password # re-enable echo stty echo echo echo Password read.

```

The `-echo` option in the preceding command disables the output to the terminal, whereas `echo` enables output.

# 获取和设置日期和延迟

时间延迟用于在程序执行期间等待设定的时间量(例如 1 秒)，或者每隔几秒钟(或每隔几个月)监控一个任务。使用时间和日期需要了解时间和日期是如何表示和操作的。这个食谱将告诉你如何处理日期和时间延迟。

# 准备好

日期可以多种格式打印。在内部，日期存储为从 1970-01-01 的 00:00:00 开始的整数秒。这被称为**纪元**或 **Unix 时间**。

可以从命令行设置系统的日期。接下来的食谱演示了如何阅读和设置日期。

# 怎么做...

可以读取不同格式的日期，也可以设置日期。

1.  阅读日期:

```sh
 $ date Thu May 20 23:09:04 IST 2010

```

2.  打印纪元时间:

```sh
 $ date +%s 1290047248

```

date 命令可以将许多格式化的日期字符串转换为纪元时间。这允许您使用多种日期格式的日期作为输入。通常，如果您是从系统日志或任何标准应用生成的输出中收集日期，您不需要担心您使用的日期字符串格式。
将日期字符串转换为纪元:

```sh
 $ date --date "Wed mar 15 08:09:16 EDT 2017" +%s 1489579718

```

`--date`选项定义一个日期字符串作为输入。我们可以使用任何日期格式选项来打印输出。date 命令可用于查找给定日期字符串的一周中的某一天:

```sh
 $ date --date "Jan 20 2001" +%A Saturday

```

日期格式字符串列在*中提到的表格中...*段

3.  使用前缀为`+`的格式字符串组合作为`date`命令的参数，以您选择的格式打印日期。考虑这个例子:

```sh
 $ date "+%d %B %Y" 20 May 2010

```

4.  设置日期和时间:

```sh
 # date -s "Formatted date string" # date -s "21 June 2009 11:01:22"

```

On a system connected to a network, you'll want to use `ntpdate` to set the date and time:
`/usr/sbin/ntpdate -s time-b.nist.gov`

5.  优化代码的规则是先度量。date 命令可用于计算一组命令执行所需的时间:

```sh
 #!/bin/bash #Filename: time_take.sh start=$(date +%s) commands; statements; end=$(date +%s) difference=$(( end - start)) echo Time taken to execute commands is $difference seconds.

```

The date command's minimum resolution is one second. A better method for timing commands is the `time` command:
`time commandOrScriptName`.

# 它是如何工作的...

Unix 纪元被定义为自 1970 年 1 月 1 日午夜前**协调世界时** ( **世界协调时**)以来经过的秒数，不包括闰秒。当您需要计算两个日期或时间之间的差异时，纪元时间非常有用。将两个日期字符串转换为纪元，并取纪元值之间的差值。本食谱计算两个日期之间的秒数:

```sh
secs1=`date -d "Jan 2 1970" 
secs2=`date -d "Jan 3 1970" 
echo "There are `expr $secs2 - $secs1` seconds between Jan 2 and Jan 3" 
There are 86400 seconds between Jan 2 and Jan 3 

```

显示自 1970 年 1 月 1 日午夜以来的时间(以秒为单位)，不容易被人类读取。日期命令支持人类可读格式的输出。

下表列出了日期命令支持的格式选项。

| **日期组件** | **格式** |
| --- | --- |
| 工作日 | `%a`(例如，Sat)`%A`(例如周六) |
| 月 | `%b`(例如，11 月)`%B`(例如 11 月) |
| 一天 | `%d`(例如 31) |
| 格式日期(年/月/日) | `%D`(例如 10/18/10) |
| 年 | `%y`(例如，10)`%Y`(例如 2010 年) |
| 小时 | `%I`或`%H`(例如 08) |
| 分钟 | `%M`(例如 33) |
| 第二 | `%S`(例如，10) |
| 纳米秒 | `%N`(例如，695208515) |
| Epoch Unix 时间(秒) | `%s`(例如，1290049486) |

# 还有更多...

在编写循环执行的监控脚本时，生成时间间隔至关重要。以下示例显示了如何生成时间延迟。

# 在脚本中产生延迟

休眠命令将延迟在`seconds`中给出的脚本执行时间。以下脚本使用`tput`和`sleep`从 0 到 40 秒计数:

```sh
#!/bin/bash 
#Filename: sleep.sh 
echo Count: 
tput sc 

# Loop for 40 seconds 
for count in `seq 0 40` 
do 
  tput rc 
  tput ed 
  echo -n $count 
  sleep 1 
done

```

在前面的例子中，一个变量遍历由`seq`命令生成的数字列表。我们使用`tput sc`来存储光标位置。在每次循环执行时，我们通过使用`tput rc`恢复光标位置，然后使用`tputs ed`清除到行尾，在终端中写入新的计数。清除该行后，脚本将回显新值。sleep 命令会导致脚本在循环的每次迭代之间延迟 1 秒。

# 调试脚本

调试通常比编写代码花费更长的时间。每种编程语言都应该实现的一个特性是在发生意外时生成跟踪信息。可以读取调试信息来理解是什么导致程序以一种意想不到的方式运行。Bash 提供了每个开发人员都应该知道的调试选项。这个食谱展示了如何使用这些选项。

# 怎么做...

我们既可以使用 Bash 内置的调试工具，也可以以易于调试的方式编写脚本；以下是如何:

1.  添加`-x`选项以启用Shell脚本的调试跟踪。

```sh
 $ bash -x script.sh

```

运行带有`-x`标志的脚本将打印每个当前状态的源代码行。

You can also use `sh -x script`.

2.  使用`set -x`和`set +x`只调试部分脚本。考虑这个例子:

```sh
        #!/bin/bash 
        #Filename: debug.sh 
        for i in {1..6}; 
        do 
            set -x 
            echo $i 
            set +x 
        done 
        echo "Script executed"

```

在前面的脚本中，`echo $i`的调试信息将仅被打印，因为调试仅限于使用`-x`和`+x`的部分。
该脚本使用`{start..end}`构造从起始值迭代到结束值，而不是前面示例中使用的`seq`命令。这个构造比调用`seq`命令稍快。

3.  上述调试方法由 Bash 内置提供。它们以固定的格式产生调试信息。在许多情况下，我们需要自己格式的调试信息。我们可以定义一个 _DEBUG 环境变量来启用和禁用调试，并以我们自己的调试风格生成消息。

请看下面的示例代码:

```sh
        #!/bin/bash 
        function DEBUG() 
        { 
            [ "$_DEBUG" == "on" ] && $@ || : 
        } 
        for i in {1..10} 
        do 
          DEBUG echo "I is $i" 
        done

```

在调试设置为“开”的情况下运行前面的脚本:

```sh
 $ _DEBUG=on ./script.sh

```

我们在每个要打印调试信息的语句前加前缀`DEBUG`。如果`_DEBUG=on`没有传递给脚本，调试信息不会被打印。在 Bash 中，命令`:`告诉 shell 什么也不要做。

# 它是如何工作的...

`-x`标志在脚本执行时输出每一行。然而，我们可能只需要观察部分源线。Bash 使用`set builtin`在脚本中启用和禁用调试打印:

*   `set -x`:执行时显示参数和命令
*   `set +x`:这将禁用调试
*   `set -v`:读取时显示输入
*   `set +v`:这将禁用打印输入

# 还有更多...

我们还可以使用其他方便的方法来调试脚本。我们可以用一种更复杂的方式来调试脚本。

# Shebang hack

可以将 shebang 从`#!/bin/bash`更改为`#!/bin/bash -xv`以启用调试，而无需任何附加标志(`-xv`标志本身)。

当每行以`+`开头时，很难在默认输出中跟踪执行流程。将 PS4 环境变量设置为`'$LINENO:'`以显示实际行号:

```sh
PS4='$LINENO: ' 

```

调试输出可能很长。使用`-x`或设置`-x`时，调试输出发送至`stderr`。可以使用以下命令将其重定向到文件:

```sh
sh -x testScript.sh 2> debugout.txt

```

Bash 4.0 和更高版本支持使用编号流调试输出:

```sh
exec 6> /tmp/debugout.txt 
BASH_XTRACEFD=6

```

# 函数和参数

函数和别名看起来很相似，但行为略有不同。最大的区别是函数参数可以在函数体中的任何地方使用，而别名只是将参数附加到命令的末尾。

# 怎么做...

函数由函数命令、函数名、开/闭括号和用花括号括起来的函数体定义:

1.  函数的定义如下:

```sh
        function fname() 
        { 
            statements; 
        }  

```

或者，它可以定义为:

```sh
        fname() 
        { 
            statements; 
        } 

```

它甚至可以定义如下(对于简单函数):

```sh
        fname() { statement; }

```

2.  使用函数的名称调用函数:

```sh
 $ fname ; # executes function

```

3.  传递给函数的参数是按位置访问的，`$1`是第一个参数，`$2`是第二个参数，依此类推:

```sh
 fname arg1 arg2 ; # passing args

```

以下是功能`fname`的定义。在`fname`函数中，我们包含了访问函数参数的各种方式。

```sh
        fname() 
        { 
           echo $1, $2; #Accessing arg1 and arg2 
           echo "$@"; # Printing all arguments as list at once 
           echo "$*"; # Similar to $@, but arguments taken as single  
           entity 
           return 0; # Return value 
         }

```

传递给脚本的参数可以通过`$0`(脚本的名称)来访问:

*   **将别名与功能进行比较**
*   这里有一个别名，通过将`ls`输出管道连接到`grep`来显示文件子集。该参数附在命令的末尾，因此`lsg txt`扩展为`ls | grep txt`:

```sh
 $> alias lsg='ls | grep' 
 $> lsg txt 
 file1.txt 
 file2.txt 
 file3.txt 

```

*   如果我们想扩展它来获取`/sbin/ifconfig`中设备的 IP 地址，我们可以尝试以下方法:

```sh
 $> alias wontWork='/sbin/ifconfig | grep' 
 $> wontWork eth0 
 eth0  Link  encap:Ethernet  HWaddr 00:11::22::33::44:55 

```

*   `grep`命令找到的是`eth0`字符串，不是 IP 地址。如果我们使用函数而不是别名，我们可以将参数传递给`ifconfig`，而不是将其附加到`grep`:

```sh
 $> function getIP() { /sbin/ifconfig $1 | grep 'inet ';  } 
 $> getIP eth0 
 inet addr:192.168.1.2 Bcast:192.168.255.255 Mask:255.255.0.0

```

# 还有更多...

让我们探索关于 Bash 函数的更多技巧。

# 递归函数

Bash 中的函数也支持递归(函数可以自己调用)。比如`F() { echo $1; F hello; sleep 1; }`。

叉形炸弹

递归函数是一个调用自身的函数:递归函数必须有一个退出条件，否则它们会不断繁殖，直到系统耗尽资源并崩溃。

该函数:`:(){ :|:& };:`永远生成进程，最终导致拒绝服务攻击。

`&`字符用函数调用后置，将子进程带入后台。这个危险的代码永远分叉处理，被称为分叉炸弹。

您可能会发现很难解释前面的代码。参考维基百科页面[h . t . t . p://e . n . w . I . k . p . d . I . a . o . r . g/w . I . k . I/F . o . r . k _ b . o . m . b](https://en.wikipedia.org/wiki/Fork_bomb)了解更多关于叉弹的细节和解释。
通过在`/etc/security/limits.conf`中定义`nproc`值来限制可以产生的最大进程数，从而防止这种攻击。

该行将所有用户限制为 100 个进程:

`hard nproc 100`

**导出函数**
函数可以使用`export`命令导出，就像环境变量一样。导出将函数的范围扩展到子过程:

```sh
export -f fname $> function getIP() { /sbin/ifconfig $1 | grep 'inet '; } $> echo "getIP eth0" >test.sh $> sh test.sh
 sh: getIP: No such file or directory $> export -f getIP $> sh test.sh
 inet addr: 192.168.1.2 Bcast: 192.168.255.255 Mask:255.255.0.0

```

# 读取命令的返回值(状态)

命令的返回值存储在`$?`变量中。

```sh
cmd; echo $?;

```

返回值称为**退出状态**。该值可用于确定命令是否成功完成。如果命令成功退出，退出状态将为零，否则为非零值。

以下脚本报告命令的成功/失败状态:

```sh
#!/bin/bash 
#Filename: success_test.sh 
# Evaluate the arguments on the command line - ie success_test.sh 'ls | grep txt' 
eval $@ 
if [ $? -eq 0 ]; 
then 
 echo "$CMD executed successfully" 
else 
 echo "$CMD terminated unsuccessfully" 
fi

```

# 将参数传递给命令

大多数应用接受不同格式的参数。假设`-p`和`-v`是可用的选项，`-k N`是另一个带数字的选项。此外，该命令需要文件名作为参数。该应用可以多种方式执行:

*   `$ command -p -v -k 1 file`
*   `$ command -pv -k 1 file`
*   `$ command -vpk 1 file`
*   `$ command file -pvk 1` 

在脚本中，可以通过命令行参数在命令行中的位置来访问它们。第一个参数是`$1`，第二个参数是`$2`，依此类推。
该脚本将显示前三个命令行参数:

```sh
echo $1 $2 $3

```

更常见的是一次遍历一个命令参数。`shift`命令将每个参数向左移动一个空格，让脚本以`$1`的形式访问每个参数。以下代码显示所有命令行值:

```sh
$ cat showArgs.sh
for i in `seq 1 $#`
do
echo $i is $1
shift
done
$ sh showArgs.sh a b c
1 is a
2 is b
3 is c

```

# 从一个命令向另一个命令发送输出

Unix shells 的最佳特性之一是可以轻松地组合许多命令来生成报告。一个命令的输出可以显示为另一个命令的输入，后者将其输出传递给另一个命令，依此类推。这个序列的输出可以分配给一个变量。这个配方说明了如何组合多个命令以及如何读取输出。

# 准备好

输入通常通过`stdin`或参数输入到命令中。输出发送到`stdout`或`stderr`。当我们组合多个命令时，我们通常通过`stdin`提供输入，并向`stdout`生成输出。

在这种情况下，命令被称为**过滤器**。我们使用管道连接每个过滤器，由管道操作员(`|`)进行聚合，如下所示:

```sh
$ cmd1 | cmd2 | cmd3 

```

这里，我们结合了三个命令。`cmd1`输出到`cmd2`，`cmd2`输出到`cmd3`，最终输出(从`cmd3`出来)会显示在监控器上，或者定向到一个文件。

# 怎么做...

管道可以与 subshell 方法一起使用，用于组合多个命令的输出。

1.  让我们从组合两个命令开始:

```sh
 $ ls | cat -n > out.txt

```

`ls`的输出(当前目录的列表)被传递给`cat -n`，而`cat -n`又在通过`stdin`接收的输入前面加上行号。输出被重定向到`out.txt`。

2.  将命令序列的输出分配给变量:

```sh
 cmd_output=$(COMMANDS)

```

这叫做**子壳法**。考虑这个例子:

```sh
 cmd_output=$(ls | cat -n) echo $cmd_output

```

另一种方法叫做**回引号**(有人也称之为**回勾**)也可以用来存储命令输出:

```sh
 cmd_output=`COMMANDS`

```

考虑这个例子:

```sh
 cmd_output=`ls | cat -n`
 echo $cmd_output

```

反引号不同于单引号字符。是键盘上 *~* 按钮上的字符。

# 还有更多...

命令分组有多种方式。

# 用子壳产生一个单独的过程

子Shell是独立的进程。使用`( )`运算符定义子壳:

*   `pwd`命令打印工作目录的路径
*   `cd`命令将当前目录更改为给定的目录路径:

```sh
        $> pwd 
        / 
        $> (cd /bin; ls) 
        awk bash cat... 
        $> pwd 
        /

```

在子 shell 中执行命令时，当前 shell 中不会发生任何更改；更改仅限于子Shell。例如，当使用`cd`命令更改子Shell中的当前目录时，目录更改不会反映在主Shell环境中。

# 子壳引用以保留间距和换行符

假设我们使用 subshell 或 back quotes 方法将命令的输出分配给一个变量，我们必须使用双引号来保留间距和换行符(`\n`)。考虑这个例子:

```sh
$ cat text.txt 1 2 3 $ out=$(cat text.txt) $ echo $out 1 2 3 # Lost \n spacing in 1,2,3 $ out="$(cat text.txt)" $ echo $out 1 2 3

```

# 不按回车键读取 n 个字符

bash 命令`read`从键盘或标准输入输入文本。我们可以使用`read`交互获取用户输入，但是`read`的功能更多。任何编程语言中的大多数输入库都从键盘读取输入，并在按下 return 键时终止字符串。在某些情况下，无法按下 return 键，字符串终止是根据接收到的字符数(可能是单个字符)来完成的。例如，在互动游戏中，当按下 *+* 时，球向上移动。按下 *+* 再按下*返回*确认 *+* 按压无效。

该配方使用`read`命令完成该任务，无需按*返回*。

# 怎么做...

您可以使用`read`命令的各种选项获得不同的结果，如下步骤所示:

1.  以下语句将从输入到`variable_name`变量中读取 *n* 字符:

```sh
 read -n number_of_chars variable_name

```

考虑这个例子:

```sh
 $ read -n 2 var $ echo $var

```

2.  在非回声模式下读取密码:

```sh
 read -s var

```

3.  使用以下命令显示带有`read`的信息:

```sh
 read -p "Enter input:"  var

```

4.  超时后读取输入:

```sh
 read -t timeout var

```

考虑以下示例:

```sh
 $ read -t 2 var # Read the string that is typed within 2 seconds into
        variable var.

```

5.  使用分隔符结束输入行:

```sh
 read -d delim_char var

```

考虑这个例子:

```sh
 $ read -d ":" var hello:#var is set to hello

```

# 运行命令直到成功

有时一个命令只有在满足某些条件时才能成功。例如，您只能在文件创建后下载文件。在这种情况下，您可能希望重复运行一个命令，直到它成功为止。

# 怎么做...

按照以下方式定义函数:

```sh
repeat() 
{ 
  while true 
  do 
    $@ && return 
  done 
}

```

或者，为了方便使用，将此添加到 shell 的`rc`文件中:

```sh
repeat() { while true; do $@ && return; done }

```

# 它是如何工作的...

这个重复函数有一个无限的`while`循环，它试图运行作为参数(由`$@`访问)传递给函数的命令。如果命令成功，它将返回，从而退出循环。

# 还有更多...

我们看到了运行命令直到它们成功的基本方法。让我们让事情变得更有效率。

# 更快的方法

在大多数现代系统中，true 在`/bin`中以二进制形式实现。这意味着每次前面提到的`while`循环运行时，Shell必须产生一个进程。为了避免这种情况，我们可以使用 shell 内置的`:`命令，它总是返回一个退出代码 0:

```sh
repeat() { while :; do $@ && return; done }

```

尽管不太可读，但这比第一种方法更快。

# 增加延迟

假设您正在使用`repeat()`从互联网上下载一个文件，该文件现在不可用，但将在一段时间后可用。一个例子如下:

```sh
repeat wget -c http://www.example.com/software-0.1.tar.gz

```

这个脚本会在`www.example.com`向 web 服务器发送过多的流量，这会给服务器带来问题(如果服务器将你的 IP 列入攻击者黑名单，可能还会给你带来问题)。为了解决这个问题，我们修改函数并添加延迟，如下所示:

```sh
repeat() { while :; do $@ && return; sleep 30; done }

```

这将导致命令每 30 秒运行一次。

# 字段分隔符和迭代器

**内部字段分隔符** ( **IFS** )是 shell 脚本中的一个重要概念。它对于处理文本数据很有用。

IFS 是一种特殊用途的分隔符。它是一个存储定界字符的环境变量。它是运行 shell 环境使用的默认分隔符字符串。

考虑我们需要遍历字符串中的单词或**逗号分隔值** ( **CSV** )的情况。在第一种情况下，我们将使用`IFS=" "`，在第二种情况下，将使用`IFS=","`。

# 准备好

考虑 CSV 数据的情况:

```sh
data="name,gender,rollno,location" 
To read each of the item in a variable, we can use IFS. 
oldIFS=$IFS 
IFS=, # IFS is now a , 
for item in $data; 
do 
    echo Item: $item 
done 

IFS=$oldIFS

```

这将生成以下输出:

```sh
Item: name Item: gender Item: rollno Item: location

```

IFS 的默认值是空格(换行符、制表符或空格字符)。

当 IFS 设置为`,`时，shell 将逗号解释为一个分隔符，因此`$item`变量在迭代过程中将逗号分隔的子字符串作为它的值。

如果 IFS 没有设置为`,`，那么它会将整个数据打印为单个字符串。

# 怎么做...

让我们通过 IFS 的另一个示例用法来解析`/etc/passwd`文件。在`/etc/passwd`文件中，每行包含由`:`分隔的项目。文件中的每一行都对应于与用户相关的属性。

考虑输入:`root:x:0:0:root:/root:/bin/bash`。每行的最后一个条目为用户指定了默认Shell。

使用 IFS hack 打印用户及其默认Shell:

```sh
#!/bin/bash 
#Desc: Illustration of IFS 
line="root:x:0:0:root:/root:/bin/bash"  
oldIFS=$IFS; 
IFS=":" 
count=0 
for item in $line; 
do 

     [ $count -eq 0 ]  && user=$item; 
     [ $count -eq 6 ]  && shell=$item; 
    let count++ 
done; 
IFS=$oldIFS 
echo $user's shell is $shell;

```

输出如下:

```sh
root's shell is /bin/bash

```

循环在迭代一系列值时非常有用。Bash 提供了许多类型的循环。

*   **面向列表的`for`循环**:

```sh
        for var in list; 
        do 
            commands; # use $var 
        done 

```

列表可以是字符串或值序列。

我们可以使用`echo`命令生成序列:

```sh
echo {1..50} ;# Generate a list of numbers from 1 to 50.
echo {a..z} {A..Z} ;# List of lower and upper case letters. 

```

我们可以结合这些来连接数据。
在下面的代码中，在每次迭代中，变量 I 将保存 a 到 z 范围内的一个字符:

```sh
      for i in {a..z}; do actions; done;

```

*   **迭代一系列数字**:

```sh
        for((i=0;i<10;i++)) 
        { 
           commands; # Use $i 
        }

```

*   **循环直到满足条件**:

当条件为真时，while 循环继续，直到条件为真时，才会运行:

```sh
        while condition 
        do 
            commands; 
        done

```

对于无限循环，使用`true`作为条件:

*   **使用`until`循环**:

Bash 提供了一个名为`until`的特殊循环。这将执行循环，直到给定条件变为真。考虑这个例子:

```sh
        x=0; 
        until [ $x -eq 9 ]; # [ $x -eq 9 ] is the condition 
        do 
            let x++; echo $x; 
        done

```

# 比较和测试

程序中的流控制是通过比较和测试语句来处理的。Bash 提供了几个选项来执行测试。我们可以使用`if`、`if else`，以及逻辑运算符来执行测试，使用比较运算符来比较数据项。还有一个名为`test`的命令，执行测试。

# 怎么做...

以下是一些用于比较和执行测试的方法:

*   使用`if`条件:

```sh
        if condition; 
        then 
            commands; 
        fi

```

*   使用`else if`和`else`:

```sh
        if condition;  
        then 
            commands; 
        else if condition; then 
            commands; 
        else 
            commands; 
        fi 

```

if 和 else 可以嵌套。if 条件可能很长；为了使它们更短，我们可以使用逻辑运算符:

`[ condition ] && action;` #如果条件为真，则执行动作

`[ condition ] || action;` #如果条件为假，则执行动作

`&&`为逻辑“与”运算，`||`为逻辑“或”运算。这是编写 Bash 脚本时非常有用的技巧。
进行数学比较:通常情况下，条件用方括号括起来`[]`。请注意，`[`或`]`与操作数之间有一个空格。如果没有提供空间，它将显示一个错误。

```sh
[$var -eq 0 ] or [ $var -eq 0]

```

对变量和值进行数学测试，如下所示:

```sh
[ $var -eq 0 ]  # It returns true when $var equal to 0\. 
[ $var -ne 0 ] # It returns true when $var is not equal to 0

```

其他重要操作员包括:

*   `-gt`:大于
*   `-lt`:小于
*   `-ge`:大于等于
*   `-le`:小于等于

`-a`运算符是逻辑“与”，而`-o`运算符是逻辑“或”。可以组合多种测试条件:

```sh
[ $var1 -ne 0 -a $var2 -gt 2 ]  # using and -a 
[ $var1 -ne 0 -o var2 -gt 2 ] # OR -o

```

与文件系统相关的测试如下:

使用不同的条件标志测试不同的文件系统相关属性

*   `[ -f $file_var ]`:如果给定的变量有一个常规的文件路径或文件名，这将返回真
*   `[ -x $var ]`:如果给定的变量包含可执行的文件路径或文件名，则返回真
*   `[ -d $var ]`:如果给定变量包含目录路径或目录名，则返回 true
*   `[ -e $var ]`:如果给定的变量保存了一个现有的文件，则返回 true
*   `[ -c $var ]`:如果给定变量保存字符设备文件的路径，则返回 true
*   `[ -b $var ]`:如果给定变量保存块设备文件的路径，则返回真
*   `[ -w $var ]`:如果给定变量保存了可写文件的路径，则返回 true
*   `[ -r $var ]`:如果给定变量包含可读文件的路径，则返回 true
*   `[ -L $var ]`:如果给定变量包含符号链接
    的路径，则返回真

考虑这个例子:

```sh
fpath="/etc/passwd" 
if [ -e $fpath ]; then 
    echo File exists;  
else 
    echo Does not exist;  
fi

```

字符串比较:使用字符串比较时，最好使用双方括号，因为使用单方括号有时会导致错误

Note that the double square bracket is a Bash extension. If the script will be run using ash or dash (for better performance), you cannot use the double square.

**测试两根弦是否相同**:

*   `[[ $str1 = $str2 ]]`:当`str1`等于`str2`时，即`str1`和`str2`的文字内容相同时，返回真
*   `[[ $str1 == $str2 ]]`:是字符串
    相等校验的替代方法

**测试两个字符串是否不相同**:

*   `[[ $str1 != $str2 ]]`:当`str1`和`str2`不匹配时，返回真

Find alphabetically larger string:
Strings are compared alphabetically by comparing the ASCII value of the characters. For example, "A" is 0x41 and "a" is 0x61\. Thus "A" is less than "a", and "AAa" is less than "Aaa".

*   `[[ $str1 > $str2 ]]`:当`str1`在字母顺序上大于`str2`时，这返回真
*   `[[ $str1 < $str2 ]]`:当`str1`的字母顺序小于`str2`时，这种情况返回真

A space is required after and before `=`; if it is not provided, it is not a comparison, but it becomes an assignment statement.

**测试空串**:

*   `[[ -z $str1 ]]`:如果`str1`持有空字符串，则返回真
*   `[[ -n $str1 ]]`:如果`str1`持有非空字符串，则返回真

使用逻辑运算符`&&`、`||`组合多个条件更容易，如下代码所示:

```sh
if [[ -n $str1 ]] && [[ -z $str2 ]] ;
   then
       commands;
   fi

```

考虑这个例子:

```sh
str1="Not empty " 
str2="" 
if [[ -n $str1 ]] && [[ -z $str2 ]]; 
then 
    echo str1 is nonempty and str2 is empty string. 
fi

```

这将是输出:

```sh
str1 is nonempty and str2 is empty string.

```

测试命令可用于执行条件检查。这减少了使用的大括号的数量，并且可以使您的代码更易读。`[]`中包含的相同测试条件可用于测试命令。

Note that test is an external program which must be forked, while [ is an internal function in Bash and thus more efficient. The test program is compatible with Bourne shell, ash, dash, and others.

考虑这个例子:

```sh
if  [ $var -eq 0 ]; then echo "True"; fi 
can be written as 
if  test $var -eq 0 ; then echo "True"; fi

```

# 使用配置文件定制 bash

您在命令行上键入的大多数命令都可以放在一个特殊的文件中，以便在您登录或启动新的 bash 会话时进行评估。通过将函数定义、别名和环境变量设置放在这些文件中的一个来定制 shell 是很常见的。

放入配置文件的常见命令包括:

```sh
# Define my colors for ls 
LS_COLORS='no=00:di=01;46:ln=00;36:pi=40;33:so=00;35:bd=40;33;01' 
export LS_COLORS 
# My primary prompt 
PS1='Hello $USER'; export PS1 
# Applications I install outside the normal distro paths 
PATH=$PATH:/opt/MySpecialApplication/bin; export PATH 
# Shorthand for commands I use frequently 
function lc () {/bin/ls -C $* ; }

```

**应该用什么定制文件？**

Linux 和 Unix 有几个文件可以保存定制脚本。这些配置文件分为三个阵营:登录时获取的文件、调用交互式 shell 时评估的文件以及调用 shell 处理脚本文件时评估的文件。

# 怎么做...

当用户登录到 shell 时，将对这些文件进行评估:

```sh
/etc/profile, $HOME/.profile, $HOME/.bash_login, $HOME/.bash_profile /

```

Note that `/etc/profile`, `$HOME/.profile` and `$HOME/.bash_profile` may not be sourced if you log in via a graphical login manager. That's because the graphical window manager doesn't start a shell. When you open a terminal window, a shell is created, but it's not a login shell.

如果存在`.bash_profile`或`.bash_login`文件，则不会读取`.profile`文件。

这些文件将由交互Shell读取，如 X11 终端会话或使用`ssh`运行单个命令，如:`ssh 192.168.1.1 ls /tmp`。

```sh
/etc/bash.bashrc $HOME/.bashrc

```

运行如下 shell 脚本:

```sh
$> cat myscript.sh 
#!/bin/bash 
echo "Running"

```

除非您已经定义了`BASH_ENV`环境变量，否则这些文件都不会被获取:

```sh
$> export BASH_ENV=~/.bashrc 
$> ./myscript.sh

```

使用`ssh`运行单个命令，如下所示:

```sh
ssh 192.168.1.100 ls /tmp

```

这将启动一个 bash shell，它将评估`/etc/bash.bashrc`和`$HOME/.bashrc`，但不会评估`/etc/profile`或`.profile`。

调用 ssh 登录会话，如下所示:

```sh
ssh 192.168.1.100

```

这将创建一个新的登录 bash shell，它将评估以下内容:

```sh
/etc/profile 
/etc/bash.bashrc 
$HOME/.profile or .bashrc_profile

```

DANGER: Other shells, such as the traditional Bourne shell, ash, dash, and ksh, also read this file. Linear arrays (lists) and associative arrays, are not supported in all shells. Avoid using these in `/etc/profile` or `$HOME/.profile`.

使用这些文件定义非导出项目，如所有用户所需的别名。考虑这个例子:

```sh
alias l "ls -l"
/etc/bash.bashrc /etc/bashrc

```

使用这些文件保存个人设置。它们对于设置必须由其他 bash 实例继承的路径非常有用。它们可能包括这样的行:

```sh
CLASSPATH=$CLASSPATH:$HOME/MyJavaProject; export CLASSPATH
$HOME/.bash_login $HOME/.bash_profile $HOME/.profile

```

If `.bash_login` or `.bash_profile` are present, `.profile` will not be read. A `.profile` file may be read by other shells.

使用这些文件保存您的个人值，这些值需要在创建新 shell 时定义。如果您希望别名和函数在 X11 终端会话中可用，请在此定义它们:

```sh
$HOME/.bashrc, /etc/bash.bashrc

```

Exported variables and functions are propagated to subordinate shells, but aliases are not. You must define `BASH_ENV` to be the `.bashrc` or `.profile`, where aliases are defined in order to use them in a shell script.

当用户退出会话时，将评估该文件:

```sh
$HOME/.bash_logout

```

例如，如果用户远程登录，他们应该在注销时清除屏幕。

```sh
$> cat ~/.bash_logout 
# Clear the screen after a remote login/logout. 
clear

```