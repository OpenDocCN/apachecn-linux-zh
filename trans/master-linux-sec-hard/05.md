# 加密技术

你可能为一个超级秘密的政府机构工作，或者你可能只是一个普通的乔或简公民。不管怎样，你仍然有敏感的数据需要保护，以免被人窥探。商业秘密、政府秘密、个人秘密——没关系；这一切都需要保护。用限制性权限设置锁定用户主目录，正如我们在 *[第 2 章](02.html)中看到的，保护用户账户*只是难题的一部分；我们还需要加密。这种加密将为我们提供三样东西:

*   **保密性**:这样可以保证只有被授权查看数据的人才能看到。
*   **完整性**:这保证了原始数据没有被未经授权的人篡改。
*   **可用性**:这样可以保证敏感数据始终可用，不会被未经授权的人删除。

我们将在本章中看到的两种一般类型的数据加密旨在保护静态数据和传输中的数据。我们将从使用文件、分区和目录加密来保护静态数据开始。我们将以使用 OpenSSL 保护传输中的数据为结尾。

在本章中，我们将涵盖以下主题:

*   **GNU 隐私卫士** ( **GPG** )
*   使用 **Linux 统一密钥设置** ( **LUKS** )加密分区
*   用加密文件加密目录
*   使用 VeraCrypt 实现加密容器的跨平台共享
*   开放 SSL 和公钥基础设施
*   商业认证机构
*   创建密钥、证书请求和证书
*   创建内部证书颁发机构
*   向操作系统添加证书颁发机构

*   OpenSSL 和 Apache 网络服务器
*   设置相互身份验证

# GNU 隐私保护(GPG)

我们先从 **GNU 隐私卫士** ( **GPG** )说起。这是菲尔·齐默曼在 1991 年创作的《相当好的隐私》的免费开源实现。您可以使用它们中的任何一个来加密或加密签名文件或消息。在这一部分，我们将严格关注 GPG。

使用 GPG 有一些优势:

*   它使用强大的，难以破解的加密算法。
*   它使用私钥/公钥方案，这消除了以安全方式将密码传输给消息或文件接收者的需要。相反，只需发送您的公钥，这对除预期收件人以外的任何人都没用。
*   您可以使用 GPG 加密自己的文件供自己使用，就像您使用任何其他加密工具一样。
*   它可以用来加密电子邮件，使您能够对敏感电子邮件进行真正的端到端加密。
*   有一些图形用户界面类型的前端可以使它更容易使用。

但是，你可能知道，也有一些缺点:

*   当您只直接与您绝对信任的人一起工作时，使用公钥而不是密码是非常好的。但是除此之外的任何事情，例如向普通大众分发公钥，以便每个人都可以验证您的签名消息，您都依赖于一个很难建立的信任网络模型。
*   对于电子邮件的端到端加密，您的电子邮件的收件人还必须在他们的系统上安装 GPG 并知道如何使用它。这在公司环境中可能行得通，但要让你的朋友们建立这种关系，还是很幸运的。(我从未成功让别人设置电子邮件加密。)
*   如果你使用一个独立的电子邮件客户端，比如 Mozilla Thunderbird，你可以安装一个插件来自动加密和解密信息。但是每次发布新的雷鸟更新时，插件都会崩溃，并且总是需要一段时间才能发布新的工作版本。

尽管有许多缺点，GPG 仍然是共享加密文件和电子邮件的最佳方式之一。GPG 预装在 Ubuntu 服务器和 CentOS 上。因此，您可以使用任何一台虚拟机进行这些演示。

# 动手实验室–创建您的 GPG 钥匙

首先你需要知道的是如何创建你的 GPG 键。我们现在就开始吧:

1.  创建您的一对 GPG 钥匙:

```sh
gpg --gen-key
```

Note that, since you're setting this up for yourself, you don't need sudo privileges.

这个命令的输出太长，无法一次显示所有内容，所以我将显示它的相关部分，并分解它们的含义。

这个命令做的第一件事是在你的`home`目录中创建一个填充的`.gnupg`目录:

```sh
gpg: directory `/home/donnie/.gnupg' created
gpg: new configuration file `/home/donnie/.gnupg/gpg.conf' created
gpg: WARNING: options in `/home/donnie/.gnupg/gpg.conf' are not yet active during this run
gpg: keyring `/home/donnie/.gnupg/secring.gpg' created
gpg: keyring `/home/donnie/.gnupg/pubring.gpg' created
```

然后你会被要求选择你想要的钥匙种类。我们只使用默认的`RSA and RSA`。RSA 密钥比旧的 DSA 密钥更强、更难破解。Elgamal 密钥很好，但旧版本的 GPG 可能不支持它们:

```sh
Please select what kind of key you want:
 (1) RSA and RSA (default)
 (2) DSA and Elgamal
 (3) DSA (sign only)
 (4) RSA (sign only)
Your selection?
```

对于适当的加密，您将希望使用至少 3072 位的密钥，因为任何较小的密钥现在都被认为是易受攻击的。(这是根据美国国家标准与技术研究所(NIST)的最新指导。)由于默认为 2，048 位，我们必须键入:

```sh
RSA keys may be between 1024 and 4096 bits long. 
What keysize do you want? (2048) 3072
```

接下来，选择您希望密钥在自动过期之前保持有效的时间。出于我们的目的，我们将使用默认的`key does not expire`:

```sh
Please specify how long the key should be valid. 
 0 = key does not expire 
 <n> = key expires in n days 
 <n>w = key expires in n weeks 
 <n>m = key expires in n months 
 <n>y = key expires in n years 
Key is valid for? (0) 
```

提供您的个人信息:

```sh
GnuPG needs to construct a user ID to identify your key. 
Real name: Donald A. Tevault 
Email address: donniet@something.net 
Comment: No comment 
You selected this USER-ID: 
 "Donald A. Tevault (No comment) <donniet@something.net>" 
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit?
Create a passphrase for your private key:
You need a Passphrase to protect your secret key. 
We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. 
```

这可能需要一段时间，即使你正在做所有推荐的事情来创造熵。要有耐心；它最终会结束。通过在另一个窗口中运行`sudo yum upgrade`，我创建了足够的熵，这样这个过程就不会花太长时间:

```sh
gpg: /home/donnie/.gnupg/trustdb.gpg: trustdb created 
gpg: key 19CAEC5B marked as ultimately trusted 
public and secret key created and signed. 
gpg: checking the trustdb 
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model 
gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u 
pub 2048R/19CAEC5B 2017-10-26 
 Key fingerprint = 8DE5 8894 2E37 08C4 5B26 9164 C77C 6944 19CA EC5B 
uid Donald A. Tevault (No comment) <donniet@something.net> 
sub 2048R/37582F29 2017-10-26
```

2.  验证密钥是否已创建:

```sh
[donnie@localhost ~]$ gpg --list-keys
 /home/donnie/.gnupg/pubring.gpg
 -------------------------------
 pub 2048R/19CAEC5B 2017-10-26
 uid Donald A. Tevault (No comment) <donniet@something.net>
 sub 2048R/37582F29 2017-10-26
 [donnie@localhost ~]$
```

3.  在此过程中，请查看您创建的文件:

```sh
[donnie@localhost ~]$ ls -l .gnupg
 total 28
 -rw-------. 1 donnie donnie 7680 Oct 26 13:22 gpg.conf
 drwx------. 2 donnie donnie 6 Oct 26 13:40 private-keys-v1.d
 -rw-------. 1 donnie donnie 1208 Oct 26 13:45 pubring.gpg
 -rw-------. 1 donnie donnie 1208 Oct 26 13:45 pubring.gpg~
 -rw-------. 1 donnie donnie 600 Oct 26 13:45 random_seed
 -rw-------. 1 donnie donnie 2586 Oct 26 13:45 secring.gpg
 srwxrwxr-x. 1 donnie donnie 0 Oct 26 13:40 S.gpg-agent
 -rw-------. 1 donnie donnie 1280 Oct 26 13:45 trustdb.gpg
 [donnie@localhost ~]$
```

这些文件是您的公共和私有密钥环、您自己的`gpg.conf`文件、随机种子文件和可信用户数据库。

# 动手实验–对称加密您自己的文件

你可能会发现 GPG 对加密你自己的文件很有用，即使你从未打算与他人共享它们。为此，您将使用对称加密，这包括使用您自己的私钥进行加密。在尝试之前，您需要生成您的密钥，正如我在前面部分中概述的:

Symmetric key encryption is, well, just that, symmetric. It's symmetric in the sense that the key that you would use to encrypt a file is the same key that you would use to decrypt the file. That's great for if you're just encrypting files for your own use. But if you need to share an encrypted file with someone else, you'll need to figure out a secure way to give that person the password. I mean, it's not like you'd want to just send the password in a plain-text email.

1.  除了您自己的用户帐户，您还需要一个 Maggie 的用户帐户。立即为 CentOS 创建她的帐户:

```sh
sudo useradd maggie
sudo passwd maggie
```

这是给 Ubuntu 的:

```sh
sudo adduser maggie
sudo passwd maggie
```

2.  让我们加密一个超级机密文件，我们不能让它落入坏人之手:

```sh
[donnie@localhost ~]$ gpg -c secret_squirrel_stuff.txt
[donnie@localhost ~]$
```

请注意，`-c`选项表示我选择对文件使用带有密码的对称加密。您输入的密码将用于文件，而不是您的私钥。

3.  看看你的新文件集。这种方法的一个小缺陷是，GPG 制作了文件的加密副本，但也保留了原始的未加密文件:

```sh
[donnie@localhost ~]$ ls -l
 total 1748
 -rw-rw-r--. 1 donnie donnie 37 Oct 26 14:22 secret_squirrel_stuff.txt
 -rw-rw-r--. 1 donnie donnie 94 Oct 26 14:22
 secret_squirrel_stuff.txt.gpg
[donnie@localhost ~]$
```

4.  让我们用`shred`去掉那个未加密的文件。我们将使用`-u`选项删除文件，使用`-z`选项用零覆盖删除的文件:

```sh
[donnie@localhost ~]$ shred -u -z secret_squirrel_stuff.txt
[donnie@localhost ~]$
```

看起来好像什么都没发生，因为`shred`没有给你任何输出。但是`ls -l`会证明文件没了。

5.  现在，如果我用`less secret_squirrel_stuff.txt.gpg`查看加密文件，我将能够在被要求输入我的私钥密码后看到它的内容。自己试试这个:

```sh
less secret_squirrel_stuff.txt.gpg

Shhh!!!! This file is super-secret.
secret_squirrel_stuff.txt.gpg (END)
```

6.  只要我的私钥仍然加载到我的密钥环中，我就可以再次查看我的加密文件，而无需重新输入密码。现在，为了向您证明文件确实是加密的，我将创建一个共享目录，并将文件移动到那里供其他人访问。同样，继续尝试一下:

```sh
sudo mkdir /shared
sudo chown donnie: /shared
sudo chmod 755 /shared
mv secret_squirrel_stuff.txt.gpg /shared
```

当我进入那个目录用`less`查看文件时，我仍然可以看到它的内容，而不必重新输入我的密码。

7.  但是现在，让我们看看当玛吉试图查看文件时会发生什么。使用`su - maggie`切换到她的账号，让她试试:

```sh
su - maggie
cd /shared

[maggie@localhost shared]$ less secret_squirrel_stuff.txt.gpg
"secret_squirrel_stuff.txt.gpg" may be a binary file. See it anyway?
```

无论如何，当她按下 *Y* 键查看时，她会得到以下信息:

```sh
<8C>^M^D^C^C^B<BD>2=<D3>͈u<93><CE><C9>MОOy<B6>^O<A2><AD>}Rg9<94><EB><C4>^W^E
 <A6><8D><B9><B8><D3>(<98><C4>æF^_8Q2b<B8>C<B5><DB>^]<F1><CD>#<90>H<EB><90><
 C5>^S%X [<E9><EF><C7>
 ^@y+<FC><F2><BA><U+058C>H'+<D4>v<84>Y<98>G<D7>֊
secret_squirrel_stuff.txt.gpg (END)
```

可怜的玛吉真的很想看我的文件，但她只能看到加密的胡言乱语。

我刚才展示的是 GPG 的另一个优势。输入一次私钥密码后，您可以查看任何加密文件，而无需手动解密，也无需重新输入密码。使用其他对称文件加密工具，如`bcrypt`，如果不先手动解密，您将无法查看您的文件。

8.  但是现在假设您不再需要加密这个文件，并且您想要解密它以便让其他人看到它。通过输入`exit`退出玛吉的账户。然后，只需将`gpg`与`-d`选项一起使用:

```sh
[maggie@localhost shared]$ exit

[donnie@localhost shared]$ gpg -d secret_squirrel_stuff.txt.gpg
 gpg: CAST5 encrypted data
 gpg: encrypted with 1 passphrase
 Shhh!!!! This file is super-secret.
 gpg: WARNING: message was not integrity protected
[donnie@localhost shared]$
```

`WARNING`关于消息未被完整性保护的消息意味着我已经对文件进行了加密，但我从未对文件进行签名。没有数字签名，有人可以在我不知道的情况下修改文件，我也无法证明我是文件的发起人。(不用担心，我们稍后将讨论签署文件。)

# 动手实验-用公钥加密文件

在本实验中，您将了解如何使用 GPG 公钥加密来加密和共享文件:

1.  首先，为 Frank 创建一个用户帐户，就像您在前面的实验中为 Maggie 所做的那样。
2.  为你自己和弗兰克创建一个密钥集，正如我已经向你展示的那样。接下来，将自己的公钥提取到一个`ASCII`文本文件中。以弗兰克的身份登录，提取他的公钥:

```sh
cd .gnupg
gpg --export -a -o donnie_public-key.txt
```

以弗兰克的身份登录，并为他重复此命令。

3.  通常，参与者会通过电子邮件附件或通过将密钥放在共享目录中的方式将密钥发送给对方。在这种情况下，您和 Frank 将接收对方的公钥文件，并将其放入各自的`.gnupg`目录中。完成后，导入彼此的密钥:

```sh
donnie@ubuntu:~/.gnupg$ gpg --import frank_public-key.txt
gpg: key 4CFC6990: public key "Frank Siamese (I am a cat.) <frank@any.net>" imported
gpg: Total number processed: 1
gpg: imported: 1 (RSA: 1)
donnie@ubuntu:~/.gnupg$

frank@ubuntu:~/.gnupg$ gpg --import donnie_public-key.txt
gpg: key 9FD7014B: public key "Donald A. Tevault <donniet@something.net>" imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)
frank@ubuntu:~/.gnupg$
```

4.  好的方面是。为 Frank 创建一个超机密消息，非对称加密(`-e`)，然后签名(`-s`)。签署消息是验证消息确实来自您，而不是来自冒名顶替者:

```sh
donnie@ubuntu:~$ gpg -s -e secret_stuff_for_frank.txt

. . .
. . .
It is NOT certain that the key belongs to the person named
in the user ID.  If you *really* know what you are doing,
you may answer the next question with yes.

Use this key anyway? (y/N) y

Current recipients:
2048R/CD8104F7 2017-10-27 "Frank Siamese (I am a cat.) <frank@any.net>"

Enter the user ID.  End with an empty line:
donnie@ubuntu:~$
```

因此，您要做的第一件事是输入私钥的密码。在显示输入用户标识的地方，输入`frank`，因为他是你信息的预期接收者。但是看看后面的线，上面写着`There is no assurance this key belongs to the named user`。那是因为你还没有信任弗兰克的公钥。我们一会儿再谈。输出的最后一行再次表示输入一个用户标识，这样我们就可以指定多个收件人。但是弗兰克是你现在唯一关心的人，所以只要按下*进入*键就可以打破常规。这导致了你给弗兰克的信息的一个`.gpg`版本:

```sh
donnie@ubuntu:~$ ls -l
total 8
. . .
-rw-rw-r-- 1 donnie donnie 143 Oct 27 18:37 secret_stuff_for_frank.txt
-rw-rw-r-- 1 donnie donnie 790 Oct 27 18:39 secret_stuff_for_frank.txt.gpg
donnie@ubuntu:~$
```

5.  你这边的最后一步是通过任何可用的方式向弗兰克发送他的加密消息文件。
6.  当弗兰克收到他的信息时，他将使用`-d`选项查看:

```sh
frank@ubuntu:~$ gpg -d secret_stuff_for_frank.txt.gpg
. . .
. . .
gpg: gpg-agent is not available in this session
gpg: encrypted with 2048-bit RSA key, ID CD8104F7, created 2017-10-27
 "Frank Siamese (I am a cat.) <frank@any.net>"
This is TOP SECRET stuff that only Frank can see!!!!!
If anyone else see it, it's the end of the world as we know it.
(With apologies to REM.)
gpg: Signature made Fri 27 Oct 2017 06:39:15 PM EDT using RSA key ID 9FD7014B
gpg: Good signature from "Donald A. Tevault <donniet@something.net>"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: DB0B 31B8 876D 9B2C 7F12  9FC3 886F 3357 9FD7 014B
frank@ubuntu:~$
```

7.  弗兰克输入了他的私钥密码，他看到了消息。在底部，他看到了关于您的公钥不可信的警告，以及`There is no indication that the signature belongs to the owner`。假设你和弗兰克私下认识，他知道公钥确实是你的。然后，他会将您的公钥添加到信任列表中:

```sh
frank@ubuntu:~$ cd .gnupg
frank@ubuntu:~/.gnupg$ gpg --edit-key donnie
gpg (GnuPG) 1.4.20; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   2  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 2u
pub  2048R/9FD7014B  created: 2017-10-27  expires: never       usage: SC
 trust: ultimate      validity: ultimate
sub  2048R/9625E7E9  created: 2017-10-27  expires: never       usage: E
[ultimate] (1). Donald A. Tevault <donniet@something.net>
gpg>

```

8.  该输出的最后一行是`gpg` shell 的命令提示符。弗兰克关心的是信任，所以他会输入`trust`命令:

```sh
gpg> trust
pub  2048R/9FD7014B  created: 2017-10-27  expires: never       usage: SC
 trust: unknown       validity: unknown
sub  2048R/9625E7E9  created: 2017-10-27  expires: never       usage: E
[ unknown] (1). Donald A. Tevault <donniet@something.net>
Please decide how far you trust this user to correctly verify other users' keys
(by looking at passports, checking fingerprints from different sources, etc.)
 1 = I don't know or won't say
 2 = I do NOT trust
 3 = I trust marginally
 4 = I trust fully
 5 = I trust ultimately
 m = back to the main menu
Your decision? 5
Do you really want to set this key to ultimate trust? (y/N) y
```

9.  弗兰克认识你有一段时间了，他知道你是送钥匙的人。所以，他选择了`5`选项来获得终极信任。一旦 Frank 注销并重新登录，该信任将生效:

```sh
frank@ubuntu:~$ gpg -d secret_stuff_for_frank.txt.gpg

You need a passphrase to unlock the secret key for
user: "Frank Siamese (I am a cat.) <frank@any.net>"
2048-bit RSA key, ID CD8104F7, created 2017-10-27 (main key ID 4CFC6990)

gpg: gpg-agent is not available in this session
gpg: encrypted with 2048-bit RSA key, ID CD8104F7, created 2017-10-27
 "Frank Siamese (I am a cat.) <frank@any.net>"
This is TOP SECRET stuff that only Frank can see!!!!!
If anyone else see it, it's the end of the world as we know it.
(With apologies to REM.)
gpg: Signature made Fri 27 Oct 2017 06:39:15 PM EDT using RSA key ID 9FD7014B
gpg: Good signature from "Donald A. Tevault <donniet@something.net>"
frank@ubuntu:~$
```

10.  没有更多的警告消息，这看起来好多了。在你这边，用弗兰克的公钥做同样的事情。

As you can see in the screen output in *step 8*, you can assign the marginal, full, or ultimate trust level to someone else's public key. Space doesn't permit me to provide a full explanation of the trust levels, but you can read a rather colorful explanation here: PGP Web of Trust: Core Concepts Behind Trusted Communication — [https://www.linux.com/tutorials/pgp-web-trust-core-concepts-behind-trusted-communication/](https://www.linux.com/tutorials/pgp-web-trust-core-concepts-behind-trusted-communication/).

这其中非常酷的一点是，即使全世界都可能拥有你的公钥，但对于任何不是你的指定收件人的人来说，它都是无用的。

On an Ubuntu machine, to get rid of the `gpg-agent is not available in this session` messages and to be able to cache your passphrase in the keyring, install the `gnupg-agent` package:

`sudo apt install gnupg-agent`

现在我们已经做到了这一点，让我们看看如何在没有加密的情况下对文件*进行签名。*

# 动手实验–在没有加密的情况下签署文件

如果文件不是机密文件，但您仍然需要确保真实性和完整性，那么您只需在不加密的情况下签名即可:

1.  为弗兰克创建一条未加密的消息，然后签名:

```sh
donnie@ubuntu:~$ gpg -s not_secret_for_frank.txt

You need a passphrase to unlock the secret key for
user: "Donald A. Tevault <donniet@something.net>"
2048-bit RSA key, ID 9FD7014B, created 2017-10-27

gpg: gpg-agent is not available in this session
donnie@ubuntu:~$ ls -l
. . .
-rw-rw-r-- 1 donnie donnie  40 Oct 27 19:30 not_secret_for_frank.txt
-rw-rw-r-- 1 donnie donnie 381 Oct 27 19:31 not_secret_for_frank.txt.gpg
```

就像之前一样，这会创建文件的`.gpg`版本。

2.  把信息发给弗兰克。
3.  以弗兰克的身份登录。让他试着用`less`打开它:

```sh
frank@ubuntu:~$ less not_secret_for_frank.txt.gpg
"not_secret_for_frank.txt.gpg" may be a binary file.  See it anyway?

<A3>^A^Av^A<89><FE><90>^M^C^@^B^A<88>o3W<9F><D7>^AK^A<AC>Fb^Xnot_secret_for_frank.txtY<F3><C1><C0>This isn't secret, so I just signed it.
<89>^A^\^D^@^A^B^@^F^E^BY<F3><C1><C0>^@
. . .
. . .
<D3>K<E5>^G<8E><90>d<8C><DA>Aɱb<86><89><DA>S<B6><91><D8><D2><E0><B3>K<FC><9E>
<ED>^@*<EF>x<E7>jø<FD><D3><FA><9A>^]
not_secret_for_frank.txt.gpg (END)
```

4.  由于签名，这里有很多乱码，但是如果你仔细看，你会看到简单的、未加密的消息。让 Frank 使用`gpg`和`--verify`选项来验证签名确实属于您:

```sh
frank@ubuntu:~$ gpg --verify not_secret_for_frank.txt.gpg
gpg: Signature made Fri 27 Oct 2017 07:31:12 PM EDT using RSA key ID 9FD7014B
gpg: Good signature from "Donald A. Tevault <donniet@something.net>"
frank@ubuntu:~$ 
```

这就结束了我们对加密单个文件的讨论。现在让我们看一下加密块设备和目录。

# 使用 Linux 统一密钥设置加密分区(LUKS)

能够对单个文件进行加密可能很方便，但也是有意义的

*   **块加密**:我们可以用这个来进行全磁盘加密，也可以加密单个分区。
*   **文件级加密**:我们可以用它来加密单个目录，而不必加密底层分区。
*   **容器化加密**:使用不附带任何 Linux 发行版的第三方软件，我们可以创建加密的跨平台容器，可以在 Linux、macOS 或 Windows 机器上打开。

**Linux 统一密钥设置** ( **LUKS** )属于第一类。几乎每个 Linux 发行版都内置了它，每个发行版的使用说明都是一样的。对于我们的演示，我将使用 CentOS 虚拟机，因为 LUKS 现在是红帽企业 Linux 7/8 和 CentOS 7/8 的默认加密机制。

You might be wondering if there's any performance impact with all of this disk encryption business. Well, with today's fast CPUs, not really. I run Fedora with full-disk encryption on a low-spec, Core i5 laptop, and other than having to enter the disk-encryption password when I first boot up, I don't even notice that encryption is taking place.

好的，让我们看看在安装操作系统的同时加密磁盘。

# 操作系统安装期间的磁盘加密

当您安装红帽企业 Linux 7/8 或它们的一个后代时，您可以选择加密驱动器。您点击的所有内容:

![](assets/f1dbd075-67eb-45b5-b1b5-23bf2145aae2.png)

除此之外，我只是让安装程序创建默认的分区方案，这意味着`/`文件系统和`swap`分区都将是加密的逻辑卷。(我一会儿会谈到这一点。)

在继续安装之前，我必须创建一个密码来装载加密磁盘:

![](assets/dba7bb60-85c2-48f3-b14e-415f67a3e548.png)

现在，每当我重新启动系统时，我都需要输入以下密码:

![](assets/cf6cca52-7569-4b10-a051-1d0d9071923b.png)

一旦机器启动并运行，我就可以查看逻辑卷列表。我看到了`/`逻辑卷和`swap`逻辑卷:

```sh
[donnie@localhost etc]$ sudo lvdisplay
 --- Logical volume ---
 LV Path /dev/centos/swap
 LV Name swap
 VG Name centos
. . .
. . .

 --- Logical volume ---
 LV Path /dev/centos/root
 LV Name root
 VG Name centos
. . .
. . .
[donnie@localhost etc]$
```

我可以查看物理卷的列表。其实列表中只有一个物理卷，被列为`luks`物理卷:

```sh
[donnie@localhost etc]$ sudo pvdisplay
 --- Physical volume ---
 PV Name               /dev/mapper/luks-2d7f02c7-864f-42ce-b362-50dd830d9772
 VG Name               centos
 PV Size               <19.07 GiB / not usable 0
 Allocatable           yes
 PE Size               4.00 MiB
 Total PE              4881
 Free PE               1
 Allocated PE          4880
 PV UUID               V50E4d-jOCU-kVRn-67w9-5zwR-nbwg-4P725S

[donnie@localhost etc]$
```

这表明底层物理卷是加密的，这意味着`/`和`swap`逻辑卷也是加密的。这是一件好事，因为不加密交换空间(手动设置磁盘加密时的常见错误)会导致数据泄漏。

# 动手实验–使用 LUKS 添加加密分区

有时，您可能需要向现有机器添加另一个加密驱动器，或者加密便携式设备，如 u 盘。此过程适用于两种情况。按照以下步骤添加加密分区:

1.  关闭您的 CentOS 虚拟机并添加另一个虚拟驱动器:

![](assets/49ad814e-77ed-4429-a308-ef3ad8806072.png)

将驱动器容量提升至 20 GB，这将为您提供充足的空间:

![](assets/8e0e136e-932b-41f0-a609-43e46197e6fb.png)

2.  重启机器后，你现在可以玩`/dev/sdb`驱动器了。下一步是创建一个分区。无论您创建的是新式的 GPT 分区还是老式的 MBR 分区，都没有关系。要创建一个 GPT 分区，我更喜欢的工具是`gdisk`，因为它与我非常熟悉和喜爱的旧的`fdisk`非常相似。唯一的问题是`gdisk`默认情况下不会安装在 CentOS 上。安装`gdisk`如下:

```sh
On CentOS 7:
sudo yum install gdisk

On CentOS 8:
sudo dnf install gdisk 
```

3.  在`gdisk`中打开驱动器。将整个驱动器用于分区，并将分区类型设置为默认类型`8300`:

```sh
sudo gdisk /dev/sdb
```

4.  查看您的新`/dev/sdb1`分区的详细信息:

```sh
[donnie@localhost ~]$ sudo gdisk -l /dev/sdb
[sudo] password for donnie:
GPT fdisk (gdisk) version 0.8.6

Partition table scan:
 MBR: protective
 BSD: not present
 APM: not present
 GPT: present
. . .
. . .
[donnie@localhost ~]$
```

5.  接下来，使用`cryptsetup`将分区转换为 LUKS 格式。在此命令中，`-v`表示详细模式，`-y`表示您必须输入两次密码才能正确验证。注意，当它说要全部大写输入`yes`时，它实际上是指大写输入:

```sh
[donnie@localhost ~]$ sudo cryptsetup -v -y luksFormat /dev/sdb1

WARNING!
========
This will overwrite data on /dev/sdb1 irrevocably.

Are you sure? (Type uppercase yes): YES
Enter passphrase:
Verify passphrase:
Command successful.
[donnie@localhost ~]$
```

6.  查看有关新加密分区的信息:

```sh
[donnie@localhost ~]$ sudo cryptsetup luksDump /dev/sdb1
LUKS header information for /dev/sdb1

Version:           1
Cipher name:       aes
Cipher mode:       xts-plain64
Hash spec:         sha256
. . .
. . .
```

输出内容比我在这里展示的要多得多，但你已经明白了。

7.  将分区映射到设备名称。你可以随便给这个设备起什么名字。现在，只需说出这一个`secrets`。我知道，这是个老掉牙的名字。在现实生活中，你不会想把你的秘密藏在哪里变得如此明显:

```sh
[donnie@localhost ~]$ sudo cryptsetup luksOpen /dev/sdb1 secrets
Enter passphrase for /dev/sdb1:
[donnie@localhost ~]$
```

8.  查看`/dev/mapper`目录。您将看到新的`secrets`设备被列为与`dm-3`设备的符号链接:

```sh
[donnie@localhost mapper]$ pwd
/dev/mapper
[donnie@localhost mapper]$ ls -l se*
lrwxrwxrwx. 1 root root 7 Oct 28 17:39 secrets -> ../dm-3
[donnie@localhost mapper]$
```

9.  使用`dmsetup`查看新设备的信息:

```sh
[donnie@localhost mapper]$ sudo dmsetup info secrets
[sudo] password for donnie:
Name:              secrets
State:             ACTIVE
Read Ahead:        8192
Tables present:    LIVE
Open count:        0
Event number:      0
Major, minor:      253, 3
Number of targets: 1
UUID: CRYPT-LUKS1-6cbdce1748d441a18f8e793c0fa7c389-secrets

[donnie@localhost mapper]$
```

10.  以通常的方式格式化分区。您可以使用红帽和 CentOS 支持的任何文件系统。但是由于系统上的其他所有内容都已经用 XFS 格式化了，所以这里也用它:

```sh
[donnie@localhost ~]$ sudo mkfs.xfs /dev/mapper/secrets
meta-data=/dev/mapper/secrets    isize=512    agcount=4, agsize=1374123 blks
 =                       sectsz=512   attr=2, projid32bit=1
 =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=5496491, imaxpct=25
 =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2683, version=2
 =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[donnie@localhost ~]$
```

11.  创建装载点并装载加密分区:

```sh
[donnie@localhost ~]$ sudo mkdir /secrets
[sudo] password for donnie:
[donnie@localhost ~]$ sudo mount /dev/mapper/secrets /secrets
[donnie@localhost ~]$
```

12.  使用`mount`命令验证分区是否安装正确:

```sh
[donnie@localhost ~]$ mount | grep 'secrets'
/dev/mapper/secrets on /secrets type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
[donnie@localhost ~]$
```

# 将 LUKS 分区配置为自动装载

唯一缺少的部分是配置系统在启动时自动挂载 LUKS 分区。为此，请配置两个不同的文件:

*   `/etc/crypttab`
*   `/etc/fstab`

如果您在安装操作系统时加密了`sda`驱动器，您将已经有一个包含该驱动器信息的`crypttab`文件。它看起来像这样:

```sh
luks-2d7f02c7-864f-42ce-b362-50dd830d9772 UUID=2d7f02c7-864f-42ce-b362-50dd830d9772 none
```

前两个字段描述加密分区的名称和位置。第三个字段是加密密码。如果设置为`none`，就像这里一样，那么密码必须在启动时手动输入。

在`fstab`文件中，我们有实际挂载分区的条目:

```sh
/dev/mapper/centos-root /                 xfs     defaults,x-systemd.device-timeout=0 0 0
UUID=9f9fbf9c-d046-44fc-a73e-ca854d0ca718 /boot                   xfs     defaults        0 0

/dev/mapper/centos-swap swap              swap    defaults,x-systemd.device-timeout=0 0 0
```

嗯，在这种情况下，实际上有两个条目，因为我们有两个逻辑卷，`/`和`swap`，在加密的物理卷之上。`UUID`行是`/boot`分区，这是驱动器中唯一没有加密的部分。现在，让我们添加新的加密分区，这样它也会自动挂载。

# 动手实验–将 LUKS 分区配置为自动装载

在本实验中，您将设置在上一个实验中创建的加密分区，以便在重新启动计算机时自动挂载:

This is where it would be extremely helpful to remotely log in to your virtual machine from your desktop host machine. By using a GUI-type terminal, be it Terminal from a Linux or macOS machine or Cygwin from a Windows machine, you'll have the ability to perform copy-and-paste operations, which you won't have if you work directly from the virtual machine terminal. (Trust me, you don't want to be typing in those long UUIDs.)

1.  第一步是获取加密分区的 UUID:

```sh
[donnie@localhost etc]$ sudo cryptsetup luksUUID /dev/sdb1
[sudo] password for donnie:
6cbdce17-48d4-41a1-8f8e-793c0fa7c389
[donnie@localhost etc]$
```

2.  复制 UUID 并将其粘贴到`/etc/crypttab`文件中。根据需要编辑或创建`cryptab`文件。另外，请注意，您将粘贴 UUID 两次。第一次在前面加上`luks-`，第二次在后面加上`UUID=`:

```sh
luks-2d7f02c7-864f-42ce-b362-50dd830d9772 UUID=2d7f02c7-864f-42ce-b362-50dd830d9772 none
luks-6cbdce17-48d4-41a1-8f8e-793c0fa7c389 UUID=6cbdce17-48d4-41a1-8f8e-793c0fa7c389 none
```

3.  编辑`/etc/fstab`文件，为新的加密分区添加文件的最后一行。请注意，您必须再次使用`luks-`，后跟 UUID 号码:

```sh
/dev/mapper/centos-root / xfs defaults,x-systemd.device-timeout=0 0 0
UUID=9f9fbf9c-d046-44fc-a73e-ca854d0ca718 /boot xfs defaults 0 0
/dev/mapper/centos-swap swap swap defaults,x-systemd.device-timeout=0 0 0
/dev/mapper/luks-6cbdce17-48d4-41a1-8f8e-793c0fa7c389 /secrets xfs defaults 0 0
```

When editing the `fstab` file for adding normal, unencrypted partitions, I always like to do `sudo mount -a` to check the `fstab` file for typos. That won't work with LUKS partitions though, because `mount` won't recognize the partition until the system reads in the `crypttab` file, and that won't happen until I reboot the machine. So, just be extra careful with editing `fstab` when adding LUKS partitions.

4.  现在是真相大白的时候了。重启机器，看看是否一切正常。使用`mount`命令验证您的努力是否成功:

```sh
[donnie@localhost ~]$ mount | grep 'secrets'
/dev/mapper/luks-6cbdce17-48d4-41a1-8f8e-793c0fa7c389 on /secrets type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
[donnie@localhost ~]$
```

5.  实验室结束。

Although it's possible to include passwords or keys in the `/etc/crypttab` file, my own preference is to not do so. If you must do so, be sure that the passwords or keys are stored on an encrypted `/` partition, for which you'll always have to enter a password upon boot-up. You can read more about that here: Store the passphrase of encrypted disk in `/etc/crypttab` encrypted: [https://askubuntu.com/questions/181518/store-the-passphrase-of-encrypted-disk-in-etc-crypttab-encrypted](https://askubuntu.com/questions/181518/store-the-passphrase-of-encrypted-disk-in-etc-crypttab-encrypted)

现在我们已经看到了 LUKS，让我们继续讨论埃及文件。

# 用加密文件加密目录

加密整个分区很酷，但有时您可能只需要加密单个目录。为此，我们可以使用加密文件。为此，我们需要使用我们的 Ubuntu 机器，因为红帽和 CentOS 不再在其产品的 7 版或 8 版中包含加密文件。(它曾在红帽 6 和 CentOS 6 中出现，但在 7 或 8 版本中甚至不再提供安装。)

# Ubuntu 安装期间的主目录和磁盘加密

当你安装 Ubuntu 服务器 16.04 时，你有两个加密。你将要

![](assets/c584bd38-41a4-4141-9c56-2e4c49ec7701.png)

此功能已从 Ubuntu 服务器 18.04 安装程序中删除。

在 Ubuntu 16.04 或 Ubuntu 18.04 的“分区磁盘”屏幕上，您将有机会为整个磁盘加密设置加密逻辑卷:

![](assets/bd3de3f5-322a-4265-b7ca-107013a55610.png)

选择此选项后，系统会要求您输入密码:

![](assets/ad16ac9f-6a44-4d73-9619-2ae7de17f583.png)

磁盘加密使用 LUKS，就像我们在 CentOS 机器上看到的一样。为了证明这一点，我们所要做的就是在`/etc`目录中寻找一个填充的`crypttab`文件:

```sh
donnie@ubuntu3:~$ cd /etc
donnie@ubuntu3:/etc$ cat crypttab
sda5_crypt UUID=56190c2b-e46b-40a9-af3c-4cb26c4fe998 none luks,discard
cryptswap1 UUID=60661042-0dbd-4c2a-9cf9-7f02a73864ae /dev/urandom swap,offset=1024,cipher=aes-xts-plain64
donnie@ubuntu3:/etc$
```

Unlike Red Hat and CentOS, an Ubuntu machine will always have the `/etc/crypttab` file, even if there are no LUKS partitions. Without LUKS partitions, the file will be empty.

Ubuntu 16.04 的主目录加密使用 eCryptfs，如`/home`目录中的`.ecryptfs`目录所示:

```sh
donnie@ubuntu3:/home$ ls -la
total 16
drwxr-xr-x 4 root root 4096 Oct 29 15:06 .
drwxr-xr-x 23 root root 4096 Oct 29 15:23 ..
drwx------ 3 donnie donnie 4096 Oct 29 15:29 donnie
drwxr-xr-x 3 root root 4096 Oct 29 15:06 .ecryptfs
donnie@ubuntu3:/home$
```

如果您为 Ubuntu 16.04 选择这两个选项，您将在加密之上拥有加密，以实现双重保护。真的有这个必要吗？可能不会，但是选择加密我的`home`目录确保了它的访问权限被设置为更严格的`700`设置，而不是默认的`755`设置。但是，请注意，您现在创建的任何用户帐户都将在其`home`目录中拥有完全开放的权限设置，除非您使用加密选项创建用户帐户。还要注意，正如我所说的，在 Ubuntu 18.04 安装程序中，使用加密文件来加密你的`home`目录不再是一个选项。说到这里，让我们在下一个实验中进行一些实际操作，假设您的硬盘没有用 LUKS 加密。

# 动手实验–为新用户帐户加密主目录

在[第 2 章](02.html)*保护用户帐户*中，我向您展示了 Ubuntu 如何允许您在创建用户帐户时加密用户的主目录。回顾一下，让我们看看创建歌迪帐户的命令:

1.  如果还没有完成，安装`ecryptfs-utils`包:

```sh
sudo apt install ecryptfs-utils
```

2.  在 Ubuntu 虚拟机上，使用加密目录创建 Goldie 的帐户:

```sh
sudo adduser --encrypt-home goldie
```

3.  让歌迪登录。让她`unwrap`自己的坐骑密码，写下来，存放在安全的地方。如果她需要恢复损坏的目录，她将需要它:

```sh
ecryptfs-unwrap-passphrase .ecryptfs/wrapped-passphrase
```

当您使用`adduser --encrypt-home`时，新用户的`home`目录将被自动设置为一个限制性权限值，该值将除目录所有者之外的所有人排除在外。即使将`adduser.conf`文件设置保留为默认设置，这种情况也会发生。

# 在现有主目录中创建私有目录

假设您有这样的用户，不管出于什么奇怪的原因，他们不想加密他们的整个`home`目录，而想保留他们的`home`目录上的`755`权限设置，以便其他人可以访问他们的文件。但是他们也想要一个私人目录，只有他们才能访问。

任何用户都可以在自己的`home`目录内创建一个加密的私有目录，而不是加密整个`home`目录。让我们来看看:

1.  如果还没有完成，安装`ecryptfs-utils`包:

```sh
sudo apt install ecryptfs-utils
```

要创建这个私有目录，请使用交互式`ecryptfs-setup-private`实用程序。如果您有管理员权限，您可以为其他用户执行此操作。没有管理员权限的用户可以自己操作。对于我们的演示，假设查理，我的大暹罗/灰色斑猫，需要他自己的加密私人空间。(谁知道猫有秘密，对吧？)

2.  以正常方式创建查理的帐户，*没有*加密的`home`目录选项。
3.  然后，以查理的身份登录，让他创建自己的私有目录:

```sh
charlie@ubuntu2:~$ ecryptfs-setup-private
Enter your login passphrase [charlie]:
Enter your mount passphrase [leave blank to generate one]:
Enter your mount passphrase (again):

************************************************************************
YOU SHOULD RECORD YOUR MOUNT PASSPHRASE AND STORE IT IN A SAFE LOCATION.
 ecryptfs-unwrap-passphrase ~/.ecryptfs/wrapped-passphrase
THIS WILL BE REQUIRED IF YOU NEED TO RECOVER YOUR DATA AT A LATER TIME.
************************************************************************
. . .
. . .
charlie@ubuntu2:~$
```

4.  对于`login`密码短语，查理输入他的正常密码或密码短语以登录到他的用户帐户。他本可以让系统生成自己的`mount`密码，但他决定输入自己的密码。因为他确实输入了自己的坐骑密码，所以他不需要执行`ecryptfs-unwrap-passphrase`命令来找出密码是什么。但是，为了展示这个命令是如何工作的，假设查理输入了`TurkeyLips`作为他的挂载密码:

```sh
charlie@ubuntu2:~$ ecryptfs-unwrap-passphrase .ecryptfs/wrapped-passphrase
Passphrase:
TurkeyLips
charlie@ubuntu2:~$
```

是的，这是一个非常弱的密码短语，但对于我们的演示目的来说，它是有效的。

5.  让查理注销，然后重新登录。之后，他可以开始使用他的新私人目录。同样，你可以看到他的`home`目录中有三个新的隐藏目录。所有这三个新目录只有查理可以访问，尽管他的顶级`home`目录仍然对所有人开放:

```sh
charlie@ubuntu2:~$ ls -la
total 40
drwxr-xr-x 6 charlie charlie 4096 Oct 30 17:00 .
drwxr-xr-x 4 root root 4096 Oct 30 16:38 ..
-rw------- 1 charlie charlie 270 Oct 30 17:00 .bash_history
-rw-r--r-- 1 charlie charlie 220 Aug 31 2015 .bash_logout
-rw-r--r-- 1 charlie charlie 3771 Aug 31 2015 .bashrc
drwx------ 2 charlie charlie 4096 Oct 30 16:39 .cache
drwx------ 2 charlie charlie 4096 Oct 30 16:57 .ecryptfs
drwx------ 2 charlie charlie 4096 Oct 30 16:57 Private
drwx------ 2 charlie charlie 4096 Oct 30 16:57 .Private
-rw-r--r-- 1 charlie charlie 655 May 16 08:49 .profile
charlie@ubuntu2:~$
```

6.  在`/etc/pam.d`目录下运行`grep 'ecryptfs' *`命令。您将看到 PAM 被配置为每当用户登录到系统时自动挂载用户的加密目录:

```sh
donnie@ubuntu2:/etc/pam.d$ grep 'ecryptfs' *
common-auth:auth    optional    pam_ecryptfs.so unwrap
common-password:password    optional    pam_ecryptfs.so
common-session:session    optional    pam_ecryptfs.so unwrap
common-session-noninteractive:session    optional    pam_ecryptfs.so unwrap
donnie@ubuntu2:/etc/pam.d$
```

7.  实验室结束。

那好吧。我们现在知道如何加密用户的主目录。现在，让我们看看如何加密其他目录。

# 动手实验–用加密文件加密其他目录

加密其他目录很简单，只需用`ecryptfs`文件系统装载它们:

1.  在文件系统的顶层创建一个`secrets`目录，并对其进行加密。请注意如何列出目录名两次，因为您还需要指定一个装载点。本质上，您使用要装载的目录作为自己的装载点:

```sh
sudo mkdir /secrets
sudo mount -t ecryptfs /secrets /secrets
```

2.  输入所需的密码，并选择加密算法和密钥长度:

```sh
donnie@ubuntu2:~$ sudo mount -t ecryptfs /secrets /secrets
[sudo] password for donnie:
Passphrase:
Select cipher:
 1) aes: blocksize = 16; min keysize = 16; max keysize = 32
 2) blowfish: blocksize = 8; min keysize = 16; max keysize = 56
. . .
. . .
Selection [aes]:
Select key bytes:
 1) 16
 2) 32
 3) 24
Selection [16]:
```

默认为`aes`，键为`16`字节。

3.  对于`plaintext passthrough`，使用默认的`no`，对于文件名加密，使用`yes`:

```sh
Enable plaintext passthrough (y/n) [n]:
Enable filename encryption (y/n) [n]: y
```

4.  使用默认的`Filename Encryption Key`并验证安装选项:

```sh
Filename Encryption Key (FNEK) Signature [e339e1ebf3d58c36]:
Attempting to mount with the following options:
  ecryptfs_unlink_sigs
  ecryptfs_fnek_sig=e339e1ebf3d58c36
  ecryptfs_key_bytes=16
  ecryptfs_cipher=aes
  ecryptfs_sig=e339e1ebf3d58c36
```

5.  此警告仅在您第一次装载目录时出现。对于最后两个问题，键入`yes`以防止该警告再次出现:

```sh
WARNING: Based on the contents of [/root/.ecryptfs/sig-cache.txt],
it looks like you have never mounted with this key
before. This could mean that you have typed your
passphrase wrong.

Would you like to proceed with the mount (yes/no)? : yes
Would you like to append sig [e339e1ebf3d58c36] to
[/root/.ecryptfs/sig-cache.txt]
in order to avoid this warning in the future (yes/no)? : yes
Successfully appended new sig to user sig cache file
Mounted eCryptfs
donnie@ubuntu2:~$
```

6.  只是为了好玩，在你新加密的`secrets`目录内创建一个文件，然后卸载这个目录。然后，尝试做一个目录列表:

```sh
cd /secrets
sudo vim secret_stuff.txt
cd
sudo umount /secrets
ls -l /secrets

donnie@ubuntu2:/secrets$ ls -l
total 12
-rw-r--r-- 1 root root 12288 Oct 31 18:24 ECRYPTFS_FNEK_ENCRYPTED.FXbXCS5fwxKABUQtEPlumGPaN-RGvqd13yybkpTr1eCVWVHdr-lrmi1X9Vu-mLM-A-VeqIdN6KNZGcs-
donnie@ubuntu2:/secrets$
```

通过选择加密文件名，当目录被卸载时，没有人能知道你有什么文件。当您准备好再次访问您的加密文件时，只需像以前一样重新装载目录。

# 用加密文件加密交换分区

如果您只是用加密文件加密单个目录，而不是使用 LUKS 全磁盘加密，您需要加密您的交换分区，以防止意外的数据泄漏。解决这个问题只需要一个简单的命令:

```sh
donnie@ubuntu:~$ sudo ecryptfs-setup-swap

WARNING:
An encrypted swap is required to help ensure that encrypted files are not leaked to disk in an unencrypted format.
HOWEVER, THE SWAP ENCRYPTION CONFIGURATION PRODUCED BY THIS PROGRAM WILL BREAK HIBERNATE/RESUME ON THIS SYSTEM!
NOTE: Your suspend/resume capabilities will not be affected.

Do you want to proceed with encrypting your swap? [y/N]: y

INFO: Setting up swap: [/dev/sda5]
WARNING: Commented out your unencrypted swap from /etc/fstab
swapon: stat of /dev/mapper/cryptswap1 failed: No such file or directory
donnie@ubuntu:~$
```

不要介意丢失`/dev/mapper/cryptswap1`文件的警告。它会在你下次重启机器时被创建。

# 使用 VeraCrypt 实现加密容器的跨平台共享

曾几何时，有一个跨平台的程序 TrueCrypt，它允许在不同的操作系统之间共享加密容器。但是这个项目总是被神秘所笼罩，因为它的开发者永远不会透露他们的身份。然后，开发人员突然发布了一条关于 TrueCrypt 不再安全的神秘消息，并关闭了该项目。

VeraCrypt 是 TrueCrypt 的继承者，它允许在 Linux、Windows、macOS 和 FreeBSD 机器之间共享加密容器。虽然 LUKS 和埃及的文件很好，但 VeraCrypt 确实在某些方面提供了更大的灵活性:

*   如上所述，VeraCrypt 提供跨平台共享，而 LUKS 和 eCryptfs 不提供。
*   VeraCrypt 允许您加密整个分区或整个存储设备，或者创建虚拟加密磁盘。

*   您不仅可以使用 VeraCrypt 创建加密卷，还可以隐藏它们，让您看似可信的否认。
*   VeraCrypt 有命令行和图形用户界面两种变体，因此它适合服务器使用或普通桌面用户。
*   像 LUKS 和 eCryptfs 一样，VeraCrypt 是免费的开源软件，这意味着它可以自由使用，并且源代码可以被审计错误或后门。

# 动手实验–获取和安装 VeraCrypt

按照以下步骤安装 VeraCrypt:

1.  从这里下载 VeraCrypt:
    [【https://www.veracrypt.fr/en/Downloads.html】](https://www.veracrypt.fr/en/Downloads.html)
    把文件解压到你的`home`目录。VeraCrypt 的 Linux 版本是一组通用安装脚本，应该可以在任何 Linux 发行版上运行。提取`.tar.bz2`档案文件后，您将看到两个用于图形用户界面安装的脚本和两个用于控制台模式安装的脚本。其中一个适用于 32 位 Linux，另一个适用于 64 位 Linux:

```sh
donnie@ubuntu:~$ ls -l vera*
-r-xr-xr-x 1 donnie users 2976573 Jul 9 05:10 veracrypt-1.21-setup-console-x64
-r-xr-xr-x 1 donnie users 2967950 Jul 9 05:14 veracrypt-1.21-setup-console-x86
-r-xr-xr-x 1 donnie users 4383555 Jul 9 05:08 veracrypt-1.21-setup-gui-x64
-r-xr-xr-x 1 donnie users 4243305 Jul 9 05:13 veracrypt-1.21-setup-gui-x86
-rw-r--r-- 1 donnie users 14614830 Oct 31 23:49 veracrypt-1.21-setup.tar.bz2 donnie@ubuntu:~$
```

2.  已经设置了可执行权限，所以安装时只需执行以下操作:

```sh
donnie@ubuntu:~$ ./veracrypt-1.21-setup-console-x64
```

您需要 sudo 权限，但是安装程序会提示您输入 sudo 密码。在阅读并同意一份相当长的许可协议后，安装只需几秒钟。

# 动手实验–在控制台模式下创建和安装 VeraCrypt 卷

我还没有找到 VeraCrypt 控制台模式变体的任何文档，但是您只需键入`veracrypt`，就可以看到可用命令的列表。在本演示中，您将创建一个 2 GB 的加密目录。但你也可以在其他地方轻松完成，比如在 u 盘上:

1.  要创建新的加密卷，请键入以下内容:

```sh
veracrypt -c
```

2.  这将带你进入一个易于使用的互动工具。在大多数情况下，您只需接受默认选项就可以了:

```sh
donnie@ubuntu:~$ veracrypt -c
Volume type:
 1) Normal
 2) Hidden
Select [1]:
Enter volume path: /home/donnie/good_stuff
Enter volume size (sizeK/size[M]/sizeG): 2G
Encryption Algorithm:
 1) AES
 2) Serpent
. . .
. . .
Select [1]:
. . .
. . .
```

3.  对于文件系统，`FAT`的默认选项为您提供了 Linux、macOS 和 Windows 之间的最佳跨平台兼容性:

```sh
Filesystem:
 1) None
 2) FAT
 3) Linux Ext2
 4) Linux Ext3
 5) Linux Ext4
 6) NTFS
 7) exFAT
Select [2]:
```

4.  选择您的密码和一个 **PIM** (个人****迭代** **乘数**的缩写)。为了我的个人信息管理，我输入了`8891`。高 PIM 值提供了更好的安全性，但也会导致卷的装载时间更长。然后，键入至少 320 个随机字符以生成加密密钥。让我的猫在我的键盘上走来走去会很方便:**

```sh
Enter password:
Re-enter password:

Enter PIM: 8891

Enter keyfile path [none]:

Please type at least 320 randomly chosen characters and then press Enter:
```

5.  点击*进入*键后，请耐心等待，因为加密卷的最终生成需要一些时间。在这里，您看到我的 2 GB `good_stuff`容器已经成功创建:

```sh
donnie@ubuntu:~$ ls -l good_stuff
-rw------- 1 donnie donnie 2147483648 Nov  1 17:02 good_stuff
donnie@ubuntu:~$
```

6.  安装此容器以便使用。首先创建装载点目录:

```sh
donnie@ubuntu:~$ mkdir good_stuff_dir
donnie@ubuntu:~$
```

7.  使用`veracrypt`实用程序将容器安装在该安装点上:

```sh
donnie@ubuntu:~$ veracrypt good_stuff good_stuff_dir
Enter password for /home/donnie/good_stuff:
Enter PIM for /home/donnie/good_stuff: 8891
Enter keyfile [none]:
Protect hidden volume (if any)? (y=Yes/n=No) [No]:
Enter your user password or administrator password:
donnie@ubuntu:~$
```

8.  要查看您安装了哪些 VeraCrypt 卷，请使用`veracrypt -l`:

```sh
donnie@ubuntu:~$ veracrypt -l
1: /home/donnie/secret_stuff /dev/mapper/veracrypt1 /home/donnie/secret_stuff_dir
2: /home/donnie/good_stuff /dev/mapper/veracrypt2 /home/donnie/good_stuff_dir
donnie@ubuntu:~$
```

9.  实验室结束。仅此而已。

# 在图形用户界面模式下使用 VeraCrypt

任何受支持操作系统的桌面用户都可以安装 VeraCrypt 的 GUI 变体。但是请注意，不能在同一台机器上同时安装控制台模式变体和图形用户界面变体，因为其中一个会覆盖另一个:

![](assets/fa8a5f84-dd96-41f0-8e02-adac15865998.png)

由于这本书的主要焦点是服务器安全，因此我在这里不讨论图形用户界面版本的细节。但是它相当不言自明，你可以在他们的网站上查看完整的 VeraCrypt 文档。

You can get VeraCrypt from here: [https://www.veracrypt.fr/en/Home.html](https://www.veracrypt.fr/en/Home.html).

# OpenSSL 和公钥基础设施

使用 OpenSSL，我们可以在信息通过网络时对其进行加密。在我们通过网络发送数据之前，没有必要手动加密数据，因为 OpenSSL 加密是自动进行的。这很重要，因为没有它，在线商务和银行业务就无法存在。

OpenSSL 中的**安全套接字层** ( **SSL** )是协议。具有讽刺意味的是，即使我们使用的是 OpenSSL 程序和库套件，我们也不再想使用 SSL。相反，我们现在想使用**传输层安全性** ( **TLS** )协议。SSL 充满了遗留代码以及伴随这些遗留代码而来的许多漏洞。TLS 是更新的，并且更加安全。但是，即使在使用 TLS 时，我们仍然可以使用 OpenSSL 套件。

旧的 SSL 协议如此糟糕的一个原因是因为过去的政府法规，特别是在美国，禁止使用强加密。在公共互联网的最初几年，美国网站运营商无法合法实施长度超过区区 40 位的加密密钥。即使在那个时候，40 位密钥也不能提供很好的安全性。但是美国政府认为强加密是一种弹药，并试图控制它，这样其他国家的政府就不能使用它。与此同时，一家名为 Fortify 的澳大利亚公司开始生产一种强大的加密插件，人们可以将其安装在网景浏览器中。这个插件允许使用 128 位加密，我和我的极客朋友都急切地将它安装在我们自己的机器上。回顾过去，我不确定它是否做得很好，因为美国的网站运营商仍然被禁止在他们的网络服务器上使用强加密密钥。

令人惊讶的是，防御装备仍然有他们的网站。你仍然可以下载强化插件，即使它现在完全没用了。下面的截图显示了设防网站:

![](assets/69250943-724f-496c-a8f5-7a940824b31d.png)

加密的 SSL/TLS 会话使用对称和非对称机制。为了获得可接受的性能，它使用对称加密来加密传输中的数据。但是对称加密需要在两个通信伙伴之间交换私钥。为此，SSL/TLS 首先使用我们在 GPG 一节中看到的相同公钥交换机制来协商非对称会话。一旦建立了非对称会话，两个通信伙伴就可以安全地交换用于对称会话的私钥。

# 商业认证机构

为了让这个神奇的工作，你需要安装一个安全证书到你的网络服务器上。该证书有两个目的:

*   它包含建立非对称密钥交换会话所需的公钥。

*   或者，它可以验证您的网站的身份或进行身份验证。因此，举例来说，用户可以从理论上确定他们连接到他们的真实银行，而不是乔海克的骗子和罪犯银行伪装成他们的银行。

当您购买证书时，您会发现相当多的供应商，它们都被称为证书颁发机构或 CAs。大多数 ca，包括像 Thawte、Symantec、GoDaddy 和 Let’s Encrypt 等供应商，都提供几种不同等级的证书。为了帮助解释证书等级之间的差异，这里有一个来自 GoDaddy 网站的截图:

![](assets/182fa571-66e0-4385-80a5-2d225e1de15e.png)

排名第一、价格最便宜的是标准 SSL DV 产品。供应商宣传这种类型的证书用于您真正关心的是加密的地方。身份验证仅限于域验证，这意味着是的，您站点的记录已经在公共可访问的 DNS 服务器上找到。

在底部，我们看到了高级 SSL 电动汽车产品。这是证书供应商提供的顶级证书。它目前的价格低于中级组织验证产品，但这只是因为降价 50%。有了这个证书的扩展验证等级，你必须跳过一些障碍来证明你是真实的你，你的网站和你的业务都是合法的。当您安装这种类型的证书时，您会看到高保证绿色地址栏出现在您客户的网络浏览器中。

那么，这个经过严格身份测试的高级 SSL EV 证书到底有多好呢？嗯，没有我想的那么好。今天早上，在我写完不同类型证书的解释两天后，我收到了火药味鸭出版的最新版*防弹 TLS 简讯*。最大的消息是，谷歌和 Mozilla 计划从未来版本的 Chrome 和 Firefox 中删除绿色高保证栏。他们的理由如下:

*   绿色高保证栏旨在帮助用户避免网络钓鱼攻击。但要想让它有用，用户必须注意到，高保证标准就在那里。研究表明，大多数人甚至没有注意到这一点。
*   安全研究员伊恩·卡罗尔质疑扩展验证证书的价值。作为一个实验，他能够为 Stripe，Inc .注册一个伪造的证书，这是一个合法的公司。证书供应商最终确实注意到了他们的错误并撤销了证书，但这是一开始就不应该发生的事情。
*   最重要的是，还可能用不正确的信息注册扩展验证证书。这表明验证过程没有证书供应商让我们相信的那么彻底。

但是尽管偶尔会出现这些问题，我仍然相信扩展验证证书是有用的。当我访问我的银行账户时，我喜欢相信额外的身份验证从来都不是坏事。

Something else that's rather curious is that certificate vendors market their certificates as SSL certificates. Don't be fooled, though. As long as the website owners configure their servers correctly, they'll be using the more secure TLS protocol, rather than SSL.

“让我们加密”是一个相当新的组织，其目标是确保各地的所有网站都使用加密进行设置。这是一个有价值的目标，但也带来了一个新问题。以下截图显示了“让我们加密”网站:

![](assets/0cf5ebcc-5c3d-4989-ac00-b4e12b7bf34a.png)

要从传统供应商那里获得证书，您必须使用 OpenSSL 实用程序来创建密钥和证书请求。然后，您将向证书颁发机构提交证书申请、身份证明(如果适用)和您的付款。根据您购买的证书等级，您需要等待一到几天才能获得证书。

“让我们加密”是完全免费的，您不必为了获得证书而跳圈。相反，您可以将您的网络服务器配置为在每次设置新网站时自动获取新的“让我们加密”证书。如果“让我们加密”发现您的新站点在可公开访问的 DNS 服务器上有有效记录，它将自动在您的服务器上创建并安装证书。除了必须将你的网络服务器配置为使用“让我们加密”之外，没有什么大惊小怪的。

“让我们加密”的问题是，它比扩展验证证书更容易被滥用。“让我们加密”开始运行后不久，犯罪分子就开始建立看似合法商业网站的子域。因此，人们看到网站是加密的，域名似乎是合法的，他们愉快地输入他们的凭证，而没有考虑事情。“让我们加密”对于合法目的来说既方便又有用，但也要注意它的缺点。

Before you choose a certificate vendor, do some research. Sometimes, even the big name vendors have problems. Not so long ago, Google removed Symantec from Chrome's list of trusted certificate authorities because Symantec had allegedly violated industry best practices several times. That's rather ironic, considering that Symantec has had a long history of being a trusted vendor of security products.

现在我们已经介绍了 SSL/TLS 加密的基础知识，让我们看看如何用 OpenSSL 套件实现它。

# 创建密钥、证书签名请求和证书

好消息是，不管我们在哪个 Linux 发行版上，这个过程都是一样的。不太好的消息是，OpenSSL 可能有点难学，因为它有很多子命令，每个子命令都有自己的一组选项和参数。容忍我，我会尽我所能把它分解。

# 使用 RSA 密钥创建自签名证书

当您只需要加密或进行测试时，自签名证书非常有用。自签名证书不涉及身份验证，因此您永远不想在用户需要信任的服务器上使用它们。假设我需要在投入生产之前测试我的新网站设置，我不想用真实的密钥和证书进行测试。我将用一个命令创建密钥和自签名证书:

```sh
openssl req -newkey rsa:2048 -nodes -keyout donnie-domain.key-x509 -days 365 -out donnie-domain.crt
```

细分如下:

*   `openssl`:我用的是 OpenSSL，只有我的普通用户权限。目前，我在自己的主目录中做所有事情，所以不需要 root 或 sudo 权限。
*   `req`:这是管理证书签名请求(CSR)的子命令。创建自签名证书时，OpenSSL 将创建一个临时 CSR。
*   `-newkey rsa:2048`:我正在创建一个长度为 2，048 位的 RSA 密钥对。实际上，我希望使用更长一点的东西，但是在设置 TLS 握手时，这会影响服务器性能。(同样，前面只有一个破折号。)
*   `-nodes`:这意味着我没有对即将创建的私钥进行加密。如果我要加密私钥，我必须在每次重新启动 web 服务器时输入私钥密码。
*   `-keyout donnie-domain.key-x509`:我正在创建名为`donnie-domain.key-x509`的私钥。`x509`部分表示这将用于自签名证书。
*   `-days 365`:证书一年后到期。
*   `-out donnie-domain.crt`:最后，我正在创建`donnie-domain.crt`证书。

当您运行此命令时，系统会提示您输入有关您的企业和服务器的信息。(我们一会儿就来看看。)创建这个密钥和证书后，我需要将它们移动到适当的位置，并配置我的 web 服务器来找到它们。(我们稍后也会谈到这一点。)

加密私钥是一个可选步骤，我没有这样做。如果我要加密私钥，我必须在每次重新启动 web 服务器时输入密码。如果有任何 web 服务器管理员没有密码，这可能会有问题。此外，尽管这听起来有悖直觉，但对网络服务器上的私钥进行加密并不能真正提高安全性。任何能够物理访问 web 服务器的恶意人员都可以使用内存取证工具从系统内存中获取私钥，即使密钥是加密的。但是如果你计划备份密钥以存储在其他地方，一定要加密这个副本。现在，让我们制作一个我的私钥的加密备份副本，我可以安全地存储在 web 服务器之外的其他地方:

```sh
[donnie@localhost ~]$ openssl rsa -aes256 -in donnie-domain.key-x509 -out donnie-domain-encrypted.key-x509 

writing RSA key
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
[donnie@localhost ~]$
```

这里有两件事要看:

*   `rsa -aes256`表示我正在使用 AES256 加密算法加密一个 RSA 密钥。
*   为了确保我制作了一个副本，而不是覆盖原始的未加密密钥，我指定了`donnie-domain-encrypted.key-x509`作为副本的名称。

# 使用椭圆曲线密钥创建自签名证书

RSA 密钥在当时还不错，但它们确实有缺点。(我稍后会详细介绍这一点。)**椭圆曲线** ( **EC** )键在几乎所有方面都是优越的。因此，现在让我们用一个 EC 密钥而不是 RSA 密钥创建一个自签名证书，如下所示:

```sh
openssl req -new -x509 -nodes -newkey ec:<(openssl ecparam -name secp384r1) -keyout cert.key.x509 -out cert.crt -days 3650
```

唯一不同的是`ec:<(openssl ecparam -name secp384r1)`部分。看起来很奇怪，但真的很有逻辑。创建 EC 键时，必须使用`ecparam`命令指定参数。您通常会将此视为两个独立的`openssl`命令，但是将这两个命令组合在一起作为一个命令放在另一个命令中会更方便。内部`openssl`命令通过输入重定向符号(`<`)将其输出反馈给外部`openssl`命令。`-name secp384r1`部分意味着我们正在用`secp384`命名的曲线算法创建一个 384 位 EC 密钥。

# 创建 RSA 密钥和证书签名请求

通常情况下，我们不会使用自签名证书来进行任何面向公众的交互。相反，我们希望从商业证书颁发机构获得证书，因为我们希望用户知道他们正在连接到一个服务器，其所有者的身份已经过验证。要从受信任的证书颁发机构获得证书，您首先需要创建一个密钥和一个**证书签名请求** ( **企业社会责任**)。我们现在就开始吧:

```sh
openssl req --out CSR.csr -new -newkey rsa:2048 -nodes -keyout server-privatekey.key
```

细分如下:

*   `openssl`:我用的是 OpenSSL，只有我的普通用户权限。目前，我在自己的`home`目录中做所有事情，所以不需要 root 或 sudo 权限。
*   `req`:这是管理 CSR 的子命令。
*   `--out CSR.csr`:`--out`表示我在创造什么。在这种情况下，我正在创建名为`CSR.csr`的企业社会责任。所有 CSR 都将有`.csr`文件扩展名。
*   `-new`:这是一个新的请求。(是的，这个前面有一个破折号，不像上一行的`out`前面有两个破折号。)
*   `-newkey rsa:2048`:我正在创建一个长度为 2，048 位的 RSA 密钥对。实际上，我希望使用更长一点的东西，但是在设置 TLS 握手时，这会影响服务器性能。(同样，前面只有一个破折号。)
*   `-nodes`:这意味着我没有对即将创建的私钥进行加密。如果我要加密私钥，我必须在每次重新启动 web 服务器时输入私钥密码。
*   `-keyout server-privatekey.key`:最后，我正在创建名为`server-privatekey.key`的私钥。因为这个密钥不是用于自签名证书的，所以我没有把`-x509`放在密钥文件名的末尾。

现在让我们看看命令输出的一个片段:

```sh
[donnie@localhost ~]$ openssl req --out CSR.csr -new -newkey rsa:2048 -nodes -keyout server-privatekey.key
Generating a RSA private key
. . .
. . .
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:GA
Locality Name (eg, city) [Default City]:Saint Marys
Organization Name (eg, company) [Default Company Ltd]:Tevault Enterprises
Organizational Unit Name (eg, section) []:Education
Common Name (eg, your name or your server's hostname) []:www.tevaultenterprises.com
Email Address []:any@any.net
Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:TurkeyLips
An optional company name []:

```

因此，我已经输入了关于我的公司位置、名称和网站名称的信息。注意底部，它问我要一个`challenge password`。这个密码不加密密钥或证书。相反，它只是证书颁发机构和我之间的共享秘密，嵌入到证书中。我需要把它放在一个安全的地方，以防我需要重新安装证书。(看在上帝的份上，当你真的这么做的时候，选择一个比`TurkeyLips`更好的密码。)

和以前一样，我没有加密私钥。但是，如果您需要制作备份副本，只需遵循您在上一节中看到的过程即可。

要从商业证书颁发机构获得证书，请访问他们的网站并按照他们的指导进行操作。收到证书后，将其安装在 web 服务器的适当位置，并配置 web 服务器以找到它。

# 创建电子商务密钥和企业社会责任

直到几年前，您可能还想在网络服务器上使用 RSA 密钥。它们没有某些其他密钥类型所具有的安全弱点，并且几乎每个网络浏览器都广泛支持它们。但是 RSA 密钥确实有两个弱点:

*   即使是标准的 2，048 位长度，它们也比其他密钥类型需要更多的计算能力。增加密钥长度以提高安全性会降低 web 服务器的性能。
*   RSA 不提供**完全前向保密** ( **PFS** )。换句话说，如果有人捕获了由 RSA 算法生成的会话密钥，他们将能够解密过去的材料。如果同一个人捕获由 PFS 算法产生的会话密钥，他们将只能解密当前的通信流。

使用新式的电子商务算法代替陈旧的 RSA 解决了这两个问题。但是如果你拿起几年前的一本书，你会发现它建议使用 RSA 密钥来向后兼容旧的网络浏览器。这部分是因为某些操作系统及其相关的专有网络浏览器存在的时间远远超过了它们应有的时间。(*我在看你，Windows XP* *)。*)不过，现在，当我 2020 年 1 月坐在这里写这篇文章时，我认为开始忽视那些拒绝从这些过时平台上继续前进的人的需求是安全的。我的意思是，Windows XP 在几年前就已经走到了尽头，而 Windows 7 几天前才刚刚做到。所以，让我们跟上时代，伙计们。

与我们刚才看到的 RSA 密钥不同，我们不能用一个简单的命令创建 EC 私钥和 CSR。对于 EC，我们需要分两步来完成。

首先，我将如下创建私钥:

```sh
openssl genpkey -algorithm EC -out eckey.pem -pkeyopt ec_paramgen_curve:P-384 -pkeyopt ec_param_enc:named_curve
```

细分如下:

*   `genpkey -algorithm EC`:`genpkey`命令是 OpenSSL 的一个相当新的补充，现在是创建私钥的推荐方式。在这里，我告诉它用 EC 算法创建一个密钥。
*   `-out eckey.pem`:我正在创建`eckey.pem`键，是**隐私增强邮件** ( **PEM** )格式。我在前一节中创建的 RSA 密钥也是 PEM 密钥，但是我在它们上面使用了`.key`文件扩展名。您可以使用`.key`或`.pem`文件扩展名，它们都可以工作。但是如果用`.pem`分机，每个看他们的人一眼就能看出他们是 PEM 的钥匙。
*   `-pkeyopt ec_paramgen_curve:P-384`:这告诉 OpenSSL 创建一个长度为 384 位的 EC 密钥。电子商务的一个优点是，它的较短长度的密钥提供了与较长的 RSA 密钥相同的加密强度。在本例中，我们有一个 384 位密钥，它实际上比 2，048 位 RSA 密钥更强。而且它需要更少的计算能力。(我称之为全面胜利！)
*   `-pkeyopt ec_param_enc:named_curve`:这是我对 EC 参数使用的编码方式。必须设置为`named_curve`或`explicit`。

现在，我将创建一个企业社会责任，并用我的新私钥签名，如下所示:

```sh
[donnie@localhost ~]$ openssl req -new -key eckey.pem -out eckey.csr
. . .
. . .
[donnie@localhost ~]$
```

我没有包括的输出与您在 RSA 密钥部分看到的相同。

最后的步骤和以前一样。选择一个认证中心，让他们告诉你如何提交企业社会责任。当他们颁发证书时，将其安装在您的 web 服务器上。

# 创建内部认证中心

当你在一个公众需要信任的网站上与公众打交道时，从商业认证机构购买证书是件好事。但是对于一个组织自己的内部使用来说，购买商业证书并不总是必要或可行的。假设您的组织有一组开发人员，他们需要自己的客户端证书来访问开发服务器。为每个开发人员购买商业证书的成本很高，并且需要开发服务器有一个可公开访问的域名，以便商业 CA 可以进行域验证。即使是免费的“让我们加密证书”也不是一个好的选择，因为这也需要开发服务器有一个可公开访问的域名。选项 2 是使用自签名证书。但这是行不通的，因为客户端身份验证不适用于自签名证书。这就剩下选项 3，建立一个私有的内部 CA。

如果你在网上搜索，你会发现很多关于建立自己的私人认证中心的指南。但是几乎所有的都已经过时了，而且大多数都是为了用 OpenSSL 建立一个证书颁发机构。对 CA 使用 OpenSSL 没有错，只是设置它是一个相当复杂的多阶段过程。然后，当您最终设置好它时，您必须从命令行使用复杂的命令来完成任何事情。我们想要的是对你和你的用户都更友好的东西。

# 实践实验室-设置狗牌认证中心

Dogtag PKI 的设置要简单得多，而且它有一个很好的 web 界面，这是 OpenSSL 所没有的。它可以在 Debian/Ubuntu 和 CentOS 的普通存储库中找到，但是使用不同的包名。在 Debian/Ubuntu 存储库中，包名是`dogtag-pki`。在 CentOS 存储库中，名称是`pki-ca`。(因为一些我不明白的原因，你永远不会看到红帽人使用“狗牌”这个名字。)

在安装 Dogtag 包之前，我们需要做几件简单的事情:

*   在服务器上设置一个**全限定域名** ( **FQDN** )
*   要么在本地 DNS 服务器中为 Dogtag 服务器创建一条记录，要么在其自己的`/etc/hosts`文件中为其创建一个条目

这个过程理论上应该可以在我们的 Ubuntu 或者 CentOS 虚拟机上运行。但是 Dogtag 依赖于拥有一个工作正常的 Tomcat Java 小程序服务器，我无法在 Ubuntu 上正常工作。因此，我们将在 CentOS 7 机器上进行此操作。(在撰写本文时，Dogtag 包还不在 CentOS 8 存储库中。)要访问 Dogtag 仪表板，我们将使用安装了桌面环境的第二个 Linux 虚拟机。做完这些，让我们开始吧:

1.  在 CentOS 虚拟机上，设置一个 FQDN，用您自己的代替我正在使用的:

```sh
sudo hostnamectl set-hostname donnie-ca.local
```

2.  编辑`/etc/hosts`文件，添加如下一行:

```sh
192.168.0.53 donnie-ca.local
```

使用虚拟机自己的 IP 地址和 FQDN。

3.  接下来，增加系统一次可以打开的文件描述符的数量。(否则，当您运行目录服务器安装程序时，您将收到一条警告消息。)通过编辑`/etc/security/limits.conf`文件来完成。在文件的末尾，添加这两行:

```sh
root            hard    nofile          4096
root            soft    nofile          4096
```

4.  重新启动计算机，以便新的主机名和文件描述符限制可以生效。
5.  Dogtag 将其证书和用户信息存储在 LDAP 数据库中。在这一步中，我们将安装 LDAP 服务器包以及 Dogtag 包。对于 CentOS 7，运行以下命令:

```sh
sudo yum install 389-ds-base pki-ca
```

6.  接下来，创建一个 LDAP **目录服务器** ( **DS** )实例。接受默认值，除非提示您创建密码。要启动该过程，请使用以下命令:

```sh
sudo setup-ds.pl
```

7.  最后，是时候创建 CA 了:

```sh
sudo pkispawn
```

接受所有的默认值，直到你到达最后。当它询问开始安装时？，键入`Yes`。当您到达 DS 部件时，输入您在上一步中用来创建 DS 实例的密码。请注意，您可以选择通过安全端口访问 LDAP DS 实例。但是因为我们在同一台机器上设置了 LDAP 和 Dogtag，所以这不是必需的。另外，通过选择 2。典型设置选项在运行设置脚本时，您将创建一个使用 2048 位 RSA 密钥进行自身身份验证的证书颁发机构，如`/etc/pki/default.cfg`文件中所指定的。尽管 384 位 EC 密钥更好，但这对于内部局域网上的大多数用例来说已经足够好了。

8.  接下来，启用`dirsrv.target`和`pki-tomcatd.target`，这样当您重新启动服务器时，它们将自动启动:

```sh
sudo systemctl enable dirsrv.target
sudo systemctl enable pki-tomcatd.target
```

9.  您将通过端口`8443/tcp`访问 Dogtag 网络界面。按照以下步骤打开端口:

```sh
sudo firewall-cmd --permanent --add-port=8443/tcp
sudo firewall-cmd --reload
```

10.  在另一台具有桌面界面的 Linux 虚拟机上，编辑`/etc/hosts`文件，以添加您在 s *步骤 2* 中添加到服务器`hosts`文件的同一行。然后，打开该机器上的 Firefox 网络浏览器，导航到 Dogtag 仪表板。与此场景中的示例一致，网址如下:

```sh
https://donnie-ca.local:8443
```

您将收到证书无效的警告，因为它是自签名的。这很正常，因为每个 CA 都必须从自签名证书开始，而您还没有将此证书导入到您的信任存储中。暂时添加例外并继续。(换句话说，清除“永久添加”框中的复选标记。你会在下一个实验室看到原因。)点击链接，直到到达此屏幕:

![](assets/ffb5efe9-a54a-4133-83e8-6d2e3b8e48dc.png)

11.  单击 SSL 最终用户服务链接。这是最终用户可以请求各种类型证书的地方。单击后退按钮返回上一屏幕。这一次，单击代理服务链接。您将无法前往那里，因为它要求您在您的 web 浏览器中安装证书进行身份验证。
12.  您需要安装的证书在您的 Dogtag VM 的`/root/.dogtag/pki-tomcat`目录中。将此文件复制到您正在使用火狐访问 Dogtag 仪表板的虚拟机上。请执行以下操作:

```sh
sudo su -
cd /root/.dogtag/pki-tomcat
scp ca_admin_cert.p12 donnie@192.168.0.14:
exit
```

当然，替换你自己的用户名和 IP 地址。请注意，该文件将自动驻留在您自己的 X 目录中，并且其所有权将从 root 更改为您自己的用户名。

13.  在装有火狐的虚拟机上，将证书导入火狐。从火狐菜单中，选择首选项，然后选择隐私和安全。在屏幕底部，单击查看证书。单击底部的导入按钮。导航到您的`home`目录，选择您刚刚从 Dogtag 服务器虚拟机发送过来的证书。导入操作完成后，您应该会在导入的证书列表中看到 PKI Administrator 证书:

![](assets/841ded9d-2273-458a-a3e8-3cef14c172fe.png)

14.  现在尝试访问代理服务页面。一旦您确认要使用刚刚导入的证书，您将被允许访问。
15.  实验室结束。

当用户需要申请自己使用的证书时，他们将使用`openssl`来创建密钥和企业社会责任，正如我在本章前面已经向您展示的那样。然后，他们将转到 SSL 最终用户服务页面，并将他们的企业社会责任的内容粘贴到他们请求的证书框中。然后，管理员将转到“代理服务”页面来批准请求并颁发证书。(为了帮助您熟悉 Dogtag，我鼓励您点击网页界面，探索所有选项。)

# 向操作系统添加证书颁发机构

大多数主要的网络浏览器，如火狐、Chrome 和 Chrome，都自带预定义的可信 ca 数据库及其相关证书。创建私有证书颁发机构时，需要将证书颁发机构证书导入浏览器的信任存储中。否则，您的用户将不断收到关于他们正在查看的网站如何使用不可信证书的消息。事实上，我们的 Dogtag 服务器就是这种情况。任何访问它以请求证书的用户都会收到一条关于证书颁发机构如何使用不可信证书的警告。我们将通过从 Dogtag 服务器导出 CA 证书并将其导入到您所有用户的浏览器中来解决这个问题。我们开始吧，好吗？

# 动手实验–导出和导入 Dogtag CA 证书

Dogtag 门户网站没有这个选项，所以我们必须使用命令行:

1.  在 Dogtag 服务器的`home`目录中，创建`password.txt`文件。在文件的第一行，插入服务器证书的密码。(这是运行`pkispawn`命令时设置的密码。)
2.  提取服务器密钥和证书，如下所示:

```sh
sudo pki-server ca-cert-chain-export --pkcs12-file pki-server.p12 --pkcs12-password-file password.txt
```

运行`ls -l`命令，验证`pki-server.p12`文件是否已创建。

3.  `p12`文件的问题在于，它既包含服务器的私钥，也包含其证书。但是要将证书添加到浏览器可信存储的 CA 部分，您必须只有证书而没有密钥。像这样提取证书:

```sh
openssl pkcs12 -in pki-server.p12 -clcerts -nokeys -out pki-server.crt
```

4.  把这个新的`pki-server.crt`文件转移到一个有图形桌面的机器上。在火狐中，打开首选项/隐私&安全。单击底部的查看证书按钮。单击授权选项卡并导入新证书。选择信任此证书颁发机构以识别网站，选择信任此证书颁发机构以识别电子邮件用户:

![](assets/7986c05f-b3a7-465e-8618-0ae846cc645c.png)

5.  关闭 Firefox，然后再次打开它，以确保证书生效。导航到 Dogtag 门户。这一次，您不应该收到任何关于使用不可信证书的警告消息。
6.  实验室结束。

# 将证书颁发机构导入窗口

无论您运行的是哪种操作系统，使用 Firefox 还是 Chrome，您都可以将证书颁发机构证书直接导入浏览器的信任存储中。但是如果你在一个名为视窗的非品牌操作系统上运行微软自己的专有浏览器，那么你需要将证书导入到视窗信任存储中，而不是浏览器中。幸运的是，这非常容易做到。将证书复制到 Windows 机器后，只需打开 Windows 文件资源管理器，双击证书文件。然后，单击弹出对话框中的安装证书按钮。如果您的组织运行的是活动目录域，只需让一名广告管理员为您将其导入活动目录。

# OpenSSL 和 Apache 网络服务器

任何 web 服务器的默认安装都不是那么安全，所以您需要加强一点。一种方法是禁用较弱的 SSL/TLS 加密算法。一般原则适用于所有 web 服务器，但是对于我们的示例，我们将只关注 Apache。(web 服务器硬化的话题相当广泛。目前，我将把讨论限制在强化 SSL/TLS 配置上。)您可以在这一部分使用 Ubuntu 或 CentOS，但是这两个发行版的包名和配置文件是不同的。CentOS 7 和 CentOS 8 之间的配置也有所不同，因此我们也将看看它们。但是在我解释配置选项之前，我需要说一两句关于 SSL/TLS 协议的历史。

20 世纪 90 年代，网景公司的工程师发明了 SSL 协议。版本 1 从未见过天日，所以第一个发布的版本是 SSL 版本 2 (SSLv2)。SSLv2 也有它的弱点，其中许多在 SSLv3 中已经解决。在微软的坚持下，下一个版本更名为**传输层安全** ( **TLS** )版本 1 (TLSv1)。(我不知道微软为什么反对 SSL 这个名字。)目前的版本是 TLSv1.3，但是在撰写本文时，它仍然没有得到大多数企业级操作系统的广泛支持。(红帽企业版 Linux 8 及其后代是例外。)默认情况下，Apache 仍然支持一些较旧的协议。我们的目标是禁用那些旧的协议。就在几年前，由于对最新版本 1.2 的可疑浏览器支持，这意味着禁用 SSLv2 和 SSLv3，并通过 TLSv1.2 离开 TLSv1。不过，现在我认为禁用对任何比 TLSv1.2 更早版本的支持是安全的。我的意思是，如果任何人仍然运行不支持它的浏览器，那么他们就是一个受伤的单元，需要升级。

理想情况下，我只想使用 TLSv1.3，因为它确实在安全性和性能方面提供了一些重大改进。然而，就目前而言，由于缺乏某个浏览器的支持，TLSv1.2 在许多情况下是我们所能期望的最好的。大多数主要的浏览器——火狐、Chrome、Chrome 和 Opera——都支持 TLSv1.3。主要的阻碍是苹果 Safari，它仍然只支持 1.2 版本。(希望当你读到这篇文章时，情况已经有所改变。)

# 在 Ubuntu 上强化 Apache SSL/TLS

在这个演示中，我们将使用两台 Ubuntu 18.04 虚拟机。我们将在第一个上安装 Apache，在第二个上安装`sslscan`。理论上可以在 CentOS 上使用`sslscan`，但是我发现它的实现有问题，不能正常工作:

1.  要在 Ubuntu 机器上安装 Apache，只需执行以下操作:

```sh
sudo apt install apache2
```

这也安装了`mod_ssl`包，其中包含了用于 SSL/TLS 实现的库和配置文件。在撰写本文时，2020 年 1 月，Ubuntu 18.04 是当前的长期支持版本。它的 Apache 包仍然不支持最新的 TLSv1.3，尽管它的 OpenSSL 包支持。(Ubuntu 19.04 和 19.10 中的 Apache 确实支持它，但由于它们不是长期支持版本，我不能建议将其用于关键的生产用途。)当你读到这篇文章的时候，很有可能 Ubuntu 20.04 将会问世，它将是 LTS，并将完全支持 1.3 版本。

当然，如果您启用了防火墙，请确保端口`443/tcp`是打开的。

2.  Apache 服务已经启用并正在运行，因此您不必再为此伤脑筋。但是您确实需要使用这三个命令来启用默认的 SSL 站点和 SSL 模块:

```sh
sudo a2ensite default-ssl.conf
sudo a2enmod ssl
sudo systemctl restart apache2
```

3.  在我们看 SSL/TLS 配置之前，让我们设置一个扫描机来从外部测试我们的配置。在第二个 Ubuntu 虚拟机上，安装 sslscan 包:

```sh
sudo apt install sslscan

```

在扫描仪机器上，扫描安装了 Apache 的 Ubuntu 机器，替换自己机器的 IP 地址:

```sh
sslscan 192.168.0.3
```

请注意支持的算法和协议版本。您应该看到根本不支持 SSLv2 和 SSLv3，并且支持 TLSv1 到 TLSv1.2。

4.  在带有 Apache 的 Ubuntu 虚拟机上，编辑`/etc/apache2/mods-enabled/ssl.conf`文件。寻找这样一句话:

```sh
SSLProtocol all -SSLv3
```

将其更改为:

```sh
SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1
```

5.  重新启动 Apache 守护程序以使此更改生效:

```sh
sudo systemctl restart apache2
```

6.  再次扫描这台机器，并注意输出。您应该看到，较旧的 TLSv1 和 TLSv1.1 协议已被禁用。所以，恭喜你！您刚刚对 web 服务器进行了快速简单的安全升级。
7.  实验室结束。

现在，让我们来看看 RHEL 8/CentOS 8。

# 在 RHEL 8/CentOS 8 上强化阿帕奇 SSL/TLS

在本演示中，您将在 CentOS 8 虚拟机上安装 Apache 和`mod_ssl`。(与 Ubuntu 不同，您必须将这些作为两个独立的包安装。)使用您在上一实验中使用的同一扫描仪虚拟机。RHEL 8/CentOS 8 的一项新功能是，您现在可以为大多数需要加密的服务和应用程序设置系统范围的加密策略。我们在这里快速看一下，在[第 6 章](06.html)*SSH 硬化*中再次出现:

1.  在您的 CentOS 8 虚拟机上，安装 Apache 和`mod_ssl`并启动服务:

```sh
sudo dnf install httpd mod_ssl
sudo systemctl enable --now httpd
```

2.  打开防火墙上的端口`443`:

```sh
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
```

3.  从扫描虚拟机中，扫描 Apache 虚拟机:

```sh
sslscan 192.168.0.160
```

你已经看到一个很大的改进。默认情况下，不支持早于 TLSv1.2 的版本。但是你也会看到一个问题。RHEL 8 和 CentOS 8 都支持新的 TLSv1.3，但是在这些扫描结果中您看不到任何相关信息。这是因为 sslscan 尚未更新以识别 TLSv1.3。没关系，我们稍后会解决这个问题。(此外，sslscan 对于显示您可能想要禁用的旧算法仍然很有用。)

4.  接下来，在 Apache 虚拟机上，查看系统范围加密配置的状态:

```sh
sudo update-crypto-policies --show
```

你应该看到`DEFAULT`作为输出。借助`DEFAULT`，您可以获得 TLSv1.2 作为最低协议版本以及 TLSv1.3 的优点。但是您还会看到一些我们可以不用的 TLSv1.2 算法。

5.  在带有 Apache 的虚拟机上，将系统范围的加密策略设置为`FIPS`:

```sh
sudo fips-mode-setup --enable
```

**联邦信息处理标准** ( **FIPS** )是美国政府标准，规定了加密算法和监控的最低要求。如果您想与美国政府做生意，您的服务器可能需要满足 FIPS 的要求。有了 RHEL 8/CentOS 8，只需要这一个命令。

6.  重新启动 Apache 虚拟机，以便 FIPS 模式生效。然后，运行这两个命令来验证 FIPS 模式是否有效:

```sh
sudo fips-mode-setup --check
sudo update-crypto-policies --show
```

7.  重复步骤 3 。这一次，您将看到支持算法的较小列表。
8.  正如我之前提到的，sslscan 还不能识别 TLSv1.3。但是您可以使用 OpenSSL 来验证 TLSv1.3 在我们的 RHEL 8/CentOS 8 服务器上确实有效。只需对 Apache 服务器虚拟机运行以下命令:

```sh
echo | openssl s_client -connect 192.168.0.160:443
```

如果没有`echo |`部分，这个命令将创建到服务器的持久连接。我们不希望这样，而`echo |`部分阻止了它。这个命令不会显示服务器支持的全部算法列表。相反，它将向您显示它用来创建连接的算法。在底部的某个地方，您会看到您通过 TLSv1.3 连接到您的 CentOS 8 虚拟机(如果您对您的 Ubuntu 18.04 虚拟机执行相同的命令，您会看到它只使用 TLSv1.2)

9.  对一些公共网站重复*第 8 步*，看看他们在用什么算法。这里有一些建议:

```sh
echo | openssl s_client -connect google.com:443
echo | openssl s_client -connect allcoins.pw:443
```

10.  实验室结束。

除了我在这里展示的两种模式之外，还有另外两种加密策略模式。`LEGACY`模式启用一些我们不想使用的非常老的算法，除非绝对有必要支持老的客户端。但是，正如我一直说的，任何使用旧客户端的人都需要升级。还有`FUTURE`模式，它既禁用弱算法，又使用更长的密钥，更能抵抗未来更强大的硬件的破解尝试。如果需要运行`FUTURE`模式而不是`FIPS`模式，只需用以下内容替换前一实验的 *s* *步骤 5* 和 *6* :

```sh
sudo update-crypto-policies --set FUTURE

```

(注意，您将设置`FIPS`模式或`FUTURE`模式。你不会同时拥有两套。`FIPS`模式不仅仅是禁用弱算法，这就是为什么设置它的命令不同。)

# 在 RHEL 7/CentOS 7 上强化阿帕奇 SSL/TLS

好吧，我说过我们会考虑在 CentOS 7 机器上做这个。但是我将使它简短。

您将在 CentOS 7 上安装 Apache 和 mod_ssl，方法与在 CentOS 8 上相同，只是您将使用`yum`命令而不是`dnf`命令。与 CentOS 8 一样，您需要启用并启动带有`systemctl`的 Apache，但您不需要启用 ssl 站点或 ssl 模块。当然，还要确保防火墙上的端口`443`是打开的。

当您对 CentOS 7 机器进行 sslscan 时，您将看到一个非常长的支持算法列表，从 TLSv1 到 TLSv1.2。即使使用 TLSv1.2，您也会看到一些非常糟糕的事情，如下所示:

```sh
Accepted  TLSv1.2  112 bits  ECDHE-RSA-DES-CBC3-SHA        Curve P-256 DHE 256
Accepted  TLSv1.2  112 bits  EDH-RSA-DES-CBC3-SHA          DHE 2048 bits
Accepted  TLSv1.2  112 bits  DES-CBC3-SHA      
```

这些行中的`DES`和`SHA`表示我们支持使用过时的**数据加密标准** ( **DES** )和版本 1 的**安全哈希算法** ( **SHA** )。这可不好。通过编辑`/etc/httpd/conf.d/ssl.conf`文件来清除它们。寻找这两行:

```sh
SSLProtocol all -SSLv2 -SSLv3
SSLCipherSuite HIGH:3DES:!aNULL:!MD5:!SEED:!IDEA
```

将它们更改为:

```sh
SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
SSLCipherSuite HIGH:!3DES:!aNULL:!MD5:!SEED:!IDEA:!SHA
```

使用以下命令重新加载 Apache:

```sh
sudo systemctl reload httpd
```

再次扫描机器，你会发现支持的算法少了很多。(顺便说一下，新 TLSv1.3 的一个优点是它完全摆脱了这些遗留算法。)

接下来，让我们看看用户如何向服务器表明自己的身份。

# 设置相互身份验证

当您访问银行的安全网站时，您的网络浏览器要求网络服务器向浏览器进行身份验证。换句话说，浏览器要求查看网站的服务器证书，以便验证它是否有效。通过这种方式，你可以确信你登录的是银行的真实网站，而不是假冒网站。然后，您必须向 web 服务器验证自己的身份，但通常要使用用户名和密码。

如果 web 服务器被设置为允许，用户可以使用证书进行身份验证。这样，坏人就没有密码可以窃取或破解。当您将 Dogtag 的`ca_admin_cert.p12`证书导入您的网络浏览器时，您已经看到了这是如何完成的。这个证书给了你访问 Dogtag 的管理员页面的强大能力。您的普通最终用户将没有此证书，因此他们只能访问最终用户页面，在那里他们可以请求证书。

主要的网络服务器——Apache、Nginx、lighttpd 和其他一些——支持相互认证。篇幅不允许我详细介绍在服务器上设置它的细节，但无论您使用哪种服务器，文档都将涵盖它。

# 摘要

像往常一样，我们在这一章已经讲了很多内容。我们从使用 GPG 加密、签名和共享加密文件开始。然后，我们研究了加密驱动器、分区、目录和可共享容器的各种方法。之后，我们研究了如何使用 OpenSSL 创建密钥、CSr 和证书。但是由于我们不想一直使用自签名证书，并且商业证书并不总是必要的，所以我们研究了如何使用 Dogtag 设置私有 CA。我们通过寻找简单的方法来强化 Apache 网络服务器上的 TLS 配置，并触及了相互身份验证的主题。

一路上，我们有很多实践实验室。这很好，因为毕竟，闲人是魔鬼的作坊，我们当然不希望出现这种情况。

在下一章中，我们将研究强化安全外壳的方法。到时候见。

# 问题

1.  以下哪一项不是 GPG 的优势？
    A .它使用强大、难以破解的算法。
    B .很适合和不认识的人分享秘密。
    C .其公钥/私钥方案消除了共享密码的需要。
    D .你可以用它来加密不打算分享的文件，供自己个人使用。
2.  你需要给弗兰克发一条加密信息。在与 GPG 加密他的信息之前，您必须做什么才能不必共享密码？
    A .没什么。只需用您自己的私钥加密邮件。
    B .将 Frank 的私钥导入您的钥匙圈，并将您的私钥发送给 Frank。
    C .将弗兰克的公钥导入您的钥匙圈，并将您的公钥发送给弗兰克。
    D .只需将 Frank 的公钥导入您的钥匙圈即可。
    E .只需将弗兰克的私钥导入你的钥匙圈。
3.  在 Linux 系统上，以下哪一项是全磁盘加密的正确选择？T2；LUKS
4.  如果您使用 eCryptfs 加密用户的主目录，而您没有使用全磁盘加密，您还必须采取什么措施来防止敏感数据泄漏？
    A .无。
    B .确保用户使用强私钥。
    C .加密交换分区。
    D .必须在全磁盘模式下使用加密文件。
5.  在以下哪种情况下，您会使用 VeraCrypt？
    A .无论何时想要实现全盘加密。
    B .只要你只是想加密用户的主目录。
    无论何时，只要你喜欢使用专有的封闭源码加密系统。
    D .每当需要创建加密容器时，可以与 Windows、macOS 和 BSD 用户共享。
6.  以下哪两种说法是正确的？
    A .默认情况下，Ubuntu 18.04 支持 TLSv1.3\.
    B .默认情况下，在 Ubuntu 18.04 中禁用 TLSv1 和 TLSv1.1。
    C .默认情况下，在 RHEL 8/CentOS 8 中禁用 TLSv1 和 TLSv1.1。
    D .默认情况下，RHEL 8/CentOS 8 支持 TLSv1.3

7.  您需要确保您的网络浏览器信任来自 Dogtag CA 的证书。你是怎么做到的？
    A .您使用`pki-server`导出 CA 证书和密钥，然后使用`openssl pkcs12`仅提取证书。然后，将证书导入浏览器。
    B .将`ca_admin.cert`证书导入浏览器。
    C .您将`ca_admin_cert.p12`证书导入浏览器。
    D .将`snakeoil.pem`证书导入浏览器。

# 进一步阅读

关于 TLS 和 OpenSSL 的说明:

*   OpenSSL 教程 SSL 证书、私钥和 CSR 是如何工作的？:[https://phoenixnap . com/kb/OpenSSL-教程-SSL-证书-私钥-csrs](https://phoenixnap.com/kb/openssl-tutorial-ssl-certificates-private-keys-csrs)
*   OpenSSL 证书颁发机构:[https://www . semurity . com/如何设置自己的证书颁发机构-ca-use-OpenSSL/](https://www.semurity.com/how-to-setup-your-own-certificate-authority-ca-using-openssl/)
*   构建 OpenSSL 证书颁发机构:[https://devcentral . F5 . com/s/articles/building-an-OpenSSL-证书颁发机构-介绍和设计-椭圆曲线的注意事项-27720](https://devcentral.f5.com/s/articles/building-an-openssl-certificate-authority-introduction-and-design-considerations-for-elliptical-curves-27720)
*   红帽 8 中传输层安全 1.3 版本:[https://www . Red Hat . com/en/blog/transport-Layer-Security-version-13-红帽-enterprise-linux-8](https://www.redhat.com/en/blog/transport-layer-security-version-13-red-hat-enterprise-linux-8)
*   OpenSSL 架构简述:[https://www . OpenSSL . org/docs/opensslstrategicarchicture . html](https://www.openssl.org/docs/OpenSSLStrategicArchitecture.html)
*   活跃的鸭子出版社，提供关于 OpenSSL 的书籍、培训和时事通讯:[https://www.feistyduck.com/](https://www.feistyduck.com/)
*   OpenSSL“genpkey”手册页:[https://www.openssl.org/docs/man1.1.0/man1/genpkey.html](https://www.openssl.org/docs/man1.1.0/man1/genpkey.html)

电动汽车证书的问题:

*   Chrome 浏览器将 EV UI 移动到 Page Info:[https://chromium . googlesource . com/chromium/src/+/HEAD/docs/security/EV-to-Page-Info . MD](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/ev-to-page-info.md)
*   扩展验证被破坏:[https://www . cyber scoop . com/easy-fake-extended-Validation-certificates-](https://www.cyberscoop.com/easy-fake-extended-validation-certificates-)
*   以“默认城市”为位置颁发的电动汽车证书:[https://groups.google.com/forum/#!topic/Mozilla . dev . security . policy/1 resopcny 0](https://groups.google.com/forum/#!topic/mozilla.dev.security.policy/1oReSOPCNy0)
*   出具错误信息的电动汽车证书:[https://twitter.com/Scott_Helme/status/1163546360328740864](https://twitter.com/Scott_Helme/status/1163546360328740864)

免费证书的问题让我们加密证书:

*   网络罪犯滥用免费让我们加密证书:[https://www . infoworld . com/article/3019926/网络罪犯-滥用免费让我们加密证书. html](https://www.infoworld.com/article/3019926/cyber-criminals-abusing-free-lets-encrypt-certificates.html)

CA 标记:

*   如何增加 Linux 中的文件描述符数量:[https://www . tec mint . com/increment-set-open-file-limits-in-Linux/](https://www.tecmint.com/increase-set-open-file-limits-in-linux/)
*   dogg 标记 PKI wiki:https://www . dotagpki . org/wiki/PKI _ main _ page
*   将 CA 导入 Linux 和 Windows:[https://Thomas-leister . de/en/how-import-CA-root-certificate/](https://thomas-leister.de/en/how-to-import-ca-root-certificate/)
*   红帽(Dogtag)证书颁发机构文档:[https://access . RedHat . com/Documentation/en-us/red _ Hat _ Certificate _ system/9/](https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/)

RHEL 8/CentOS 8:

*   设置系统范围的加密策略:[https://access . RedHat . com/documentation/en-us/red _ hat _ enterprise _ Linux/8/html/security _ Harding/使用系统范围的加密策略 _ security-Harding](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening)**