# 扫描、审核和强化

一个常见的误解是，Linux 用户从来不需要担心恶意软件。是的，的确 Linux 比 Windows 更能抵抗病毒。但是病毒只是恶意软件的一种类型，其他类型的恶意软件也可以植入到 Linux 机器上。此外，如果您运行的服务器将与 Windows 用户共享文件，您需要确保不与他们共享任何感染病毒的文件。

虽然 Linux 系统日志文件很好，但它们并不总是很好地描述谁做了什么或谁访问了什么。可能是入侵者或内部人员试图访问他们无权访问的数据。我们真正想要的是一个好的审计系统，当人们做了他们不应该做的事情时，它会提醒我们。

此外还有法规遵从性的问题。您的组织可能不得不与一个或多个管理机构打交道，这些机构规定您如何加固服务器以抵御攻击。如果你不遵守规定，你可能会被罚款或停业。

幸运的是，我们有办法处理所有这些问题，它们并没有那么复杂。

在本章中，我们将涵盖以下主题:

*   安装和更新 ClamAV 和 maldet
*   用 ClamAV 和 maldet 扫描
*   SELinux 注意事项
*   用 Rootkit 猎人扫描 Rootkit
*   使用字符串和病毒总数执行快速恶意软件分析
*   控制审计后台程序
*   创建审核规则
*   使用`ausearch`和`aureport`实用程序搜索审计日志中的问题
*   `oscap`，用于管理和应用 OpenSCAP 策略的命令行实用程序
*   管理和应用 OpenSCAP 策略的图形用户界面工具
*   OpenSCAP 策略文件以及每个文件设计要满足的合规标准
*   在操作系统安装期间应用策略

如果你准备好了，让我们从一个基于 Linux 的病毒扫描解决方案开始。

# 技术要求

本章的代码文件可以在这里找到:[https://github . com/packt publishing/Mastering-Linux-Security-and-Harding-第二版](https://github.com/PacktPublishing/Mastering-Linux-Security-and-Hardening-Second-Edition)。

# 安装和更新 ClamAV 和 maldet

虽然我们不必太担心病毒感染我们的 Linux 机器，但我们确实需要担心与 Windows 用户共享受感染的文件。ClamAV 是一个免费的开源软件 ( **自由/开源软件**)反病毒解决方案，可以在你典型的视窗工作站上运行。附带的`freshclam`实用程序允许您更新病毒特征。

**Linux 恶意软件检测**，你会经常看到缩写为 **LMD** 或 **maldet** 的，是另一个可以与 ClamAV 一起工作的自由/开源软件反病毒程序。(为了节省打字时间，从现在开始，我只称它为 LMD 或马尔代特。)据我所知，它在任何 Linux 发行版的存储库中都不可用，但安装和配置它仍然足够简单。它的一个特点是，当它在网络的边缘入侵检测系统上看到恶意软件时，它会自动生成恶意软件检测签名。最终用户也可以提交自己的恶意软件样本。当您安装它时，您将获得一个已经启用的 systemd 服务和一个 cron 作业，它将定期更新恶意软件签名和程序本身。它与 Linux 内核的 inotify 功能一起工作，自动监控目录中已更改的文件。安装它的过程基本上是

You can get all the nitty-gritty details about LMD at [https://www.rfxn.com/projects/linux-malware-detect/](https://www.rfxn.com/projects/linux-malware-detect/).

我们将 ClamAV 和 LMD 安装在一起的原因是，正如 LMD 人自由承认的那样，ClamAV 扫描引擎在扫描大型文件集时提供了更好的性能。此外，通过将它们放在一起，ClamAV 可以使用 LMD 恶意软件签名以及它自己的恶意软件签名。

Just to be clear...
Viruses are a real problem for computers that run the Windows operating system. But, as far as anyone has been able to tell, there's no such thing as a virus that can harm a Linux-based operating system. So, the only real reason to run an antivirus solution on a Linux machine is to prevent infecting any Windows machines on your network. This means that you don't need to worry about installing an antivirus product on your Linux-based DNS servers, DHCP servers, and so forth. But, if you have a Linux-based email server, Samba server, download server, or any other Linux-based machine that shares files with Windows computers, then installing an antivirus solution is a good idea.

好了，理论到此为止。让我们把手弄脏，好吗？

# 动手实验–安装 ClamAV 和 maldet

我们将从安装 ClamAV 开始。(它在 Ubuntu 的正常存储库中，但不在 CentOS 的存储库中。对于 CentOS，您需要安装 EPEL 存储库，正如我在[第 1 章](01.html)、*在虚拟环境中运行 Linux*中向您展示的那样。)我们还会安装`wget`，用来下载 LMD。对于本实验，您可以使用 Ubuntu、CentOS 7 或 CentOS 8。让我们开始吧:

1.  以下命令将在 Ubuntu 上安装 ClamAV 和`wget`:

```
donnie@ubuntu3:~$ sudo apt install clamav wget inotify-tools
```

以下命令将在 CentOS 7 上安装 ClamAV、`inotify-tools`和`wget`:

```
[donnie@localhost ~]$ sudo yum install clamav clamav-update wget inotify-tools
```

对于 CentOS 8，请执行以下操作:

```
[donnie@localhost ~]$ sudo dnf install clamav clamav-update wget inotify-tools 
```

Note that if you chose the Minimal installation option when creating the CentOS **virtual machine** (**VM**), you may also have to install the `perl` and the `tar` packages.

对于 Ubuntu 来说，`clamav`包包含了你需要的一切。对于 CentOS，您还需要安装`clamav-update`以获取病毒更新。

其余步骤对于任何一台虚拟机都是相同的。

2.  接下来，您将下载并安装 LMD。

在这里，你会想做一些我很少告诉人们去做的事情。也就是说，您将希望登录到根用户 shell。原因是，尽管 LMD 安装程序在`sudo`上运行良好，但最终程序文件将归执行安装的用户所有，而不是由根用户所有。从根用户的 shell 执行安装为我们省去了跟踪这些文件和更改所有权的麻烦。因此，下载文件，如下所示:

```
sudo su -
wget http://www.rfxn.com/downloads/maldetect-current.tar.gz
```

现在，您将在根用户的主目录中拥有该文件。

3.  现在，提取归档文件并输入结果目录:

```
tar xzvf maldetect-current.tar.gz
cd maldetect-1.6.4/ 
```

4.  运行安装程序。安装程序完成后，将`README`文件复制到您自己的主目录中，以便您可以随时参考。(本`README`文件为 LMD 文件。)然后，从根用户的 shell 退出，回到自己的 shell:

```
root@ubuntu3:~/maldetect-1.6.4# ./install.sh
Created symlink from /etc/systemd/system/multi-user.target.wants/maldet.service to /usr/lib/systemd/system/maldet.service.
update-rc.d: error: initscript does not exist: /etc/init.d/maldet
. . .
. . .
maldet(22138): {sigup} signature set update completed
maldet(22138): {sigup} 15218 signatures (12485 MD5 | 1954 HEX | 779 YARA | 0 USER)

root@ubuntu3:~/maldetect-1.6.4# cp README /home/donnie

root@ubuntu3:~/maldetect-1.6.4# exit
logout
donnie@ubuntu3:~$

```

如您所见，安装程序会自动创建启用`maldet`服务的符号链接，并且还会自动下载和安装最新的恶意软件签名。

5.  对于 CentOS，安装程序复制到`/lib/systemd/system`目录的`maldet.service`文件有错误的 SELinux 上下文，这将阻止 maldet 启动。通过执行以下操作来更正 SELinux 上下文:

```
sudo restorecon /lib/systemd/system/maldet.service
```

您已经到达了实验室的终点–祝贺您！

# 动手实验室-配置 maldet

在以前的版本中，maldet 默认配置为自动监视和扫描用户的主目录。在当前版本中，默认情况下它只监控`/dev/shm`、`/var/tmp`和`/tmp`目录。我们将重新配置它，以便可以添加一些目录。让我们开始吧:

1.  打开`/usr/local/maldetect/conf.maldet`文件进行编辑。找到这两行:

```
default_monitor_mode="users"
# default_monitor_mode="/usr/local/maldetect/monitor_paths"
```

将它们更改为以下内容:

```
# default_monitor_mode="users"
default_monitor_mode="/usr/local/maldetect/monitor_paths"
```

2.  在文件顶部，启用电子邮件提醒，并将您的用户名设置为电子邮件地址。这两行现在应该如下所示:

```
email_alert="1"
email_addr="donnie"
```

3.  LMD 还没有被配置成将可疑文件移动到`quarantine`文件夹，我们想让它这样做。在`conf.maldet`文件的更下方，查找如下内容的行:

```
quarantine_hits="0"
```

将其更改为以下内容:

```
quarantine_hits="1"
```

You'll see a few other quarantine actions that you can configure, but, for now, this is all we need. 

4.  保存`conf.maldet`文件，因为这是我们需要对其进行的所有更改。
5.  打开`/usr/local/maldetect/monitor_paths`文件进行编辑。添加要监视的目录，如下所示:

```
/var/dev/shm
/var/tmp
/tmp
/home
/root
```

Since viruses affect Windows and not Linux, just monitor the directories with files that will be shared with Windows machines.

6.  保存文件后，启动`maldet`守护程序:

```
sudo systemctl start maldet
```

You can add more directories to the `monitor_paths` file at any time, but remember to restart the `maldet` daemon any time that you do, in order to read in the new additions.

您已经到达了实验室的终点–祝贺您！

现在，让我们谈谈如何保持 ClamAV 和 maldet 的更新。

# 更新 ClamAV 和 maldet

对于忙碌的管理员来说，好消息是，您不必做任何事情来保持这些更新，我们可以查看系统日志文件:

```
Dec 8 20:02:09 localhost freshclam[22326]: ClamAV update process started at Fri Dec 8 20:02:09 2017
Dec 8 20:02:29 localhost freshclam[22326]: Can't query current.cvd.clamav.net
Dec 8 20:02:29 localhost freshclam[22326]: Invalid DNS reply. Falling back to HTTP mode.
Dec 8 20:02:29 localhost freshclam[22326]: Reading CVD header (main.cvd):
Dec 8 20:02:35 localhost freshclam[22326]: OK
Dec 8 20:02:47 localhost freshclam[22326]: Downloading main-58.cdiff [100%]
Dec 8 20:03:19 localhost freshclam[22326]: main.cld updated (version: 58, sigs: 4566249, f-level: 60, builder: sigmgr)
. . .
. . .
Dec 8 20:04:45 localhost freshclam[22326]: Downloading daily.cvd [100%]
. . .
. . .
```

您将在 Ubuntu 日志或 CentOS 日志中看到这些相同的条目。但是，更新如何自动运行是有区别的。

在你的 Ubuntu 机器的`/etc/clamav/freshclam.conf`文件中，你会在最后看到以下几行:

```
# Check for new database 24 times a day
Checks 24
DatabaseMirror db.local.clamav.net
DatabaseMirror database.clamav.net
```

所以，本质上，这意味着在 Ubuntu 上，ClamAV 将每小时检查一次更新。

在您的 CentOS 机器上，您将在`/etc/cron.d`目录中看到一个`clamav-update` cron 作业，如下所示:

```
## Adjust this line...
MAILTO=root

## It is ok to execute it as root; freshclam drops privileges and becomes
## user 'clamupdate' as soon as possible
0  */3 * * * root /usr/share/clamav/freshclam-sleep
```

左边第二列的`*/3`表示 ClamAV 每 3 小时检查一次更新。如果你愿意，你可以改变它，但是你也需要改变`/etc/sysconfig/freshclam`文件中的设置。

假设您希望 CentOS 每小时也检查 ClamAV 更新。在 cron 作业文件中，将`*/3`更改为`*`。(不需要做`*/1`，因为那个位置的星号本身就已经表示工作每小时运行一次。)然后，在`/etc/sysconfig/freshclam`文件中，查找这一行:

```
# FRESHCLAM_MOD=
```

取消对该行的注释，并添加更新之间所需的分钟数。要将其设置为 1 小时，以便与 cron 作业匹配，它将如下所示:

```
FRESHCLAM_MOD=60
```

为了证明`maldet`正在被更新，你可以在`/usr/local/maldetect/logs/`目录中查看它自己的日志文件。在`event_log`文件中，您将看到以下消息:

```
Dec 06 22:06:14 localhost maldet(3728): {sigup} performing signature update check...
Dec 06 22:06:14 localhost maldet(3728): {sigup} local signature set is version 2017070716978
Dec 06 22:07:13 localhost maldet(3728): {sigup} downloaded https://cdn.rfxn.com/downloads/maldet.sigs.ver
Dec 06 22:07:13 localhost maldet(3728): {sigup} new signature set (201708255569) available
Dec 06 22:07:13 localhost maldet(3728): {sigup} downloading https://cdn.rfxn.com/downloads/maldet-sigpack.tgz
. . .
. . .
Dec 06 22:07:43 localhost maldet(3728): {sigup} unpacked and installed maldet-clean.tgz
Dec 06 22:07:43 localhost maldet(3728): {sigup} signature set update completed
Dec 06 22:07:43 localhost maldet(3728): {sigup} 15218 signatures (12485 MD5 | 1954 HEX | 779 YARA | 0 USER)
Dec 06 22:14:55 localhost maldet(4070): {scan} signatures loaded: 15218 (12485 MD5 | 1954 HEX | 779 YARA | 0 USER)
```

在`/usr/local/maldetect/conf.maldet`文件中，您会看到这两行，但中间有一些注释:

```
autoupdate_signatures="1"

autoupdate_version="1"
```

LMD 不仅会自动更新其恶意软件签名，还会确保您拥有最新版本的 LMD。

# 用 ClamAV 和 maldet 扫描

LMD 的 maldet 守护程序会持续监控您在`/usr/local/maldetect/monitor_paths`文件中指定的目录。当它在我的主目录中找到时。幸运的是，这比听起来容易，因为我们

**European Institute for Computer Antivirus Research **(**EICAR**) provides a virus signature that you can include in a plaintext file. You can get it at [http://2016.eicar.org/86-0-Intended-use.html](http://2016.eicar.org/86-0-Intended-use.html).

要创建模拟病毒文件，请转到我在前面链接中列出的页面。

向下滚动到页面底部，直到在文本框中看到这一行文本:

```
X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
```

复制这一行文本，并将其插入一个文本文件，然后保存到任一虚拟机的主目录中。(你想叫什么都可以，但我就叫我的`testing.txt`。)稍等片刻，您应该会看到文件消失。然后，查看`/usr/local/maldetect/logs/event_log`文件，验证 LMD 是否将文件移至隔离区:

```
Dec 09 19:03:43 localhost maldet(7192): {quar} malware quarantined from '/home/donnie/testing.txt' to '/usr/local/maldetect/quarantine/testing.txt.89513558'
```

LMD 还有比我在这里能给你看的更多的东西。但是，您可以在附带的`README`文件中阅读所有相关内容。

# SELinux 注意事项

过去，在红帽类型的系统上进行防病毒扫描会触发 SELinux 警报。但是，在这一章的校对过程中，扫描都正常进行，SELinux 从来没有打扰过我。所以，它

如果您确实在病毒扫描中生成了任何 SELinux 警报，您只需更改一个布尔值就可以修复它:

```
[donnie@localhost ~]$ getsebool -a | grep 'virus'
antivirus_can_scan_system --> off
antivirus_use_jit --> off
[donnie@localhost ~]$
```

这里让我们感兴趣的是`antivirus_can_scan_system`布尔值，默认情况下是关闭的。要打开它以启用病毒扫描，只需执行以下操作:

```
[donnie@localhost ~]$ sudo setsebool -P antivirus_can_scan_system on
[sudo] password for donnie:

[donnie@localhost ~]$ getsebool antivirus_can_scan_system
antivirus_can_scan_system --> on
[donnie@localhost ~]$
```

这应该可以解决任何与 SELinux 相关的扫描问题。但是，就目前的情况来看，你可能不需要担心。

# 用 Rootkit 猎人扫描 Rootkit

Rootkits 是非常讨厌的恶意软件，肯定会毁了你的一天。他们可以监听主人的命令，窃取敏感数据并发送给主人，或者为主人提供一个方便的后门。它们被设计成隐形的，能够隐藏在普通人的视线之外。有时，他们会用自己的安装了木马的版本来替换实用程序 su as ls 或 ps，显示系统上的所有文件或进程，但与 rootkit 相关的文件或进程除外。Rootkits 可以感染任何操作系统，甚至是我们钟爱的 Linux。

为了植入 rootkit，攻击者必须已经获得了系统的管理权限。这就是为什么当我看到人们从根用户的 shell 中完成所有工作时，我总是畏缩不前的原因之一，也是为什么我坚决主张尽可能使用 sudo 的原因之一。我是说，真的，我们为什么要让坏人逍遥法外？

Several years ago, back in the dark days of Windows XP, Sony Music got into a bit of trouble when someone discovered that they had planted a rootkit on their music CDs. They didn't mean to do anything malicious, but only wanted to stop people from using their computers to make illegal copies. Of course, most people ran Windows XP with an administrator account, which made it really easy for the rootkit to infect their computers. Windows users still mostly run with administrator accounts, but they at least now have User Access Control to help mitigate these types of problems.

有几个不同的程序扫描 rootkits，两者的使用方式基本相同。我们现在要看的这个叫做 Rootkit Hunter。

Allow me to emphasize that in order to plant a rootkit on a Linux machine, an attacker has to have already gained root user privileges. So, the best way to deal with rootkits is to prevent them by ensuring that only trusted, authorized personnel have root privileges.

好吧，我们去实验室吧。

# 动手实验–安装和更新 Rootkit Hunter

对于 Ubuntu 来说，Rootkit Hunter 在正常的存储库中。对于 CentOS，您需要安装 EPEL 存储库，正如我在[第 1 章](01.html)*中向您展示的那样，在虚拟环境*中运行 Linux。对于两个 Linux 发行版，包名都是`rkhunter`。让我们开始吧:

1.  根据需要，使用以下命令之一安装 Rootkit Hunter。对于 Ubuntu，请执行以下操作:

```
sudo apt install rkhunter 
```

对于 CentOS 7，请执行以下操作:

```
sudo yum install rkhunter 
```

对于 CentOS 8，请执行以下操作:

```
sudo dnf install rkhunter 
```

2.  安装后，您可以使用以下命令查看其选项:

```
man rkhunter
```

3.  接下来您需要做的是使用`--update`选项更新 rootkit 签名:

```
[donnie@localhost ~]$ sudo rkhunter --update
[ Rootkit Hunter version 1.4.4 ]
Checking rkhunter data files...
 Checking file mirrors.dat [ Updated ]
 Checking file programs_bad.dat [ Updated ]
 Checking file backdoorports.dat [ No update ]
 Checking file suspscan.dat [ Updated ]
 Checking file i18n/cn [ No update ]
 Checking file i18n/de [ Updated ]
 Checking file i18n/en [ Updated ]
 Checking file i18n/tr [ Updated ]
 Checking file i18n/tr.utf8 [ Updated ]
 Checking file i18n/zh [ Updated ]
 Checking file i18n/zh.utf8 [ Updated ]
 Checking file i18n/ja [ Updated ]
```

4.  现在，我们准备扫描。

您已经到达了实验室的终点–祝贺您！

# 扫描 rootkits

要运行扫描，请使用`-c`选项。(那是`-c`检查。)要有耐心，因为这需要一段时间:

```
sudo rkhunter -c
```

当您以这种方式运行扫描时，Rootkit Hunter 会定期停止并要求您点击*进入*键继续。扫描完成后，您会在`/var/log`目录中找到一个`rkhunter.log`文件。

要让 Rootkit Hunter 作为 cron 作业自动运行，您需要使用`--cronjob`选项，该选项将使程序一直运行，而不会提示您继续按下*回车*键。您可能还想使用`--rwo`选项，这将导致程序只报告警告，而不是报告所有好的事情。从命令行看，该命令如下所示:

```
sudo rkhunter -c --cronjob --rwo
```

要创建每晚自动运行 Rootkit Hunter 的 cron 作业，请打开 root 用户的 crontab 编辑器:

```
sudo crontab -e -u root
```

假设你想每晚 10 点 20 分运行 Rootkit Hunter。将此输入 crontab 编辑器:

```
20 22 * * * /usr/bin/rkhunter -c --cronjob --rwo
```

由于 cron 只使用 24 小时制，您必须将晚上 10:00 表示为 22 点。(只需在您习惯使用的正常下午时钟时间上增加 12 秒。)三个星号表示作业将分别在每月、每月和每周的每一天运行。您需要列出该命令的整个路径；否则，cron 将无法找到它。

你会在`rkhunter`手册页上找到更多可能让你感兴趣的选项，但这应该足以让你继续下去。

接下来，让我们看几个分析恶意软件的快速技术。

# 使用字符串和病毒总数执行快速恶意软件分析

恶意软件分析是我在这里无法详细介绍的高级主题之一。但是，我可以向您展示几种快速分析可疑文件的方法。

# 用字符串分析文件

可执行文件中经常嵌入文本字符串。您可以使用字符串实用程序来查看这些字符串。(是啊，有道理，对吧？)根据您的发行版本，字符串可能已经安装，也可能尚未安装。它已经在 CentOS 上运行了，但是要在 Ubuntu 上运行，您需要安装`binutils`包，如下所示:

```
sudo apt install binutils
```

举个例子，我们来看看这个`Your File Is Ready To Download_2285169994.exe`文件，它是从一个加密硬币水龙头网站自动下载的。(如果你想自己玩这个，你可以从 Packt Publishing 网站下载的代码文件中找到这个。)要检查文件，请执行以下操作:

```
strings "Your File Is Ready To Download_2285169994.exe" > output.txt
vim output.txt

```

我把输出保存到了一个可以在`vim`打开的文本文件中，这样就可以查看行号了。要查看行号，请使用`vim`屏幕底部的`:set number`。(用`vim`的说法，我们用的是最后一行模式。)

很难说到底要搜索什么，所以你只需要浏览一下，直到你看到一些有趣的东西。在这种情况下，看看我从第`386`行开始发现了什么:

```
386 The Setup program accepts optional command line parameters.
387 /HELP, /?
388 Shows this information.
389 /SP-
390 Disables the This will install... Do you wish to continue? prompt at the beginning of Setup.
391 /SILENT, /VERYSILENT
392 Instructs Setup to be silent or very silent.
393 /SUPPRESSMSGBOXES
394 Instructs Setup to suppress message boxes.
. . .
399 /NOCANCEL
400 Prevents the user from cancelling during the installation process.
. . .
```

据说这个程序的安装过程可以做成在`SILENT`模式下运行，不会弹出任何对话框。也可以让它以用户无法取消安装的方式运行。当然，最上面一行写着这些是`optional command line parameters`。但是，它们真的是可选的，还是硬编码为默认的？不清楚，但在我看来，任何可以在`SILENT`模式下运行并且不能取消的安装程序看起来都有点可疑，即使我们在谈论`optional`参数。

Okay, so you're probably wondering, *What is a cryptocoin faucet?* Well, it's a website where you can go to claim a small amount of cryptocoin, such as Bitcoin, Ethereum, or Monero, in exchange for viewing the advertising and solving some sort of CAPTCHA puzzle. Most faucet operators are honest, but the advertising they allow on their sites often isn't and is often laden with malware, scams, and Not-Safe-For-Work images.

现在，这个小技巧有时很有效，但不总是有效。更复杂的恶意软件可能不包含任何可以给你任何类型线索的文本字符串。那么，让我们来看看恶意软件分析的另一个小技巧。

# 使用病毒扫描恶意软件总计

病毒总量是一个网站，您可以上传可疑文件进行分析。它使用多种不同的病毒扫描程序，所以如果一个扫描程序遗漏了什么，另一个很可能会发现它。以下是扫描`Your File Is Ready To Download_2285169994.exe`文件的结果:

![](assets/55c9a8f7-390e-4e5a-bf9a-37cb9478a998.png)

在这里，我们可以看到不同的病毒扫描程序以不同的方式对该文件进行分类。但是是否归类为 Win。恶意软件。安装核心，木马。InstallCore，或者别的什么，还是不好。

As good as VirusTotal is, you'll want to use it with caution. Don't upload any files that contain sensitive or confidential information, because it will get shared with other people.

那么，这个特定的恶意软件是关于什么的呢？嗯，其实是假的 Adobe Flash 安装程序。当然，您不想通过在生产 Windows 机器上安装来测试它。但是，如果你手边有一个视窗虚拟机，你可以在上面测试恶意软件。(或者在开始之前制作虚拟机的快照，或者准备在之后丢弃虚拟机。)

正如我在开头所说的，恶意软件分析是一个相当深入的话题，有很多更复杂的程序可以用来分析它。然而，如果你对某件事有所怀疑，只需要做一个快速检查，这两个技巧可能就是你所需要的。

接下来，让我们看看如何自动审计系统的不同事件。

# 了解审计后台程序

因此，您有一个目录，其中充满了只有极少数人需要查看的超级机密文件，您想知道未经授权的人何时试图查看这些文件。或者，您可能想知道某个文件何时被更改，或者您想知道人们何时登录系统，以及他们登录后在做什么。对于所有这些和更多，你有审计系统。这是一个非常酷的系统，我想你会喜欢的。

One of the beauties of auditd is that it works at the Linux kernel level, rather than at the user-mode level. This makes it much harder for attackers to subvert.

在红帽型系统上，默认情况下安装并启用 auditd。所以，你会发现它已经在你的 CentOS 机器上了。在 Ubuntu 上，它不会被安装，所以你必须自己安装:

```
sudo apt install auditd
```

在 Ubuntu 上，你可以用普通的`systemctl`命令控制审计守护进程。因此，如果您需要重新启动 auditd 以读入新配置，您可以通过以下方式实现:

```
sudo systemctl restart auditd
```

在 RHEL/CentOS 7 和 8 上，由于一些我不理解的原因，auditd 被配置为不能使用正常的`systemctl`命令。(对于所有其他守护程序，它们都是如此。)因此，在您的 CentOS 7/8 机器上，您将使用老式的`service`命令重新启动 auditd 守护程序，如下所示:

```
sudo service auditd restart
```

除了这个微小的区别，我告诉你的关于审计的一切都将适用于 Ubuntu 和 CentOS。

# 创建审核规则

好吧，让我们从一些简单的事情开始，然后一步步走向一些令人敬畏的事情。首先，让我们检查是否有任何审计规则生效:

```
[donnie@localhost ~]$ sudo auditctl -l
[sudo] password for donnie:
No rules
[donnie@localhost ~]$
```

如您所见，`auditctl`命令是我们用来管理审核规则的。`-l`选项列出了规则。

# 审核文件的更改

现在，假设我们希望看到有人更改`/etc/passwd`文件。(我们将使用的命令看起来有点令人生畏，但我保证，一旦我们分解它，它就会有意义。)下面是:

```
[donnie@localhost ~]$ sudo auditctl -w /etc/passwd -p wa -k passwd_changes
[sudo] password for donnie:

[donnie@localhost ~]$ sudo auditctl -l
-w /etc/passwd -p wa -k passwd_changes
[donnie@localhost ~]$
```

细分如下:

*   `-w`:这个代表在哪里，指向我们要监控的对象。这种情况下就是`/etc/passwd`。
*   `-p`:表示我们要监控的对象的权限。在这种情况下，我们正在监视是否有人试图写入文件或试图进行属性更改。(我们可以审核的另外两个权限是(r)ead 和 e(x)ecute。)
*   `-k`:`k`代表 key，这只是 auditd 为规则指定名称的方式。所以，`passwd_changes`是我们正在创造的规则的关键，或者说名字。

`auditctl -l`命令告诉我们规则确实存在。

现在，这个小问题是，这个规则只是暂时的，当我们重新启动机器时，它就会消失。为了使其永久化，我们需要在`/etc/audit/rules.d/`目录中创建一个自定义`rules`文件。然后，当您重新启动 auditd 守护程序时，自定义规则将被插入到`/etc/audit/audit.rules`文件中。因为`/etc/audit/`目录只能由具有 root 权限的人访问，所以我将通过列出文件的完整路径来打开文件，而不是试图进入目录:

```
sudo less /etc/audit/audit.rules
```

这个默认文件中没有太多内容:

```
## This file is automatically generated from /etc/audit/rules.d
-D
-b 8192
-f 1

```

这是这个文件的细目:

*   `-D`:这将导致当前生效的所有规则和手表被删除，这样我们就可以从头开始了。因此，如果我现在重新启动 auditd 守护程序，它将读取这个`audit.rules`文件，这将删除我刚刚创建的规则。
*   `-b 8192`:这设置了我们一次可以拥有的未完成审计缓冲区的数量。如果所有缓冲区都已满，系统将无法再生成任何审核消息。
*   `-f 1`:设置关键错误的失效模式，数值可以是`0`、`1`或`2`。`-f 0`将模式设置为静音，这意味着 auditd 不会对严重错误采取任何措施。`-f 1`，正如我们在这里看到的，告诉 auditd 只报告关键错误，而`-f 2`会导致 Linux 内核进入死机模式。根据`auditctl`手册页，任何处于高度安全环境中的人都可能希望将其更改为`-f 2`。然而，对我们来说，`-f1`是有效的。

您可以使用文本编辑器在`/etc/audit/rules.d/`目录中创建新的`rules`文件。或者，您可以将`auditctl -l`输出重定向到一个新文件，如下所示:

```
[donnie@localhost ~]$ sudo sh -c "auditctl -l > /etc/audit/rules.d/custom.rules"
[donnie@localhost ~]$ sudo service auditd restart

On Ubuntu:
sudo systemctl restart auditd 
```

由于 Bash shell 不允许我直接将信息重定向到`/etc`目录下的文件中，即使使用 sudo，我也必须使用`sudo sh -c`命令才能执行`auditctl`命令。重新启动 auditd 守护程序后，我们的`audit.rules`文件现在如下所示:

```
## This file is automatically generated from /etc/audit/rules.d
-D
-b 8192
-f 1

-w /etc/passwd -p wa -k passwd_changes
```

现在，该规则将在每次计算机重新启动时生效，并且每次您手动重新启动 auditd 守护程序时生效。

# 审核目录

维姬和克利奥帕特拉，我的灰猫和灰白色斑猫，有一些超级敏感的秘密，他们需要保护。于是，我创建了`secretcats`组，并将它们添加到其中。然后，我创建了`secretcats`共享目录，并在上面设置了访问控制，正如我在[第 8 章](08.html)、*访问控制列表和共享目录管理*中向您展示的那样:

```
[donnie@localhost ~]$ sudo groupadd secretcats
[sudo] password for donnie:

[donnie@localhost ~]$ sudo usermod -a -G secretcats vicky
[donnie@localhost ~]$ sudo usermod -a -G secretcats cleopatra

[donnie@localhost ~]$ sudo mkdir /secretcats
[donnie@localhost ~]$ sudo chown nobody:secretcats /secretcats/
[donnie@localhost ~]$ sudo chmod 3770 /secretcats/

[donnie@localhost ~]$ ls -ld /secretcats/
drwxrws--T. 2 nobody secretcats 6 Dec 11 14:47 /secretcats/
[donnie@localhost ~]$
```

维姬和克利奥帕特拉想要绝对确保没有人进入他们的东西，所以他们要求我为他们的目录建立一个审计规则:

```
[donnie@localhost ~]$ sudo auditctl -w /secretcats/ -k secretcats_watch
[sudo] password for donnie:

[donnie@localhost ~]$ sudo auditctl -l
-w /etc/passwd -p wa -k passwd_changes
-w /secretcats -p rwxa -k secretcats_watch
[donnie@localhost ~]$
```

和以前一样，`-w`选项表示我们要监控的内容，而`-k`选项表示审核规则的名称。这一次，我省略了`-p`选项，因为我想监视每种类型的访问。换句话说，我希望监控任何读、写、属性更改或执行操作。(因为这是一个目录，所以当有人试图`cd`进入目录时，执行动作就会发生。)您可以在`auditctl -l`输出中看到，通过省略`-p`选项，我们现在将监控所有内容。但是，假设我只想监视有人试图`cd`进入该目录的时间。相反，我可以让规则看起来像这样:

```
sudo auditctl -w /secretcats/ -p x -k secretcats_watch
```

到目前为止很容易，对吧？

Plan carefully when you create your own custom audit rules. Auditing more files and directories than you need to can have a bit of a performance impact and could drown you in excessive information. Just audit what you really need to audit, as called for by either the scenario or what any applicable governing bodies require.

现在，让我们看一些更复杂的东西。

# 审核系统调用

创建规则来监控某人何时执行某个动作并不难，但是命令语法比我们目前看到的要复杂一些。有了这条规则，每当查理试图打开文件或试图创建文件时，我们都会收到警报:

```
[donnie@localhost ~]$ sudo auditctl -a always,exit -F arch=b64 -S openat -F auid=1006
[sudo] password for donnie:

[donnie@localhost ~]$ sudo auditctl -l
-w /etc/passwd -p wa -k passwd_changes
-w /secretcats -p rwxa -k secretcats_watch
-a always,exit -F arch=b64 -S openat -F auid=1006
[donnie@localhost ~]$
```

细分如下:

*   `-a always,exit`:这里，我们有动作和列表。`exit`部分意味着该规则将被添加到系统调用`exit`列表中。每当操作系统从系统调用中退出时，`exit`列表将用于确定是否需要生成审核事件。`always`部分是操作，这意味着在退出指定的系统调用时，将始终创建该规则的审核记录。请注意，动作和列表参数必须用逗号分隔。
*   `-F arch=b64`:使用`-F`选项构建规则字段，在这个命令中我们可以看到两个规则字段。第一个规则字段指定机器的中央处理器体系结构。`b64`表示电脑运行的是 x86_64 CPU。(不管是英特尔还是 AMD 都无所谓。)考虑到 32 位机器正在消亡，Sun 和 PowerPC 机器并不那么常见，`b64`是您现在最常看到的。
*   `-S openat`:选项`-S`指定我们要监控的系统调用。`openat`是打开或创建文件的系统调用。
*   `-F auid=1006`:第二个审核字段指定我们要监控的用户的用户 ID 号。(查理的用户 ID 号是`1006`。)

A complete explanation of system calls, or syscalls, is a bit too esoteric for our present purpose. For now, suffice it to say that a syscall happens whenever a user issues a command that requests that the Linux kernel provide a service. If you're so inclined, you can read more about syscalls at [https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/](https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/).

我在这里介绍的只是您可以使用审计规则做的许多事情中的几件。要查看更多示例，请查看`auditctl`手册页:

```
man auditctl
```

所以，现在你在想，*既然我有了这些规则，我怎么知道什么时候有人试图违反它们？*一如既往，很高兴你这么问。

# 使用 ausearch 和 aeroport

被审计的守护程序将事件记录到`/var/log/audit/audit.log`文件中。虽然你可以用`less`之类的东西直接读取文件，但你真的不想。`ausearch`和`aureport`实用程序将帮助您将文件翻译成某种有意义的语言。

# 搜索文件更改警报

让我们从查看我们创建的规则开始，每当对`/etc/passwd`文件进行更改时，该规则都会提醒我们:

```
sudo auditctl -w /etc/passwd -p wa -k passwd_changes
```

现在，让我们对文件进行更改，并查找警报消息。与其添加另一个用户，因为我已经没有我可以使用名字的猫了，我只需要使用`chfn`实用程序将联系信息添加到克利奥帕特拉条目的评论栏中:

```
[donnie@localhost etc]$ sudo chfn cleopatra
Changing finger information for cleopatra.
Name []: Cleopatra Tabby Cat
Office []: Donnie's back yard
Office Phone []: 555-5555
Home Phone []: 555-5556

Finger information changed.
[donnie@localhost etc]
```

现在，我将使用`ausearch`查找该事件可能生成的任何审核消息:

```
[donnie@localhost ~]$ sudo ausearch -i -k passwd_changes
----
type=CONFIG_CHANGE msg=audit(12/11/2017 13:06:20.665:11393) : auid=donnie ses=842 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 op=add_rule key=passwd_changes li
st=exit res=yes
----
type=CONFIG_CHANGE msg=audit(12/11/2017 13:49:15.262:11511) : auid=donnie ses=842 op=updated_rules path=/etc/passwd key=passwd_changes list=exit res=yes
[donnie@localhost ~]$
```

细分如下:

*   `-i`:这将获取任何数字数据，并尽可能将其转换为文本。在这种情况下，它获取用户的身份证号码，并将其转换为实际的用户名，在这里显示为`auid=donnie`。如果我将`-i`留在外面，用户信息将显示为`auid=1000`，这是我的用户标识号。
*   `-k passwd_changes`:这指定了我们想要查看审计消息的审计规则的关键字或名称。

在这里，您可以看到这个输出有两个部分。第一部分只显示了我创建审计规则的时间，因此我们对此不感兴趣。在第二部分中，您可以看到我何时触发了规则，但它没有显示我是如何触发的。所以，让我们用`aureport`看看它是否会给我们更多的细节:

```
[donnie@localhost ~]$ sudo aureport -i -k | grep 'passwd_changes'
1\. 12/11/2017 13:06:20 passwd_changes yes ? donnie 11393
2\. 12/11/2017 13:49:15 passwd_changes yes ? donnie 11511
3\. 12/11/2017 13:49:15 passwd_changes yes /usr/bin/chfn donnie 11512
4\. 12/11/2017 14:54:11 passwd_changes yes /usr/sbin/usermod donnie 11728
5\. 12/11/2017 14:54:25 passwd_changes yes /usr/sbin/usermod donnie 11736
[donnie@localhost ~]$
```

奇怪的是，使用`ausearch`，您必须在`-k`选项后指定您感兴趣的审核规则的名称或密钥。对于`aureport`，`-k`选项意味着您想要查看与所有审核规则关键字相关的所有日志条目。要查看特定键的日志条目，只需将输出导入`grep`。-i 选项的作用和它对 ausearch 的作用是一样的。

如您所见，`aureport`将`audit.log`文件的神秘语言解析为更容易理解的简单语言。我不确定我做了什么来生成事件 1 和 2，所以我查看了`/var/log/secure`文件，看是否能找到。我在那段时间看到了这两个条目:

```
Dec 11 13:06:20 localhost sudo: donnie : TTY=pts/1 ; PWD=/home/donnie ; USER=root ; COMMAND=/sbin/auditctl -w /etc/passwd -p wa -k passwd_changes
. . .
. . .
Dec 11 13:49:24 localhost sudo: donnie : TTY=pts/1 ; PWD=/home/donnie ; USER=root ; COMMAND=/sbin/ausearch -i -k passwd_changes

```

所以，事件 1 发生在我最初创建审核规则的时候，事件 2 发生在我执行`ausearch`操作的时候。

我必须承认第 *4* 和第 *5* 行的事件有点神秘。这两个都是在我调用`usermod`命令时创建的，它们都与我将维基和克利奥帕特拉添加到`secretcats`组的安全日志条目相关:

```
Dec 11 14:54:11 localhost sudo:  donnie : TTY=pts/1 ; PWD=/home/donnie ; USER=root ; COMMAND=/sbin/usermod -a -G secretcats vicky
Dec 11 14:54:11 localhost usermod[14865]: add 'vicky' to group 'secretcats'
Dec 11 14:54:11 localhost usermod[14865]: add 'vicky' to shadow group 'secretcats'
Dec 11 14:54:25 localhost sudo:  donnie : TTY=pts/1 ; PWD=/home/donnie ; USER=root ; COMMAND=/sbin/usermod -a -G secretcats cleopatra
Dec 11 14:54:25 localhost usermod[14871]: add 'cleopatra' to group 'secretcats'
Dec 11 14:54:25 localhost usermod[14871]: add 'cleopatra' to shadow group 'secretcats'
```

奇怪的是，将用户添加到二级组不会修改`passwd`文件。所以，我真的不知道为什么触发规则来创建第 *4* 和第 *5* 行的事件。

这就剩下第 *3* 行的事件了，这就是我使用`chfn`实际修改`passwd`文件的地方。这是`secure`的日志条目:

```
Dec 11 13:48:49 localhost sudo:  donnie : TTY=pts/1 ; PWD=/etc ; USER=root ; COMMAND=/bin/chfn cleopatra
```

因此，在所有这些事件中，第 *3* 行的事件是唯一一个`/etc/passwd`文件被实际修改的事件。

The `/var/log/secure` file that I keep mentioning here is on Red Hat-type operating systems, such as CentOS. On your Ubuntu machine, you'll see the `/var/log/auth.log` file instead.

# 搜索目录访问规则违规

在下一个场景中，我们为维姬和克利奥帕特拉创建了一个共享目录，并为其创建了一个审核规则，如下所示:

```
sudo auditctl -w /secretcats/ -k secretcats_watch
```

因此，对该目录的所有访问或尝试访问都应触发警报。首先，让 Vicky 进入`/secretcats`目录，运行一个`ls -l`命令:

```
[vicky@localhost ~]$ cd /secretcats
[vicky@localhost secretcats]$ ls -l
total 4
-rw-rw-r--. 1 cleopatra secretcats 31 Dec 12 11:49 cleopatrafile.txt
[vicky@localhost secretcats]$
```

在这里，我们可以看到克利奥帕特拉已经去过那里，并且已经创建了一个文件。(我们过一会儿再谈这个。)当一个事件触发一个审计规则时，往往会在`/var/log/audit/audit.log`文件中创建多条记录。如果你仔细查看一个事件的每条记录，你会发现每条记录都涵盖了该事件的不同方面。当我执行`ausearch`命令时，我从那一次`ls -l`操作中总共看到了五条记录。为了节省空间，我就把第一个放在这里:

```
sudo ausearch -i -k secretcats_watch | less

type=PROCTITLE msg=audit(12/12/2017 12:15:35.447:14077) : proctitle=ls --color=auto -l
type=PATH msg=audit(12/12/2017 12:15:35.447:14077) : item=0 name=. inode=33583041 dev=fd:01 mode=dir,sgid,sticky,770 ouid=nobody ogid=secretcats rdev=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=NORMAL
type=CWD msg=audit(12/12/2017 12:15:35.447:14077) :  cwd=/secretcats
type=SYSCALL msg=audit(12/12/2017 12:15:35.447:14077) : arch=x86_64 syscall=openat success=yes exit=3 a0=0xffffffffffffff9c a1=0x2300330 a2=O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC a3=0x0 items=1 ppid=10805 pid=10952 auid=vicky uid=vicky gid=vicky euid=vicky suid=vicky fsuid=vicky egid=vicky sgid=vicky fsgid=vicky tty=pts0 ses=1789 comm=ls exe=/usr/bin/ls subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch
```

我把最后一个放在这里:

```
type=PROCTITLE msg=audit(12/12/2017 12:15:35.447:14081) : proctitle=ls --color=auto -l
type=PATH msg=audit(12/12/2017 12:15:35.447:14081) : item=0 name=cleopatrafile.txt inode=33583071 dev=fd:01 mode=file,664 ouid=cleopatra ogid=secretcats rdev=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=NORMAL
type=CWD msg=audit(12/12/2017 12:15:35.447:14081) :  cwd=/secretcats
type=SYSCALL msg=audit(12/12/2017 12:15:35.447:14081) : arch=x86_64 syscall=getxattr success=no exit=ENODATA(No data available) a0=0x7fff7c266e60 a1=0x7f0a61cb9db0 a2=0x0 a3=0x0 items=1 ppid=10805 pid=10952 auid=vicky uid=vicky gid=vicky euid=vicky suid=vicky fsuid=vicky egid=vicky sgid=vicky fsgid=vicky tty=pts0 ses=1789 comm=ls exe=/usr/bin/ls subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch
```

在这两个记录中，您可以看到所采取的行动(`ls -l`)以及采取行动的人(在本例中是猫)的信息。由于这是一台 CentOS 机器，您还可以看到 SELinux 上下文信息。在第二条记录中，您还可以看到 Vicky 在执行`ls`命令时看到的文件名。

接下来，假设那个鬼鬼祟祟的查理登录并试图进入`/secretcats`目录:

```
[charlie@localhost ~]$ cd /secretcats
-bash: cd: /secretcats: Permission denied
[charlie@localhost ~]$ ls -l /secretcats
ls: cannot open directory /secretcats: Permission denied
[charlie@localhost ~]$
```

查理不是`secretcats`组的成员，也没有进入`secretcats`目录的权限。所以，他应该会触发警报信息。他实际上触发了一个由四条记录组成的记录，我将再次列出第一条和最后一条记录。这是第一个:

```
sudo ausearch -i -k secretcats_watch | less

type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14152) : proctitle=ls --color=auto -l /secretcats
type=PATH msg=audit(12/12/2017 12:32:04.341:14152) : item=0 name=/secretcats inode=33583041 dev=fd:01 mode=dir,sgid,sticky,770 ouid=nobody ogid=secretcats rdev=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=NORMAL
type=CWD msg=audit(12/12/2017 12:32:04.341:14152) :  cwd=/home/charlie
type=SYSCALL msg=audit(12/12/2017 12:32:04.341:14152) : arch=x86_64 syscall=lgetxattr success=yes exit=35 a0=0x7ffd8d18f7dd a1=0x7f2496858f8a a2=0x12bca30 a3=0xff items=1 ppid=11637 pid=11663 auid=charlie uid=charlie gid=charlie euid=charlie suid=charlie fsuid=charlie egid=charlie sgid=charlie fsgid=charlie tty=pts0 ses=1794 comm=ls exe=/usr/bin/ls subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch
```

这是最后一个:

```
type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14155) : proctitle=ls --color=auto -l /secretcats
type=PATH msg=audit(12/12/2017 12:32:04.341:14155) : item=0 name=/secretcats inode=33583041 dev=fd:01 mode=dir,sgid,sticky,770 ouid=nobody ogid=secretcats rdev=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=NORMAL
type=CWD msg=audit(12/12/2017 12:32:04.341:14155) :  cwd=/home/charlie
type=SYSCALL msg=audit(12/12/2017 12:32:04.341:14155) : arch=x86_64 syscall=openat success=no exit=EACCES(Permission denied) a0=0xffffffffffffff9c a1=0x12be300 a2=O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC a3=0x0 items=1 ppid=11637 pid=11663 auid=charlie uid=charlie gid=charlie euid=charlie suid=charlie fsuid=charlie egid=charlie sgid=charlie fsgid=charlie tty=pts0 ses=1794 comm=ls exe=/usr/bin/ls subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch
```

这里有两点需要注意。首先，试图进入目录不会触发警报。然而，使用`ls`尝试读取目录的内容确实如此。其次，注意第二条记录中显示的`Permission denied`信息。

我们将看到的最后一组警报是在克利奥帕特拉创建她的`cleopatrafile.txt`文件时创建的。此事件触发了包含 30 条记录的警报。我只给你看其中两个，第一个在这里:

```
type=PROCTITLE msg=audit(12/12/2017 11:49:37.536:13856) : proctitle=vim cleopatrafile.txt
type=PATH msg=audit(12/12/2017 11:49:37.536:13856) : item=0 name=. inode=33583041 dev=fd:01 mode=dir,sgid,sticky,770 ouid=nobody ogid=secretcats rdev=00:00 obj=unconfined_u:o
bject_r:default_t:s0 objtype=NORMAL
type=CWD msg=audit(12/12/2017 11:49:37.536:13856) :  cwd=/secretcats
type=SYSCALL msg=audit(12/12/2017 11:49:37.536:13856) : arch=x86_64 syscall=open success=yes exit=4 a0=0x5ab983 a1=O_RDONLY a2=0x0 a3=0x63 items=1 ppid=9572 pid=9593 auid=cle
opatra uid=cleopatra gid=cleopatra euid=cleopatra suid=cleopatra fsuid=cleopatra egid=cleopatra sgid=cleopatra fsgid=cleopatra tty=pts0 ses=1779 comm=vim exe=/usr/bin/vim sub
j=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch
```

第二个如下:

```
type=PROCTITLE msg=audit(12/12/2017 11:49:56.001:13858) : proctitle=vim cleopatrafile.txt
type=PATH msg=audit(12/12/2017 11:49:56.001:13858) : item=1 name=/secretcats/.cleopatrafile.txt.swp inode=33583065 dev=fd:01 mode=file,600 ouid=cleopatra ogid=secretcats rdev
=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=DELETE
type=PATH msg=audit(12/12/2017 11:49:56.001:13858) : item=0 name=/secretcats/ inode=33583041 dev=fd:01 mode=dir,sgid,sticky,770 ouid=nobody ogid=secretcats rdev=00:00 obj=unc
onfined_u:object_r:default_t:s0 objtype=PARENT
type=CWD msg=audit(12/12/2017 11:49:56.001:13858) :  cwd=/secretcats
type=SYSCALL msg=audit(12/12/2017 11:49:56.001:13858) : arch=x86_64 syscall=unlink success=yes exit=0 a0=0x15ee7a0 a1=0x1 a2=0x1 a3=0x7ffc2c82e6b0 items=2 ppid=9572 pid=9593
auid=cleopatra uid=cleopatra gid=cleopatra euid=cleopatra suid=cleopatra fsuid=cleopatra egid=cleopatra sgid=cleopatra fsgid=cleopatra tty=pts0 ses=1779 comm=vim exe=/usr/bin
/vim subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=secretcats_watch

```

可以看出，这两条消息中的第一条发生在克利奥帕特拉保存文件并退出`vim`时，因为第二条消息显示`objtype=DELETE`，她临时的`vim`交换文件被删除了。

好吧，这些都很好，但是如果这些信息太多怎么办？如果您只是想要一个由该规则触发的所有安全事件的快速稀疏列表，该怎么办？为此，我们将使用`aureport`。我们将像以前一样使用它。

首先，让我们将`aureport`输出导入`less`而不是`grep`，这样我们就可以看到列标题:

```
[donnie@localhost ~]$ sudo aureport -i -k | less

Key Report
===============================================
# date time key success exe auid event
===============================================
1\. 12/11/2017 13:06:20 passwd_changes yes ? donnie 11393
2\. 12/11/2017 13:49:15 passwd_changes yes ? donnie 11511
3\. 12/11/2017 13:49:15 passwd_changes yes /usr/bin/chfn donnie 11512
4\. 12/11/2017 14:54:11 passwd_changes yes /usr/sbin/usermod donnie 11728
5\. 12/11/2017 14:54:25 passwd_changes yes /usr/sbin/usermod donnie 11736
. . .
. . .
```

`success`列中的状态将是`yes`或`no`，这取决于用户是否能够成功执行违反规则的操作。或者，如果事件不是规则被触发的结果，它可能是一个问号。

对于查理，我们在第 *48* 行看到一个`yes`事件，第 *49* 到 *51* 行的事件都具有`no`状态。我们还可以看到，所有这些条目都是由查理使用`ls`命令触发的:

```
sudo aureport -i -k | grep 'secretcats_watch'

[donnie@localhost ~]$ sudo aureport -i -k | grep 'secretcats_watch'
6\. 12/11/2017 15:01:25 secretcats_watch yes ? donnie 11772
8\. 12/12/2017 11:49:29 secretcats_watch yes /usr/bin/ls cleopatra 13828
9\. 12/12/2017 11:49:37 secretcats_watch yes /usr/bin/vim cleopatra 13830
10\. 12/12/2017 11:49:37 secretcats_watch yes /usr/bin/vim cleopatra 13829
. . .
. . .
48\. 12/12/2017 12:32:04 secretcats_watch yes /usr/bin/ls charlie 14152
49\. 12/12/2017 12:32:04 secretcats_watch no /usr/bin/ls charlie 14153
50\. 12/12/2017 12:32:04 secretcats_watch no /usr/bin/ls charlie 14154
51\. 12/12/2017 12:32:04 secretcats_watch no /usr/bin/ls charlie 14155
[donnie@localhost ~]$
```

你可能会认为第 *48* 行的`yes`事件表明查理成功读取了`secretcats`目录的内容。为了进一步分析这一点，让我们看看每行末尾的事件编号，并将它们与我们之前的`ausearch`命令的输出相关联。您将看到事件编号`14152`到`14155`属于具有相同时间戳的记录。我们可以在每条记录的第一行看到:

```
[donnie@localhost ~]$ sudo ausearch -i -k secretcats_watch | less

type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14152) : proctitle=ls --color=auto -l /secretcats

type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14153) : proctitle=ls --color=auto -l /secretcats

type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14154) : proctitle=ls --color=auto -l /secretcats

type=PROCTITLE msg=audit(12/12/2017 12:32:04.341:14155) : proctitle=ls --color=auto -l /secretcats
```

正如我们之前提到的，这个系列的最后一个记录显示了查理的`Permission denied`，这才是真正重要的。

Space doesn't permit me to give a full explanation of each individual item in an audit log record. However, you can read about it here, in the official Red Hat documentation: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files).

# 搜索系统调用规则违规

我们创造的第三条规则是监视那个鬼鬼祟祟的查理。每当查理试图打开或创建文件时，这条规则都会提醒我们(正如我们前面提到的，`1006`是查理的用户标识号):

```
sudo auditctl -a always,exit -F arch=b64 -S openat -F auid=1006
```

即使查理在这个系统上没有做那么多，这个规则给我们的日志条目比我们预期的要多得多。我们将只看几个条目:

```
time->Tue Dec 12 11:49:29 2017
type=PROCTITLE msg=audit(1513097369.952:13828): proctitle=6C73002D2D636F6C6F723D6175746F
type=PATH msg=audit(1513097369.952:13828): item=0 name="." inode=33583041 dev=fd:01 mode=043770 ouid=99 ogid=1009 rdev=00:00 obj=unconfined_u:object_r:default_t:s0 objtype=NO
RMAL
type=CWD msg=audit(1513097369.952:13828):  cwd="/secretcats"
type=SYSCALL msg=audit(1513097369.952:13828): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=10d1560 a2=90800 a3=0 items=1 ppid=9572 pid=9592 auid=1004 u
id=1004 gid=1006 euid=1004 suid=1004 fsuid=1004 egid=1006 sgid=1006 fsgid=1006 tty=pts0 ses=1779 comm="ls" exe="/usr/bin/ls" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0
:c0.c1023 key="secretcats_watch"
```

该记录是在查理试图访问`/secretcats/`目录时生成的。所以，我们可以期待看到这个。但是，我们没想到的是，查理通过**安全外壳** ( **SSH** )登录系统时间接访问的文件记录列表非常长。这里有一个:

```
time->Tue Dec 12 11:50:28 2017
type=PROCTITLE msg=audit(1513097428.662:13898): proctitle=737368643A20636861726C6965407074732F30
type=PATH msg=audit(1513097428.662:13898): item=0 name="/proc/9726/fd" inode=1308504 dev=00:03 mode=040500 ouid=0 ogid=0 rdev=00:00 obj=unconfined_u:unconfined_r:unconfined_t
:s0-s0:c0.c1023 objtype=NORMAL
type=CWD msg=audit(1513097428.662:13898):  cwd="/home/charlie"
type=SYSCALL msg=audit(1513097428.662:13898): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=7ffc7ca1d840 a2=90800 a3=0 items=1 ppid=9725 pid=9726 auid=1
006 uid=1006 gid=1008 euid=1006 suid=1006 fsuid=1006 egid=1008 sgid=1008 fsgid=1008 tty=pts0 ses=1781 comm="sshd" exe="/usr/sbin/sshd" subj=unconfined_u:unconfined_r:unconfin
ed_t:s0-s0:c0.c1023 key=(null)
```

这里还有一个:

```
time->Tue Dec 12 11:50:28 2017
type=PROCTITLE msg=audit(1513097428.713:13900): proctitle=737368643A20636861726C6965407074732F30
type=PATH msg=audit(1513097428.713:13900): item=0 name="/etc/profile.d/" inode=33593031 dev=fd:01 mode=040755 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:bin_t:s0 objtype=
NORMAL
type=CWD msg=audit(1513097428.713:13900):  cwd="/home/charlie"
type=SYSCALL msg=audit(1513097428.713:13900): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=1b27930 a2=90800 a3=0 items=1 ppid=9725 pid=9726 auid=1006 u
id=1006 gid=1008 euid=1006 suid=1006 fsuid=1006 egid=1008 sgid=1008 fsgid=1008 tty=pts0 ses=1781 comm="bash" exe="/usr/bin/bash" subj=unconfined_u:unconfined_r:unconfined_t:s
0-s0:c0.c1023 key=(null)
```

在第一条记录中，我们可以看到查理访问了`/usr/sbin/sshd`文件。在第二个中，我们可以看到他访问了`/usr/bin/bash`文件。并不是查理选择访问那些文件。操作系统在正常的登录事件中为他访问了这些文件。因此，正如你所看到的，当你创建审计规则时，你必须小心你的愿望，因为有一个明确的危险，这个愿望可能会被批准。如果你真的需要监视某人，你会想要创建一个不会给你太多信息的规则。

在此过程中，我们不妨看看这个的`aureport`输出是什么样子的:

```
[donnie@localhost ~]$ sudo aureport -s -i | grep 'openat'
1068\. 12/12/2017 11:49:29 openat 9592 ls cleopatra 13828
1099\. 12/12/2017 11:50:28 openat 9665 sshd charlie 13887
1100\. 12/12/2017 11:50:28 openat 9665 sshd charlie 13889
1101\. 12/12/2017 11:50:28 openat 9665 sshd charlie 13890
1102\. 12/12/2017 11:50:28 openat 9726 sshd charlie 13898
1103\. 12/12/2017 11:50:28 openat 9726 bash charlie 13900
1104\. 12/12/2017 11:50:28 openat 9736 grep charlie 13901
1105\. 12/12/2017 11:50:28 openat 9742 grep charlie 13902
1108\. 12/12/2017 11:50:51 openat 9766 ls charlie 13906
1110\. 12/12/2017 12:15:35 openat 10952 ls vicky 14077
1115\. 12/12/2017 12:30:54 openat 11632 sshd charlie 14129
. . .
. . . 
```

除了查理的所作所为，我们还可以看到维基和克利奥帕特拉的所作所为。这是因为我们为`/secretcats/`目录设置的规则在维姬和克利奥帕特拉访问、查看或创建该目录中的文件时会生成`openat`事件。

# 生成身份验证报告

您可以生成用户身份验证报告，而无需定义任何审核规则。只需将`aureport`与`-au`选项开关配合使用(记住`au`，*认证的前两个字母*):

```
[donnie@localhost ~]$ sudo aureport -au
[sudo] password for donnie:
Authentication Report
============================================
# date time acct host term exe success event
============================================
1\. 10/28/2017 13:38:52 donnie localhost.localdomain tty1 /usr/bin/login yes 94
2\. 10/28/2017 13:39:03 donnie localhost.localdomain /dev/tty1 /usr/bin/sudo yes 102
3\. 10/28/2017 14:04:51 donnie localhost.localdomain /dev/tty1 /usr/bin/sudo yes 147
. . .
. . .
239\. 12/12/2017 11:50:20 charlie 192.168.0.222 ssh /usr/sbin/sshd no 13880
244\. 12/12/2017 12:10:06 cleopatra 192.168.0.222 ssh /usr/sbin/sshd no 13992
. . .
```

对于登录事件，这告诉我们用户是在本地终端登录还是通过 SSH 远程登录。要查看任何事件的详细信息，请使用带有`-a`选项的`ausearch`，后跟您在行尾看到的事件编号。(奇怪的是，`-a`选项代表一个事件。)

让我们看看查理的事件编号`14122`:

```
[donnie@localhost ~]$ sudo ausearch -a 14122
----
time->Tue Dec 12 12:30:49 2017
type=USER_AUTH msg=audit(1513099849.322:14122): pid=11632 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=pubkey acct="charlie" exe="/usr/sbin/sshd" hostname=? addr=192.168.0.222 terminal=ssh res=failed'
```

问题是这真的没有任何意义。我是为查理登录的人，我知道查理从来没有登录失败过。事实上，我们可以将其与`/var/log/secure`文件中的匹配条目关联起来:

```
Dec 12 12:30:53 localhost sshd[11632]: Accepted password for charlie from 192.168.0.222 port 34980 ssh2
Dec 12 12:30:54 localhost sshd[11632]: pam_unix(sshd:session): session opened for user charlie by (uid=0)
```

这两个条目的时间戳比`ausearch`输出的时间戳晚几秒，但这没关系。这个日志文件中没有任何内容表明查理曾经登录失败，这两个条目清楚地表明查理的登录确实是成功的。这里的教训是，当您在`ausearch`或`aureport`输出中看到一些奇怪的东西时，一定要将其与适当的身份验证日志文件中的匹配条目相关联，以便更好地了解发生了什么。(认证日志文件，我指的是红帽类系统的`/var/log/secure`和 Ubuntu 系统的`/var/log/auth.log`。其他 Linux 发行版的名称可能会有所不同。)

# 使用预定义的规则集

在您的 CentOS 7 机器的`/usr/share/doc/audit-version_number/rules`目录和您的 CentOS 8 机器的`/usr/share/doc/audit/rules`目录中，您会看到一些针对不同场景的预制规则集。一旦你在 Ubuntu 上安装了 auditd，你也会有它的审计规则，但是 Ubuntu 16.04 和 Ubuntu 18.04 的位置是不同的。在 Ubuntu 16.04 上，规则在`/usr/share/doc/auditd/examples/`目录中。在 Ubuntu 18.04 上，它们在`/usr/share/doc/auditd/examples/rules/`目录中。无论如何，一些规则集在这三个发行版中都是通用的。让我们看看 CentOS 7 机器，看看我们有什么:

```
[donnie@localhost rules]$ pwd
/usr/share/doc/audit-2.7.6/rules
[donnie@localhost rules]$ ls -l
total 96
. . .
-rw-r--r--. 1 root root 4915 Apr 19  2017 30-nispom.rules
-rw-r--r--. 1 root root 5952 Apr 19  2017 30-pci-dss-v31.rules
-rw-r--r--. 1 root root 6663 Apr 19  2017 30-stig.rules
-rw-r--r--. 1 root root 1498 Apr 19  2017 31-privileged.rules
-rw-r--r--. 1 root root  218 Apr 19  2017 32-power-abuse.rules
-rw-r--r--. 1 root root  156 Apr 19  2017 40-local.rules
-rw-r--r--. 1 root root  439 Apr 19  2017 41-containers.rules
. . .
[donnie@localhost rules]$
```

我想重点介绍的三个文件是`nispom`、`pci-dss`和`stig`文件。这三个规则集都是为了满足特定认证机构的审计标准而设计的。按照顺序，这些规则集如下:

*   `nispom`:国家工业安全计划——你会在美国国防部或其承包商那里看到这个规则集。
*   `pci-dss`:支付卡行业数据安全标准——如果你在银行或金融行业工作，或者即使你只是在经营一家接受信用卡的在线企业，你可能会非常熟悉这一点。
*   `stig`:安全技术实施指南——如果你为美国政府工作，或者可能为其他政府工作，你将处理这份指南。

要在 CentOS 7 或 CentOS 8 上使用这些规则集之一，只需将适当的文件复制到`/etc/audit/rules.d/`目录:

```
[donnie@localhost rules]$ sudo cp 30-pci-dss-v31.rules /etc/audit/rules.d
[donnie@localhost rules]$
```

在 Ubuntu 上，您会看到这三个文件是用 gzip 压缩来压缩的，尽管其他文件都不是:

```
donnie@ubuntu-ufw:/usr/share/doc/auditd/examples/rules$ ls -l
total 88
. . .
. . .
-rw-r--r-- 1 root root 506 Dec 14 2017 23-ignore-filesystems.rules
-rw-r--r-- 1 root root 1368 Dec 14 2017 30-nispom.rules.gz
-rw-r--r-- 1 root root 2105 Dec 14 2017 30-pci-dss-v31.rules.gz
-rw-r--r-- 1 root root 2171 Dec 14 2017 30-stig.rules.gz
-rw-r--r-- 1 root root 1498 Dec 14 2017 31-privileged.rules
. . .
. . .
```

因此，您需要在复制之前解压缩它们，如下所示:

```
donnie@ubuntu-ufw:/usr/share/doc/auditd/examples/rules$ sudo gunzip 30-pci-dss-v31.rules.gz

donnie@ubuntu-ufw:/usr/share/doc/auditd/examples/rules$ ls -l 30-pci-dss-v31.rules 
-rw-r--r-- 1 root root 5952 Dec 14  2017 30-pci-dss-v31.rules
donnie@ubuntu-ufw:/usr/share/doc/auditd/examples/rules$
```

复制完规则文件后，重新启动 auditd 守护程序以读入新规则。

对于红帽或 CentOS，请执行以下操作:

```
sudo service auditd restart
```

对于 Ubuntu，请执行以下操作:

```
sudo systemctl restart auditd
```

当然，这些规则集中的某个特定规则可能不适合您，或者您可能需要启用当前已禁用的规则。如果是这样，只需在文本编辑器中打开`rules`文件，并注释掉不工作的部分或取消注释需要启用的部分。

尽管 auditd 非常酷，但请记住，它只会提醒您潜在的安全漏洞。对他们来说，这无助于强化系统。

# 动手实验–使用 auditd

在本实验中，您将练习使用 auditd 的功能。让我们开始吧:

1.  仅适用于 Ubuntu，安装`auditd`:

```
sudo apt update
sudo apt install auditd
```

2.  查看当前有效的规则:

```
sudo auditctl -l
```

3.  从命令行中，创建一个临时规则来审核`/etc/passwd`文件的更改。验证规则是否有效:

```
sudo auditctl -w /etc/passwd -p wa -k passwd_changes
sudo auditctl -l

```

为莱昂内尔创建一个用户帐户。在 Ubuntu 上，执行以下操作:

```
sudo adduser lionel
```

在 CentOS 上，执行以下操作:

```
sudo useradd lionel
sudo passwd lionel
```

4.  搜索与`passwd`文件的任何更改相关的审核消息:

```
sudo ausearch -i -k passwd_changes
sudo aureport -i -k | grep 'passwd_changes'
```

5.  退出你自己的帐户，以莱昂内尔的身份登录。然后，注销莱昂内尔的账户，回到你自己的账户。
6.  进行身份验证报告:

```
sudo aureport -au
```

7.  创建`/secrets`目录并设置权限，以便只有根用户可以访问:

```
sudo mkdir /secrets
sudo chmod 700 /secrets
```

8.  创建一个监控`/secrets`目录的规则:

```
sudo auditctl -w /secrets -k secrets_watch
sudo auditctl -l
```

9.  注销您的帐户，并以莱昂内尔的身份登录。让他尝试查看`/secrets`目录中的内容:

```
ls -l /secrets
```

10.  注销莱昂内尔的账户，登录你自己的账户。查看莱昂内尔创建的警报:

```
sudo ausearch -i -k secrets_watch | less
```

11.  您现在有两个临时规则，当您重新启动机器时，它们将会消失。通过创建`custom.rules`文件使它们永久化:

```
sudo sh -c "auditctl -l > /etc/audit/rules.d/custom.rules"
```

12.  重新启动计算机，并验证规则是否仍然有效:

```
sudo auditctl -l
```

您已经到达了实验室的终点–祝贺您！

在本节中，您看了一些如何使用 auditd 的示例。接下来，我们将看看 OpenSCAP，它实际上可以修复一个不太安全的系统。

# 使用 oscap 应用 OpenSCAP 策略

**安全内容自动化协议** ( **SCAP** )由美国**国家标准与技术研究所** ( **NIST** )创建。它包括用于设置安全系统的强化指南、强化模板和基线配置指南。OpenSCAP 是一套可以用来实现 SCAP 的自由/开源软件工具。它包括以下内容:

*   可以应用于系统的安全配置文件。满足几个不同认证机构的要求有不同的配置文件。
*   安全指南有助于系统的初始设置。
*   应用安全模板的`oscap`命令行工具。
*   在有桌面界面的系统上，你有一个图形用户界面类型的工具 SCAP 工作台。

您可以在红帽或 Ubuntu 发行版上安装 OpenSCAP，但是在红帽发行版上实现要好得多。首先，当您安装红帽类型的操作系统时，您可以选择在安装过程中应用 SCAP 配置文件。用 Ubuntu 做不到。RHEL 7、RHEL 8 和 CentOS 7 配备了一套相当完整的现成配置文件。CentOS 8 附带了 CentOS 7 的配置文件，但不包括 CentOS 8。Ubuntu 18.04 附带了 Ubuntu 16.04 的过时配置文件，Ubuntu 18.04 没有。不过，没关系。我将向您展示如何为 CentOS 8 和 Ubuntu 18.04 获取合适的配置文件。

When doing initial system builds, it's desirable to follow a security checklist that's appropriate for your scenario. Then, use OpenSCAP to monitor for changes. I'll tell you more about security checklists at the end of [Chapter 14](14.html), *Security Tips and Tricks for the Busy Bee*.

好的:让我们学习如何安装 OpenSCAP，以及如何使用我们两个发行版通用的命令行实用程序。

# 安装 OpenSCAP

在您的 CentOS 机器上，假设您在操作系统安装期间没有安装 OpenSCAP，请对 CentOS 7 执行以下操作:

```
sudo yum install openscap-scanner scap-security-guide 
```

对 CentOS 8 执行以下操作:

```
sudo dnf install openscap-scanner scap-security-guide
```

在 Ubuntu 机器上执行以下操作:

```
sudo apt install python-openscap ssg-applications ssg-debderived ssg-nondebian ssg-base ssg-debian
```

# 查看配置文件

在任何一台 CentOS 机器上，您都会在`/usr/share/xml/scap/ssg/content/`目录中看到配置文件。

奇怪的是，在 Ubuntu 机器上，你会在`/usr/share/openscap/`目录中看到一些过时的 Fedora 和 RHEL 配置文件。(他们为什么在那里，我不知道。)在`/usr/share/scap-security-guide`目录中，您将看到火狐、Java 运行时环境和 Webmin 的应用程序配置文件。您还会看到 Ubuntu 操作系统的配置文件，但它们是针对 Ubuntu 16.04 的。(真的，包含 Ubuntu 18.04 的最新配置文件有那么难吗？)配置文件采用`.xml`格式，每个文件包含一个或多个可应用于系统的配置文件。例如，这里有一些来自 CentOS 7 的机器:

```
[donnie@localhost content]$ pwd
/usr/share/xml/scap/ssg/content
[donnie@localhost content]$ ls -l
total 50596
-rw-r--r--. 1 root root  6734643 Oct 19 19:40 ssg-centos6-ds.xml
-rw-r--r--. 1 root root  1596043 Oct 19 19:40 ssg-centos6-xccdf.xml
-rw-r--r--. 1 root root 11839886 Oct 19 19:41 ssg-centos7-ds.xml
-rw-r--r--. 1 root root  2636971 Oct 19 19:40 ssg-centos7-xccdf.xml
-rw-r--r--. 1 root root      642 Oct 19 19:40 ssg-firefox-cpe-dictionary.xml
. . .
-rw-r--r--. 1 root root 11961196 Oct 19 19:41 ssg-rhel7-ds.xml
-rw-r--r--. 1 root root   851069 Oct 19 19:40 ssg-rhel7-ocil.xml
-rw-r--r--. 1 root root  2096046 Oct 19 19:40 ssg-rhel7-oval.xml
-rw-r--r--. 1 root root  2863621 Oct 19 19:40 ssg-rhel7-xccdf.xml
[donnie@localhost content]$
```

CentOS 8 没有任何`centos8`配置文件，但它确实附带了`rhel8`配置文件，这些配置文件在 CentOS 上不起作用。(或者，至少 2020 年 1 月是这样，CentOS 8.0 和 CentOS 8.1 都是这样。)我们可以在这里看到`rhel8`的简介:

```
[donnie@localhost content]$ ls -l
total 5490
. . .
. . .
-rw-r--r--. 1 root root 1698 May 14 01:05 ssg-rhel8-cpe-dictionary.xml
-rw-r--r--. 1 root root 59226 May 14 01:05 ssg-rhel8-cpe-oval.xml
-rw-r--r--. 1 root root 6969395 May 14 01:05 ssg-rhel8-ds.xml
-rw-r--r--. 1 root root 1139859 May 14 01:05 ssg-rhel8-ocil.xml
-rw-r--r--. 1 root root 1941100 May 14 01:05 ssg-rhel8-oval.xml
-rw-r--r--. 1 root root 3719713 May 14 01:05 ssg-rhel8-xccdf.xml
[donnie@localhost content]$
```

使用 OpenSCAP 的命令行工具是`oscap`。在我们的 CentOS 7 机器上，让我们使用`info`开关来查看任何配置文件的信息。我们来看看`ssg-centos7-xccdf.xml`的文件:

```
[donnie@localhost content]$ sudo oscap info ssg-centos7-xccdf.xml
. . .
Profiles:
 standard
 pci-dss
 C2S
 rht-ccp
 common
 stig-rhel7-disa
 stig-rhevh-upstream
 ospp-rhel7
 cjis-rhel7-server
 docker-host
 nist-800-171-cui
. . .
```

在这里，我们可以看到这个文件包含 11 个不同的配置文件，我们可以应用于系统。其中，您可以看到`stig`和`pci-dss`的配置文件，就像我们对审计规则的配置文件一样。而且，如果你运行的是 Docker 容器，`docker-host`配置文件会非常方便。

# 获取 Ubuntu 18.04 和 CentOS 8 缺少的配置文件

所以，Ubuntu 18.04 和 CentOS 8 没有自带 OpenSCAP 配置文件。所有的希望都破灭了吗？绝对不会。事实证明，当你在 Fedora 31 机器上安装`scap-security-guide`包时，你会得到这两个发行版的配置文件。为了您的方便，我已经将这些配置文件包含在代码存档文件中，您可以从 Packt Publishing 网站下载。下载并提取该文件后，只需进入`Chapter_11`目录，将文件复制到自己虚拟机上的适当位置。

If you prefer, you can also download the Ubuntu 18.04 profiles from GitHub. Here's the link: [https://github.com/ComplianceAsCode/content/tree/master/ubuntu1804/profiles](https://github.com/ComplianceAsCode/content/tree/master/ubuntu1804/profiles).

Strangely, though, the CentOS 8 profiles aren't there.

在您的 Ubuntu 18.04 机器上，通过执行以下操作将配置文件复制到正确的位置:

```
sudo cp *.xml /usr/share/scap-security-guide/
```

在您的 CentOS 8 机器上，通过执行以下操作将配置文件复制到正确的位置:

```
sudo cp *.xml /usr/share/xml/scap/ssg/content
```

# 扫描系统

在本节中，我们将使用我们的 CentOS 7 虚拟机。

This procedure works the same for CentOS 8\. As we'll see later, Ubuntu 18.04 has a completely different set of profiles, but other than that, the procedure will still be the same.

现在，假设我们需要确保我们的系统符合支付卡行业标准。首先，我们将扫描 CentOS 机器以查看需要修复的内容(请注意，以下命令非常长，并且在打印页面上换行):

```
sudo oscap xccdf eval --profile pci-dss --results scan-xccdf-results.xml /usr/share/xml/scap/ssg/content/ssg-centos7-xccdf.xml
```

就像我们一直喜欢做的那样，让我们把它分解一下:

*   `xccdf eval`:可扩展配置清单描述格式是我们可以用来编写安全配置文件规则的语言之一。我们将使用用这种语言编写的配置文件来评估系统。
*   `--profile pci-dss`:这里我指定了要用支付卡行业-数据安全标准配置文件来评估系统。
*   `--results scan-xccdf-results.xml`:我要把扫描结果保存到这个`.xml`格式的文件中。扫描完成后，我将根据该文件创建报告。
*   `/usr/share/xml/scap/ssg/content/ssg-centos7-xccdf.xml`:这是包含`pci-dss`配置文件的文件。

随着扫描的进行，输出将被发送到屏幕和指定的输出文件。这是一个很长的项目列表，所以我只给你看其中的几个。以下是一些看起来不错的项目:

```
    Ensure Red Hat GPG Key Installed
    ensure_redhat_gpgkey_installed
    pass

    Ensure gpgcheck Enabled In Main Yum Configuration
    ensure_gpgcheck_globally_activated
    pass

    Ensure gpgcheck Enabled For All Yum Package Repositories
    ensure_gpgcheck_never_disabled
    pass

    Ensure Software Patches Installed
    security_patches_up_to_date
    notchecked
```

以下是需要修复的几个项目:

```
    Install AIDE
    package_aide_installed
    fail

    Build and Test AIDE Database
    aide_build_database
    fail

```

所以，我们安装了 GPG 加密，这很好。然而，我们没有安装 AIDE 入侵检测系统是一件坏事。

现在，我已经运行了扫描并创建了一个带有结果的输出文件，我可以构建我的报告:

```
sudo oscap xccdf generate report scan-xccdf-results.xml > scan-xccdf-results.html
```

这将从`.xml`格式文件中提取不应该被人类读取的信息，并将其传输到您可以在网络浏览器中打开的`.html`文件中。(报告说有 20 个问题需要解决，请记录在案。)

# 修复系统

因此，在我们的系统符合支付卡行业标准之前，我们有 20 个问题需要解决。让我们看看有多少`oscap`可以为我们修复:

```
sudo oscap xccdf eval --remediate --profile pci-dss --results scan-xccdf-remediate-results.xml /usr/share/xml/scap/ssg/content/ssg-centos7-xccdf.xml
```

这是我用来执行初始扫描的相同命令，除了我添加了`--remediate`选项，并且我正在将结果保存到不同的文件中。运行此命令时，您需要有一点耐心，因为修复某些问题需要下载和安装软件包。事实上，就在我键入这个的时候，`oscap`正忙着下载和安装丢失的 AIDE 入侵检测系统包。

好的，修复仍在运行，但我仍可以向您展示一些已修复的内容:

```
    Disable Prelinking
    disable_prelink
    error
    Install AIDE
    package_aide_installed
    fixed
    Build and Test AIDE Database
    aide_build_database
    fixed
    Configure Periodic Execution of AIDE
    aide_periodic_cron_checking
    fixed
    Verify and Correct File Permissions with RPM
    rpm_verify_permissions
    error

```

有几个错误是因为`oscap`无法修复的事情，但这很正常。至少你知道它们，这样你就可以自己尝试修复它们。

看看这个。你还记得在[第 2 章](02.html)、*保护用户账户*中，我是如何让你跳圈确保用户拥有定期过期的强密码的吗？通过应用这个 OpenSCAP 概要文件，您可以自动修复所有问题。以下是第一组已修复的项目:

```
    Set Password Maximum Age
    accounts_maximum_age_login_defs
    fixed

    Set Account Expiration Following Inactivity
    account_disable_post_pw_expiration
    fixed

    Set Password Strength Minimum Digit Characters
    accounts_password_pam_dcredit
    fixed

    Set Password Minimum Length
    accounts_password_pam_minlen
    fixed
```

下面是第二组已修复的项目:

```

    Set Password Strength Minimum Uppercase Characters
    accounts_password_pam_ucredit
    fixed

    Set Password Strength Minimum Lowercase Characters
    accounts_password_pam_lcredit
    fixed

    Set Deny For Failed Password Attempts
    accounts_passwords_pam_faillock_deny
    fixed

    Set Lockout Time For Failed Password Attempts
    accounts_passwords_pam_faillock_unlock_time
    fixed

```

所以，是的，OpenSCAP 非常酷，甚至命令行工具也不难使用。然而，如果您必须使用图形用户界面，我们有一个工具，我们将在接下来介绍。

# 使用 SCAP 工作台

对于安装了桌面环境的机器，我们有 SCAP 工作台。然而，如果你曾经使用过这个工具的早期版本，你可能会非常失望。事实上，工作台的早期版本非常糟糕，甚至无法使用。谢天谢地，此后情况有所改善。现在，工作台是一个相当不错的小工具。

要获得 SCAP 工作台，只需使用适当的安装命令。在 CentOS 7 上，执行以下操作:

```
sudo yum install scap-workbench 
```

在 CentOS 8 上，执行以下操作:

```
sudo dnf install scap-workbench 
```

在 Ubuntu 18.04 上，执行以下操作:

```
sudo apt install scap-workbench 
```

是啊，包名只是`scap-workbench`而不是`openscap-workbench`。我不知道为什么，但我知道如果你在寻找`openscap`包裹，你永远也找不到它。

安装后，您将在系统工具菜单下看到它的菜单项:

![](assets/1c20b799-2993-4baa-9913-413f2313f183.png)

当你第一次打开程序时，你会认为系统会要求你输入 root 或 sudo 密码。但是，它没有。我们会看看这会不会影响到我们。

您将在开始屏幕上看到的第一件事是一个下拉列表，供您选择要加载的内容类型。我将选择 CentOS7，然后单击加载内容按钮:

![](assets/b0751489-f41b-4e26-b886-ca82827ea2b7.png)

接下来，您将看到顶部面板，您可以在其中选择所需的配置文件。您还可以选择自定义配置文件，以及是在本地计算机上运行扫描还是在远程计算机上运行扫描。在底部窗格中，您将看到该配置文件的规则列表。您可以展开每个规则项来获取该规则的描述:

![](assets/20b3b5ea-335f-493a-a80c-d9542706d898.png)

现在，让我们单击“扫描”按钮，看看会发生什么:

![](assets/b579a67d-e3ec-491d-80ab-e493b5a08ea3.png)

酷！正如我所希望的，它会提示您输入 sudo 密码。除此之外，我会让你去玩它。这只是另一个图形用户界面，所以它的其余部分应该很容易理解。

接下来，我们将看看 OpenSCAP 守护程序。

# 在 Ubuntu 18.04 上使用 OpenSCAP 守护程序

OpenSCAP 守护程序目前在 Ubuntu 18.04 和 Fedora 各自的存储库中可用，但不适用于 RHEL 或 CentOS。虽然包名是`openscap-daemon`，但是还有一个命令行组件。守护进程在后台运行，不断检查您使用命令行工具创建的任何任务。命令行实用程序允许您以交互模式创建扫描任务。这比我们之前使用普通的`openscap`实用程序创建每个扫描命令要容易得多。然而，也有一些缺点:

*   要在 RHEL 或中央操作系统上安装它，你必须下载源代码并自己编译。
*   文档不是很好。
*   据说，您可以使用它来自动扫描本地主机或远程机器。然而，我无法使远程扫描选项工作。

所以，是的，目前有一些不利因素。然而，用户一直在请求这种类型的守护服务，所以 OpenSCAP 开发人员最终迫使他们这样做。对于这个演示，我已经创建了一个新的 Ubuntu 18.04 虚拟机。我已经将 Ubuntu 18.04 配置文件从代码存档文件转移到我自己的主目录中，您可以从 Packt Publishing 网站下载该文件。(您将在本章开头找到该链接。)

要安装它，只需执行以下操作:

```
sudo apt install openscap-daemon ssg-applications ssg-debderived ssg-nondebian ssg-base ssg-debian
```

安装完成后，守护程序将已经运行。接下来，我将把 Ubuntu 18.04 配置文件转移到适当的目录:

```
donnie@ubuntu4:~$ ls
ssg-ubuntu1804-cpe-dictionary.xml  ssg-ubuntu1804-ds.xml    ssg-ubuntu1804-xccdf.xml
ssg-ubuntu1804-cpe-oval.xml        ssg-ubuntu1804-ocil.xml
ssg-ubuntu1804-ds-1.2.xml          ssg-ubuntu1804-oval.xml
donnie@ubuntu4:~$ sudo cp *.xml /usr/share/scap-security-guide/
donnie@ubuntu4:~$
```

现在，您可以使用`oscapd-cli`工具为本地机器或远程机器设置扫描作业。您可以将作业配置为运行一次，或者定期运行。`oscapd-cli`手册页相当的不值钱，所以你最好的选择是咨询 OpenSCAP 网站。

You'll find documentation for `oscapd-cli` at [https://github.com/OpenSCAP/openscap-daemon/blob/master/README.md](https://github.com/OpenSCAP/openscap-daemon/blob/master/README.md).

通过创建一个*任务*开始该过程。都是互动的，所以真的只是回答一些问题。以下是开始行动的命令:

```
donnie@ubuntu4:~$ sudo oscapd-cli task-create -i
Creating new task in interactive mode
Title: Localhost scan
```

结尾的`-i`选项意味着交互。如果它不在那里，命令只会向您抛出一条愤怒的错误消息。如您所见，您需要为工作创建一个标题。在这里，您最好的选择是用您正在扫描的机器或软件包来命名作业。这样的话，我就命名为`Localhost scan`。

接下来，输入要扫描的机器的地址。要扫描本地主机，我只需点击*进入*键。然后，选择一个配置文件。我会选择数字`15`，对于 Ubuntu 18.04:

```
donnie@ubuntu4:~$ sudo oscapd-cli task-create -i
Creating new task in interactive mode
Title: Localhost scan
Target (empty for localhost): 
Found the following SCAP Security Guide content: 
 1:  /usr/share/scap-security-guide/ssg-centos5-ds.xml
 . . .
 15:  /usr/share/scap-security-guide/ssg-ubuntu1804-ds.xml
 16:  /usr/share/scap-security-guide/ssg-webmin-ds.xml
Choose SSG content by number (empty for custom content): 15
```

配置文件包含六个配置文件可供选择。

The ANSSI DAT-NT28 profiles are from the *Agence nationale de la sécurité des systèmes d’information* in France. You would think that there would be some profiles for `stig` or `pci-dss`, but there aren't.

我只选择配置文件编号`2`，对于标准系统安全配置文件:

```
Found the following possible profiles: 
 1:  Profile for ANSSI DAT-NT28 Minimal Level (id='xccdf_org.ssgproject.content_profile_anssi_np_nt28_minimal')
 2:  Standard System Security Profile for Ubuntu 18.04 (id='xccdf_org.ssgproject.content_profile_standard')
 3:  Profile for ANSSI DAT-NT28 Restrictive Level (id='xccdf_org.ssgproject.content_profile_anssi_np_nt28_restrictive')
 4:  Profile for ANSSI DAT-NT28 Average (Intermediate) Level (id='xccdf_org.ssgproject.content_profile_anssi_np_nt28_average')
 5:  Profile for ANSSI DAT-NT28 High (Enforced) Level (id='xccdf_org.ssgproject.content_profile_anssi_np_nt28_high')
 6:  (default) (id='')
Choose profile by number (empty for (default) profile): 2
```

接下来，我会选择是否做自动补救，然后设置一个时间表。目前，我会选择不做补救，因为我只想先测试一下这个。我会选择扫描`NOW`每周重复工作:

```
Online remediation (1, y or Y for yes, else no): 
Schedule: 
 - not before (YYYY-MM-DD HH:MM in UTC, empty for NOW): 
 - repeat after (hours or @daily, @weekly, @monthly, empty or 0 for no repeat): @weekly
Task created with ID '1'. It is currently set as disabled. You can enable it with `oscapd-cli task 1 enable`.
donnie@ubuntu4:~$
```

现在，我们有了任务 ID 1，我们仍然需要启用它。我们将用下面的代码来实现:

```
donnie@ubuntu4:~$ sudo oscapd-cli task 1 enable
donnie@ubuntu4:~$
```

要查看创建的任务列表，请使用`task`选项:

```
donnie@ubuntu4:~$ sudo oscapd-cli task
---+----------------+-----------+---------------------+--------
ID | Title | Target | Modified | Enabled
---+----------------+-----------+---------------------+--------
1 | Localhost scan | localhost | 2019-11-20 23:39:26 | enabled

Found 1 tasks, 1 of them enabled.
donnie@ubuntu4:~$
```

扫描完成后，您会在`/var/lib/oscapd`目录下的`results.xml`文件中找到结果。在该目录中，您将看到每个已启用任务的新编号子目录。在这些子目录中，您会看到更多带编号的子目录，每次任务运行时都有一个。`/var/lib/oscapd`目录仅对根用户可读，因此您需要转到根 shell 查看其中的内容:

```
donnie@ubuntu4:~$ sudo su -
root@ubuntu4:~# cd /var/lib/oscapd/results/
root@ubuntu4:/var/lib/oscapd/results# ls
1
root@ubuntu4:/var/lib/oscapd/results# cd 1
root@ubuntu4:/var/lib/oscapd/results/1# ls
1
root@ubuntu4:/var/lib/oscapd/results/1# cd 1
root@ubuntu4:/var/lib/oscapd/results/1/1# ls
exit_code results.xml stderr stdout
root@ubuntu4:/var/lib/oscapd/results/1/1#
```

因为我们普通人不应该阅读`.xml`文件，我们将把它转换成一个更人性化的`.html`文件，就像我们使用命令行扫描仪时一样:

```
root@ubuntu4:/var/lib/oscapd/results/1/1# ls
exit_code  results.xml  stderr  stdout
root@ubuntu4:/var/lib/oscapd/results/1/1# oscap xccdf generate report results.xml > /home/donnie/results.html

root@ubuntu4:/var/lib/oscapd/results/1/1# exit
logout
donnie@ubuntu4:~$
```

然后，只需在网络浏览器中打开文件。

如果您只想查看机器或软件是否兼容，而不必查看整个输出文件，只需使用 result 选项，后跟任务号:

```
donnie@ubuntu4:~$ sudo oscapd-cli result 1
Results of Task "Localhost scan", ID = 1

---+---------------------+--------------
ID | Timestamp | Status 
---+---------------------+--------------
1 | 2019-11-20 23:39:26 | Non-Compliant
donnie@ubuntu4:~$
```

哦，天哪，我不听话。我将不得不查看刚刚生成的报告，看看需要修复什么。一旦我查看了它，看看我是否同意它的发现，我将创建另一个任务来执行自动修复。

那么，底线是什么？好吧，OpenSCAP 守护进程是一个非常酷的概念，我喜欢它。我迫不及待地想知道 RHEL 和 CentOS 的存储库。

接下来，让我们看看选择 OpenSCAP 配置文件的一些标准。

# 选择 OpenSCAP 配置文件

所以，现在，你在说，*好吧，这都很好，但是我如何找到这些配置文件中有什么，我需要哪一个？*嗯，有几种方法。

我刚刚向您展示的第一种方法是在具有桌面界面的机器上安装 SCAP 工作台，并通读每个概要文件的所有规则的描述。

第二种方法可能会简单一点，那就是去 OpenSCAP 网站，浏览那里的文档。

You'll find information about the available OpenSCAP profiles at [https://www.open-scap.org/security-policies/choosing-policy/](https://www.open-scap.org/security-policies/choosing-policy/).

就知道选择哪种配置文件而言，有几件事需要考虑:

*   如果你在金融部门或从事在线金融交易的企业工作，那么请选择`pci-dss`档案。
*   如果你为一个政府机构工作，特别是如果是美国政府，那么按照特定机构的指示，选择`stig`档案或`nispom`档案。
*   如果这两个考虑都不适用于你的情况，那么你将只想做一些研究和规划，以便弄清楚什么是真正需要锁定的。浏览每个配置文件中的规则，并阅读 OpenSCAP 网站上的文档，以帮助您决定您需要什么。

使用红帽及其后代，您甚至可以在安装操作系统时应用策略。我们接下来看看。

# 在系统安装期间应用 OpenSCAP 配置文件

我喜欢红帽人的一点是，他们完全了解这种安全感。是的，我们可以锁定其他发行版，让它们更安全，正如我们已经看到的。但是有了红帽发行版，就简单多了。对于很多事情，红帽类型发行版的维护者已经设置了安全的默认选项，而在其他发行版上默认情况下这些选项是不安全的。(例如，红帽发行版是唯一默认锁定用户主目录的发行版。)另外，Red Hat 类型的发行版附带了工具和安装选项，有助于让忙碌、注重安全的管理员的生活变得更加轻松。

当你安装一个红帽类型的发行版时，你将有机会在操作系统安装期间应用一个 OpenSCAP 概要文件。在这里，在这个 CentOS 7 安装程序屏幕上，您将在屏幕右下角看到选择安全配置文件的选项:

![](assets/2eca6621-c9d7-45d5-8a62-dce34b1e1d38.png)

你所要做的就是点击它，然后选择你的个人资料:

![](assets/ff12b5a3-e621-415c-9aaa-38af2c213530.png)

在撰写本文时，即 2020 年 1 月，这无论对 CentOS 8.0 还是 CentOS 8.1 都不起作用。由于还没有`centos8`的简介，这个屏幕不会给你任何选择。看下面的截图就能明白我的意思了:

![](assets/aeefec30-fa82-430a-9d82-9d2fec132266.png)

是的，那里什么都没有。(我曾希望这能在 CentOS 8.1 版本中得到修复，但没有这样的运气。)但是，对于 RHEL 8，你有两个选择:

![](assets/6bb440f5-ee12-4b7f-bd0a-4cc39aef378d.png)

好了，这就差不多结束了我们对 OpenSCAP 的讨论。唯一要补充的是，尽管 OpenSCAP 很棒，但它不会做所有的事情。例如，一些安全标准要求您在它们自己独立的分区上拥有某些目录，如`/home/`或`/var/`。如果不是这样，OpenSCAP 扫描会提醒您，但它不能改变您现有的分区方案。因此，对于这样的事情，您需要从管理机构那里获得一份清单，规定您的安全要求，并在接触 OpenSCAP 之前做一些高级工作。

# 摘要

在这一章中，我们涉及了很多方面，我们看到了一些非常酷的东西。我们从查看几个防病毒扫描程序开始，这样我们就可以防止感染任何访问我们的 Linux 服务器的 Windows 机器。在*用 Rootkit Hunter 扫描 Rootkit*部分，我们看到了如何扫描那些讨厌的 Rootkit。我们还看到了几种快速检查潜在恶意文件的技术。知道如何审计系统很重要，尤其是在高安全性环境中，我们看到了如何做到这一点。最后，我们讨论了用 OpenSCAP 强化我们的系统。

在下一章中，我们将研究日志记录和日志文件安全性。到时候见。

# 问题

1.  关于 rootkits，以下哪一项是正确的？

A.它们只会感染 Windows 操作系统。
B .种植 rootkit 的目的是获得系统的 root 权限。
C .入侵者必须已经获得根特权才能种植根工具包。
脱氧核糖核酸 rootkit 不是很有害。

2.  您会使用以下哪种方法来保持`maldet`更新？

A.手动创建每天运行的 cron 作业。
B .什么都不做，因为 maldet 会自动更新自己。
C .每天运行一次操作系统的正常更新命令。
D .从命令行运行 maldet 更新实用程序。

3.  关于审计服务，以下哪一项是正确的？

A.在 Ubuntu 系统上，您需要使用服务命令停止或重新启动它。
B .在红帽型系统上，您需要使用服务命令停止或重新启动它。
C .在 Ubuntu 系统上，它已经安装好了。
D .在红帽型系统上，你需要自己安装。

4.  您需要创建一个审核规则，每当特定的人读取或创建文件时，该规则都会提醒您。在该规则中，您将使用以下哪个系统调用？

A.`openfile`T4【b .】`fileread`T5【c .】`openat`T6【d .`fileopen`

5.  auditd 服务使用哪个文件来记录审核事件？

A.`/var/log/messages`T4【b .】`/var/log/syslog`T5【c .】`/var/log/auditd/audit`T6【d .`/var/log/audit/audit.log`

6.  您需要为 auditd 创建自定义审核规则。你会把新规则放在哪里？

A.`/usr/share/audit-version_number`T4【b .】`/etc/audit`T5【c .】`/etc/audit.d/rules`T6【d .`/etc/audit/rules.d`

7.  你正在为银行的客户入口设置一个网络服务器。您可能会应用以下哪些 SCAP 配置文件？

A.Stig
b . nisom
c . PCI-DSS
d . sarbanes-oxley

8.  关于 OpenSCAP，以下哪一项是正确的？

A.它不能修复所有问题，因此在设置服务器之前，您需要使用核对表进行预先规划。
B .它可以自动修复你系统上的每一个问题。
C .它只适用于红帽型发行版。
D. Ubuntu 提供了更好的 SCAP 配置文件选择。

9.  您将使用以下哪个命令来生成用户身份验证报告？

A.`sudo ausearch -au`
B. `sudo aureport -au`
C .定义一个审核规则，然后做`sudo ausearch -au`。
D .定义一个审核规则，然后做`sudo aureport -au`。

10.  你会使用哪组 Rootkit Hunter 选项来让 Rootkit 扫描每晚自动运行？

A.`-c`T4【b .】`-c --rwo`T5【c .】`--rwo`T6【d .`-c --cronjob --rwo`

# 进一步阅读

*   如何安装和配置 maldet:[https://www . servernaobs . com/如何安装和配置-maldet-Linux-恶意软件-检测-lmd/](https://www.servernoobs.com/how-to-install-and-configure-maldet-linux-malware-detect-lmd/)
*   使用审计守护程序配置和审计 Linux 系统:[https://Linux-audit . com/配置和审计-Linux-使用审计守护程序系统/](https://linux-audit.com/configuring-and-auditing-linux-systems-with-audit-daemon/)
*   OpenSCAP 门户网站:[https://www.open-scap.org/](https://www.open-scap.org/)
*   OpenSCAP 守护程序:[https://github . com/OpenSCAP/OpenSCAP-守护程序/blob/master/README.md](https://github.com/OpenSCAP/openscap-daemon/blob/master/README.md)
*   实用 Openscap:[https://www . RedHat . com/files/summit/session-assets/2016/SL45190-实用-Openscap _ security-standard-compliance-and-reporting . pdf](https://www.redhat.com/files/summit/session-assets/2016/SL45190-practical-openscap_security-standard-compliance-and-reporting.pdf)