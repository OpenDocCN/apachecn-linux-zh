# *第 15 章*:使用 Ansible 实现工作流自动化

如果您的日常系统管理或开发工作涉及繁琐和重复的操作，**Ansible**可以帮助您运行任务，同时节省宝贵的时间。 Ansible 是一个用于自动化软件供应、配置管理和应用程序部署工作流的工具。 Ansible 最初由 Michael DeHaan 在 2012 年开发，在 2015 年被 Red Hat 收购，现在作为一个开源项目维持。

在本章中，您将学习关于 Ansible 的基本概念，以及各种实践示例。 特别地，我们将探讨以下主题:

*   引入 Ansible
*   安装 Ansible
*   使用 Ansible

# 技术要求

首先，您应该熟悉 Linux 命令行 Terminal。 Linux 的中级知识将帮助您理解本章中使用的一些复杂的实际插图。 您还应该精通使用基于 linux 的文本编辑器。 对于动手操作的示例，我们建议设置一个与我们正在使用的类似的实验室环境。 你可以在`README`文件中找到相关的说明，这些说明包含在本书的 GitHub 存储库的补充资源中。

如果您没有配置实验室环境，您仍然可以从本章中与实际示例相关的详细解释中获益。

现在，让我们从介绍关于 Ansible 的入门概念开始我们的旅程。

# 介绍 Ansible

在本章开篇的一段中，我们抓住了 Ansible 的一个重要方面——它是一种自动化工作流的工具。 几乎任何 Linux 系统管理任务都可以使用 Ansible 实现自动化。 使用 Ansible CLI，我们可以调用简单的命令来更改系统的**所需状态**。 通常，使用 Ansible，我们在一个远程主机或一组主机上执行任务。

让我们使用包管理的经典示例。 假设你正在管理一个基础设施，其中包括一组 web 服务器，你计划在所有这些服务器上安装一个最新版本的 web 服务器应用程序(Nginx 或 Apache)。 完成这项任务的一种方法是通过 SSH 进入每个主机，并运行相关的 shell 命令来安装最新的 web 服务器包。 如果你有很多机器，这将是一个大任务。 您可能会说，您可以编写一个脚本来自动化这项工作。 这是可能的，但这样你就有另一份工作要做了; 也就是说，维护脚本、修复可能的错误，以及随着基础设施的增长而添加新特性。

在某些情况下，您可能需要在多个主机上管理用户或数据库或配置网络设置。 很快，您将看到一种瑞士军刀工具，它具有您宁愿免费获得而不是自己编写的功能。 这就是 Ansible 派上用场的地方。 Ansible 拥有无数的模块(对于几乎任何您可以想象的系统管理任务)，它可以远程配置、运行或部署您所选择的管理作业，以一种非常安全、高效的方式，付出最少的努力。

我们将通过简要介绍 Ansible 架构巩固这些初步想法。

## 理解 Ansible 架构

核心 Ansible框架是用 Python 编写的。 让我们先提一下，Ansible 有一个**无 agent**架构。 换句话说，Ansible 在一个在远程主机上执行命令的**控制节点**上运行，而不需要在托管主机上安装远程端点或服务来与控制节点通信。 至少，Ansible 通信的唯一要求是 SSH 连接到托管主机。 然而，如果主机没有安装 Python 框架，那么 Ansible 操作的数量将相对限于只运行脚本和原始 SSH 命令。 大多数服务器操作系统平台已经默认安装了 Python。

Ansible 可以使用安全 SSH 连接从一个控制节点管理一个远程主机舰队。 下图显示了使用 Ansible 管理基础设施的**逻辑布局**:

![Figure 15.1 – The logical layout of a managed infrastructure using Ansible](image/B13196_15_01.jpg)

图 15.1 -使用 Ansible 管理基础设施的逻辑布局

产品级**企业环境通常包括一个配置管理数据库**(**CMDB)信息技术组织**(**【显示】)基础设施资产。 IT 基础设施资产的示例包括服务器、网络、服务和用户。 尽管 CMDB*不是 Ansible 体系结构的直接部分，但是 CMDB*描述了*资产和他们在管理基础设施中的关系，并且可以被用来构建 Ansible**库存**。*******

库存是本地存储 Ansible 控制节点——通常是一个**INI**或**YAML 文件描述**主机管理——**或**组**的主机。 库存可以从 CMDB 中推断出来，也可以由系统管理员手动创建。**

现在，让我们仔细看看下面图表中显示的高级 Ansible 架构:

![Figure 15.2 – The Ansible architecture](image/B13196_15_02.jpg)

图 15.2 - Ansible 架构

上图显示了 Ansible 控制节点与私有或公共云基础设施中的托管主机进行交互。 以下是对建筑视图中各区块的简要描述:

*   **API 和核心框架**:封装 Ansible 核心功能的主要库; Ansible 核心框架是用 Python 编写的。
*   **插件**:额外的库扩展核心框架的功能; 示例包括**连接插件**(例如云连接器)，**测试插件**(验证特定的响应数据)，**回调插件**(响应事件)，以及更多。
*   **模块**:这些模块封装了运行在托管主机上的特定功能; 例如包括**用户**模块(管理用户)、**包**模块(管理软件包)等等。
*   **库存**:INI 或YAML 文件，描述 Ansible 命令和剧本所针对的主机和主机组。
*   **Playbooks**:Ansible执行文件，描述一组以托管主机为目标的任务。
*   **私有或公共云**:受管理的基础设施，托管在本地或各种云环境(例如 VMware、AWS 和 Azure)中。
*   **托管主机**:Ansible 命令和剧本的目标服务器
*   **CLI**:AnsibleCLI 工具，如**Ansible**，**Ansible -playbook**，**Ansible -doc**等。
*   **Users**:管理员、超级用户和运行 Ansible 命令或剧本的自动化用户进程。

现在我们已经对 Ansible 的架构有了基本的了解，让我们看看是什么让 Ansible 成为自动化管理工作流的好工具。 接下来我们将介绍**配置管理**的概念。

## 介绍配置管理

如果我们回顾一下以前，系统管理员通常管理的服务器数量相对较少，通过在每个主机上使用远程 shell 来运行日常管理任务。 相对简单的操作，如复制文件、更新软件包和管理用户，可以很容易地编写脚本并定期重用。 随着最近应用和服务的激增，在互联网的巨大扩张的驱动下，现代的本地和基于云的 IT 基础设施——支撑相关平台——已经显著增长。 所涉及的配置更改的数量远远超过一个管理人员运行和维护少量脚本的能力。 这就是配置管理来拯救的地方。

通过配置管理，将被管理的主机和资产按照特定的标准进行逻辑分组，如图*图 15.1*所示。 管理主机以外的资产最终归结为在托管这些资产的服务器上执行特定的任务。 配置管理清单是 Ansible 目录文件。 因此，Ansible 成为配置管理端点。

使用 Ansible，我们可以运行单个一次性的命令来执行特定的任务，但是可以通过剧本实现更有效的配置管理工作流。 使用 Ansible 剧本，我们可以在任意数量的主机上运行针对目标平台的各个子系统的多个任务。 为定期维护和配置管理任务调度 ansible-playbook 运行是 IT 基础设施自动化中的常见实践。

针对特定目标反复(或按计划)运行 Ansible 任务会引起对由于重复操作而导致的期望状态中不希望发生的更改的关注。 这个问题将我们带到配置管理的一个基本方面——配置更改的**等幂**。 我们来看看接下来是什么幂等变化。

### 解释幂等操作

在配置管理中，一个操作是幂等的，当它多次运行时产生的结果与运行一次相同。 从这个意义上说，Ansible 是一个幂等配置管理工具。

假设我们有一个创建用户的 Ansible 任务。 当任务第一次运行时，它创建用户。 当用户已经创建时再次运行它，将导致一个**无操作**(**无操作**)。 *如果没有*幂等性，同一任务的后续运行将由于试图创建一个已经存在的用户而产生错误。

我们应该注意到，Ansible 并不是市场上唯一的配置管理工具。 我们有**Chef**，**Puppet**，and**SaltStack**等等。 这些平台中的大多数已经被大型企业收购，例如 VMware 拥有的 SaltStack，并且一些人可能会认为 Ansible 的成功应该归功于 Red Hat 开源项目。 Ansible 似乎是当今最成功的配置管理平台。 业界的共识是，Ansible 在企业级部署中提供了用户友好的体验、高可伸缩性和负担得起的许可层。

在介绍了这些入门概念之后，让我们卷起袖子，在您选择的 Linux 平台上安装 Ansible。

# 安装 Ansible

在本节中，我们将向您展示如何在控制节点上安装 Ansible。 在 Linux 上，我们可以通过以下几种方式安装 Ansible:

*   使用特定于平台的包管理器(例如，Ubuntu/Debian 上的`apt`和 RHEL/CentOS 上的`yum`)
*   使用 Python 包管理器`pip`

Ansible 社区推荐安装 Ansible`pip`，因为它提供了 Ansible 最新的稳定版本。 在本节中，我们将使用 Ubuntu 和 RHEL/CentOS 上的两种方法。 要获得所有主要操作系统平台的完整的 Ansible 安装指南，请遵循[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)的在线文档。

在控制节点上，Ansible 需要 Python，所以在安装 Ansible 之前，我们需要确保我们的系统已经安装了 Python。

重要提示

2020 年 1 月 1 日起不再支持 Python 2。 请使用 Python 3 代替。

让我们先在 Ubuntu 上安装 Ansible。

## 安装 Ansible

在 Ubuntu 20.04 中，我们默认安装了 Python 3。 让我们使用以下命令检查我们的 Python 3 版本:

```sh
python3 --version
```

在我们的 Ubuntu 20.04 机器上，Python 版本如下:

```sh
Python 3.8.5
```

如果你没有安装 Python 3，你可以使用以下命令来安装它:

```sh
sudo apt-get install -y python3
```

在安装了 Python 3 之后，我们可以继续安装 Ansible。 为了使用`apt`获得最新的 Ansible 包，我们需要将Ansible**Personal Package Archives**(**PPA**)存储库添加到我们的系统。

让我们从更新当前的`apt`存储库开始:

```sh
sudo apt-get update
```

接下来，我们必须添加 Ansible PPA:

```sh
sudo apt-get install -y software-properties-common
sudo apt-add-repository -y --update ppa:ansible/ansible
```

现在，我们可以使用以下命令安装 Ansible 包:

```sh
sudo apt-get install -y ansible
```

安装了 Ansible 之后，我们可以检查它的当前版本:

```sh
ansible --version
```

在我们的例子中，前一个命令的输出中相关的摘录如下:

```sh
ansible 2.9.6
```

接下来，我们将看看如何在 RHEL/CentOS 系统上安装 Ansible。

## 在 RHEL/CentOS 上安装 Ansible

首先，我们需要确保 Python 安装在我们的系统上。 在最小的**Red Hat Enterprise Linux**(**RHEL**)/CentOS 8 发行版中，Python 默认不安装。 目前，RHEL/CentOS 8 上可用的 Python 的最新版本是 Python 3.8。 让我们用下面的命令安装它:

```sh
sudo yum install -y python38
```

安装了 Python 3 后，我们可以通过运行以下命令来检查其当前版本:

```sh
python --version
```

在我们的例子中，输出如下:

```sh
Python 3.8.3
```

在 RHEL/CentOS 上，Ansible 可以通过**Extra Packages for Enterprise Linux**(**EPEL**)存储库获得。 让我们启用 EPEL 存储库:

```sh
sudo yum install -y epel-release
```

现在，我们可以安装 Ansible:

```sh
sudo yum install -y ansible
```

安装了 Ansible 之后，我们可以检查它的当前版本:

```sh
ansible --version
```

在我们的例子中，上述输出的相关摘录如下:

```sh
ansible 2.9.18
```

接下来，我们将看看如何使用`pip`安装 Ansible。

## 使用 pip 安装 Ansible

在用`pip`安装Ansible 之前，我们需要确保系统上安装了Python。 我们假设 Python 3 是基于前面介绍的步骤安装的。 接下来，我们应该删除安装了特定于平台的包管理器的 Ansible 的任何现有版本(例如，`apt`或`yum`)。

在 Ubuntu 上卸载 Ansible，运行如下命令:

```sh
sudo apt-get remove -y ansible
```

在 RHEL/CentOS 上，我们可以用下面的命令删除 Ansible:

```sh
sudo yum remove -y ansible
```

接下来，我们必须确保安装了`pip`。 下面的命令应该提供当前版本的`pip`:

```sh
python3 -m pip --version
```

在我们的例子中，输出显示如下:

```sh
pip 21.0.1 from /home/packt/.local/lib/python3.8/site-packages/pip (python 3.8)
```

如果`pip`没有安装，我们必须先下载`pip`安装程序:

```sh
curl -s https://bootstrap.pypa.io/get-pip.py -o get-pip.py
```

现在，我们已经准备好使用以下命令安装`pip`和 Ansible 了:

```sh
python3 get-pip.py --user
python3 -m pip install --user ansible
```

请注意，使用前面的命令，我们只为当前用户安装了`pip`和 Ansible。 如果您想在系统上全局安装 Ansible*，等效的命令如下:*

```sh
sudo python3 get-pip.py
sudo python3 -m pip install ansible
```

安装完成后，在使用 Ansible 之前，您可能需要注销并重新登录到终端。 使用以下命令检查安装的 Ansible 版本:

```sh
ansible --version
```

在我们的例子中，输出显示如下:

```sh
ansible 2.10.7
```

如您所见，您可以通过使用`pip`获得 Ansible 的最新版本。 因此是安装 Ansible 的推荐方法。

在控制节点上安装了 Ansible 之后，让我们看看一些使用 Ansible 的实际示例。

# 与 Ansible 合作

从这个小节开始，我们将广泛使用 Ansible CLI 工具来执行各种配置管理任务。 为了展示我们的实际示例，我们将使用一个定制的实验室环境，我们强烈建议您复制它以获得完整的配置管理体验。

以下是本节的概要:

*   搭建实验室环境
*   配置 Ansible
*   使用 Ansible ad hoc 命令
*   使用 Ansible 剧本

让我们从实验室环境的概述开始。

## 搭建实验室环境

我们的实验室使用 VMwareFusion 作为虚拟环境的桌面管理程序，但是任何其他管理程序都可以。 [*第 1 章*](01.html#_idTextAnchor014)，*安装 Linux*详细描述了使用 VMware Fusion 和 Oracle VM VirtualBox 创建 Linux 虚拟机的过程。 我们部署了以下虚拟机来模拟真实的配置管理基础设施:

*   `Neptune`:Ansible 控制节点(Ubuntu)。
*   `web1`:web 服务器(Ubuntu)。
*   `web2`:web 服务器(CentOS)。
*   `db1`:数据库服务器(Ubuntu)。
*   `db2`:数据库服务器(CentOS)。
*   `neptune`、`web1`、`db1`虚拟机运行在 Ubuntu 20.04 LTS 服务器上，`web2`、`db2`虚拟机安装了 RHEL/CentOS 8。 所有虚拟机都安装了默认的服务器组件。 在每个主机上，我们创建了一个默认的管理用户`packt`，并启用了 SSH 访问。 我们在本书的第一章中描述了 Ubuntu 和 RHEL/CentOS 服务器平台的相关安装过程。

现在，让我们简要描述这些 vm 的设置，首先从托管主机开始。

### 设置被管理的主机

被管理主机要想从 Ansible 控制节点完全启用配置管理访问，有几个关键要求:

*   它们必须运行 OpenSSH 服务器。
*   他们必须安装 Python。

我们假设您已经在主机上启用了 OpenSSH。 要安装 Python，您可以按照*安装 Ansible*一节中描述的相关步骤进行安装。

重要提示

被管理的主机不需要在系统上安装 Ansible。

要设置每个虚拟机的主机名，可以运行以下命令(例如，对于`web1`主机名):

```sh
sudo hostnamectl set-hostname web1
```

我们还希望禁用托管主机上的`sudo`登录密码，以便在运行自动化脚本时进行无人值勤权限升级。 如果我们不做这个修改，远程执行 Ansible 命令将需要一个密码。

要禁用`sudo`登录密码，使用以下命令编辑`sudo`配置:

```sh
sudo visudo
```

添加以下一行并保存配置文件。 将`packt`替换为您的用户名，如果它是不同的:

```sh
packt ALL=(ALL) NOPASSWD:ALL
```

您必须在所有托管主机上进行此更改。

接下来，我们将看看 Ansible 控制节点的初始设置。

### 建立 Ansible 控制节点

Ansible 控制节点(`neptune`)使用 Ansible 命令和剧本与被管理主机(`web1`、`web2`、`db1`和`db2`交互。 为了方便起见，我们的示例将通过主机名而不是 IP 地址引用托管主机。 为了方便地实现这一点，我们在 Ansible 控制节点(`neptune`)上的`/etc/hosts`文件中添加了以下条目:

```sh
127.0.0.1 neptune localhost
172.16.191.12 web1
172.16.191.13 db1
172.16.191.14 web2
172.16.191.15 db2
```

您必须根据 VM 环境匹配主机名和 IP 地址。

接下来，我们必须安装 Ansible。 根据您选择的平台，使用本章前面的*安装 Ansible*小节中描述的相关过程。 在本例中，我们按照*带 pip*部分中的步骤安装 Ansible，以便在撰写本文时受益于最新的 Ansible 版本 2.10.7。

最后，我们将在 Ansible 控制节点和托管主机之间建立基于 SSH 密钥的身份验证。

### 建立 SSH 密钥认证

Ansible 使用SSH 与被管理主机通信。 SSH 密钥认证机制使远程 SSH 接入不需要输入用户密码。 如果需要开启 SSH 密钥认证，请在 Ansible 控制主机(`neptune`)上执行如下命令。

使用以下命令生成安全密钥对，并遵循默认提示:

```sh
ssh-keygen
```

生成密钥对后，将相关的公钥复制到每个托管主机。 您必须一次瞄准一个主机，并使用远程`packt`用户的密码进行身份验证。 当提示时接受 SSH 密钥交换:

```sh
ssh-copy-id -i ~/.ssh/id_rsa.pub packt@web1
ssh-copy-id -i ~/.ssh/id_rsa.pub packt@web2
ssh-copy-id -i ~/.ssh/id_rsa.pub packt@db1
ssh-copy-id -i ~/.ssh/id_rsa.pub packt@db2
```

现在，您应该能够通过 SSH 从 Ansible 控制节点(`neptune`)进入任何托管主机，而不会提示输入密码。 例如，要访问`web1`，您可以使用以下命令进行测试:

```sh
ssh packt@web1
```

该命令将带您到远程服务器的(`web1`)终端。 在执行接下来的步骤之前，请确保返回到 Ansible 控制节点的终端(在`neptune`上)。

现在我们可以在控制节点上配置 Ansible 了。

## 配置 Ansible

本节探讨了与 Ansible**配置文件**和**目录**相关的 Ansible 的一些基本配置概念。 使用配置文件和其中的参数，我们可以更改 Ansible 的*行为*，例如特权升级、连接超时和默认目录文件路径。 目录*定义了*所管理的主机，作为 Ansible 的配置管理数据库。

让我们先看看 Ansible 的配置文件。

### 创建 Ansible 配置文件

下面的命令提供了一些关于 Ansible 环境的有用信息，包括当前的配置文件:

```sh
ansible --version
```

下面是前一个命令的完整输出:

![Figure 15.3 – The default Ansible configuration settings](image/B13196_15_03.jpg)

图 15.3 -默认的 Ansible 配置设置

默认的 Ansible 安装将配置文件路径设置为`/etc/ansible/ansible.cfg`。 正如您可能猜到的那样，默认配置文件具有全局作用域，这意味着在运行 Ansible 任务时默认使用它。

如果同一个控制主机上有多个用户在运行 Ansible 任务，该怎么办? 我们本能地认为，每个用户可能都有自己的一组配置参数。 Ansible 通过在用户的主目录中查找`~/.ansible.cfg`文件来解决这个问题。 让我们通过在用户(`packt`)的主目录中创建一个虚拟的配置文件来验证这个行为:

```sh
touch ~/.ansible.cfg
```

`ansible --version`命令的新调用现在会产生以下配置文件路径:

```sh
config file = /home/packt/.ansible.cfg
```

换句话说，`~/.ansible.cfg`优先于*全局配置文件`/etc/ansible/ansible.cfg`。*

现在，假设我们的用户(`packt`)创建多个 Ansible 项目，其中一些管理本地主机，另一些与公共云资源交互。 同样，我们可能需要一组不同的 Ansible 配置参数(例如连接超时和库存文件)。 Ansible 通过在当前文件夹中查找`./ansible.cfg`文件来适应这种情况。

让我们在一个新的`~/ansible/`目录中创建一个虚拟的`ansible.cfg`文件:

```sh
mkdir ~/ansible
touch ~/ansible/ansible.cfg
```

切换到`~/ansible`目录并调用`ansible --version`命令会显示以下配置文件:

```sh
config file = /home/packt/ansible/ansible.cfg
```

我们可以将项目目录命名为任何名称，不一定是`/home/packt/ansible`。 Ansible 将用户主目录中的`./ansible.cfg`文件优先于`~/.ansible.cfg`配置文件。

最后，我们可能希望配置文件具有极大的灵活性，不依赖于 Ansible 命令生成的目录或位置。 在不更改主配置文件的情况下测试临时配置时，这样的特性可能很有帮助。 为此，Ansible 为配置文件的路径读取`ANSIBLE_CONFIG`环境变量。

假设我们在`./ansible`项目文件夹中，其中我们已经定义了本地`ansible.cfg`文件，让我们创建一个虚拟的测试配置文件`test.cfg`:

```sh
cd ~/ansible
touch test.cfg
```

现在，让我们验证当设置了`ANSIBLE_CONFIG`环境变量时，Ansible 将从`test.cfg`而不是`ansible.cfg`读取配置:

```sh
ANSIBLE_CONFIG=test.cfg ansible --version
```

输出如下所示:

```sh
config file = /home/packt/ansible/test.cfg
```

我们应该注意，配置文件应该始终具有`.cfg`扩展名。 否则，Ansible 会丢弃它。

下面是一个列表，总结了 Ansible 配置文件从低优先级到高优先级的顺序:

*   `/etc/ansible/ansible.cfg`
*   用户的主目录中的`~/.ansible.cfg`文件
*   本地目录中的`./ansible.cfg`文件
*   环境变量 T0

在我们的示例中，我们将依赖于本地项目目录(`~/ansible`)中的`ansible.cfg`配置文件。 让我们创建这个配置文件，暂时把它留空:

```sh
mkdir ~/ansible
cd ~/ansible
touch ansible.cfg
```

在本章的其余部分中，除非另有说明，否则我们将从`~/ansible`文件夹运行 Ansible 命令。

除非在配置文件中明确定义(重载)配置参数，否则 Ansible 将采用系统默认值。 我们将添加到配置文件的一个属性是目录文件路径。 但首先，我们得创建库存。 下面一节将向您展示如何做到这一点。

### 创建一个 Ansible 清单

Ansible库存是一个常规的**INI**或**YAML**文件，描述被管理的主机。 在其最简单的形式中，目录可以是主机名或 IP 地址的平面列表，但 Ansible 也可以将**主机**组织为**组**。 Ansible 目录文件可以是**静态**或者**动态**，这取决于它们是手动创建和更新还是动态更新。 现在，我们将使用静态库存。

在我们的演示环境中，有两个 web 服务器(`web1`和`web2`)和两个数据库服务器(`db1`和`db2`)，我们可以定义以下目录(以 INI 格式):

```sh
[webservers]
web1
web2
[databases]
db1
db2
```

我们把主人分成两组，用括号括起来; 即`[webservers]`和`[databases]`。 分组是主机按照特定条件进行的逻辑排列。 主机可以属于多个组，例如通过添加`[ubuntu]`和`[centos]`组，如下所示:

```sh
[ubuntu]
web1
db1
[centos]
web2
db2
```

组名称区分大小写，应始终以字母开头，不应包含连字符(`-`)或空格。

Ansible 有两个默认组:

*   **all**:库存中的每台主机
*   **未分组**:**中所有的**宿主不是另一组的成员

我们还可以根据特定的模式定义组。 例如，下面的组包含以`web`开始，以`1`-`2`范围内的数字结束的主机名范围:

```sh
[webservers]
web[1:2]
```

当我们管理大量主机时，模式很有帮助。 例如，下面的模式包含一个 IP 地址范围内的所有主机:

```sh
[all_servers]
172.16.191.[11:15]
```

范围定义为`[START:END]`，包含从`START`到`END`的所有值。 范围的例子有`[1:10]`、`[01:10]`和`[a-g]`。

组也可以嵌套。 换句话说，一个组可以包含其他组。 这种嵌套用`:children`后缀来描述。 例如，我们可以定义一个包括`[ubuntu]`和`[centos]`组的`[platforms]`组:

```sh
[platforms:children]
ubuntu
centos
```

让我们将库存文件命名为`hosts`。 请注意，我们在`~/ansible`目录中。 使用您选择的 Linux 编辑器，将以下内容添加到`hosts`文件:

![Figure 15.4 – The inventory file in INI format](image/B13196_15_04.jpg)

图 15.4 - INI 格式的库存文件

`hosts`文件也可以在本章的补充 GitHub 存储库中找到:[https://github.com/PacktPublishing/Mastering-Linux-Administration/blob/main/15/src/ansible/hosts](https://github.com/PacktPublishing/Mastering-Linux-Administration/blob/main/15/src/ansible/hosts)。 在保存库存文件之后，我们可以使用以下命令来验证它:

```sh
ansible-inventory -i ./hosts –list --yaml
```

下面是对该命令参数的简要解释:

*   `-i (--inventory)`:指定库存文件; 即`./hosts`
*   `--list`:列出 Ansible 读取的当前库存
*   `--yaml`:指定 YAML 输出格式

在成功验证库存之后，该命令将显示等效的 YAML 输出。 (`ansible-inventory`实用程序的默认输出格式是 JSON。)

到目前为止，我们已经用 INI 格式表达了 Ansible 目录，但是我们也可以使用 YAML 文件来代替。 下图显示了描述相同目录的 INI 和 YAML 文件之间的并排比较:

![Figure 15.5 – Side-by-side comparison of the INI and YAML inventory formats](image/B13196_15_05.jpg)

图 15.5 -并排比较 INI 和 YAML 库存格式

由于严格的缩进和格式要求，YAML 表示可能有些挑战性，特别是在大型配置中。 在本章的其余部分，我们将继续使用 INI 目录格式。

接下来，我们要让安斯贝尔找到我们的存货。 编辑`./ansible.cfg`配置文件，添加如下行:

```sh
[defaults]
inventory = ~/ansible/hosts
```

保存文件之后，就可以运行针对托管主机的 Ansible 命令或任务了。 有两种方式可以执行 Ansible 配置管理任务:使用一次性的**临时命令**和通过**Ansible 剧本**。 接下来我们将研究临时命令。

## 使用 Ansible ad hoc 命令

特设命令执行单个 Ansible 任务，并提供与托管主机交互的快速方法。 当我们进行简单的更改和执行测试时，这些简单的操作很有帮助。

Ansible ad hoc 命令的一般语法如下:

```sh
ansible [OPTIONS] -m MODULE -a ARGS PATTERN
```

上面的命令使用 Ansible`MODULE`在指定的主机上基于`PATTERN`执行特定的任务。 任务是通过参数(`ARGS`)来描述的。 您可能还记得，模块封装了特定的功能，例如管理用户、包和服务。 为了演示临时命令的使用，我们将使用一些最常见的 Ansible 模块来完成配置管理任务。 让我们从 Ansible`ping`模块开始。

### 使用 ping 模块

最简单的临时命令之一是 Ansible`ping`测试:

```sh
ansible -m ping all
```

该命令在`all`托管主机上执行快速测试，检查它们的 SSH 连接，并确保提供所需的 Python 模块。 下面是输出的摘录:

![Figure 15.6 – A successful ping test with a managed host](image/B13196_15_06.jpg)

图 15.6 -托管主机的 ping 测试成功

输出表明命令成功(`web1 | SUCCESS`)，并且远程服务器(`web1`)响应了我们的 ping 请求(`"ping": "pong"`)。 请注意，Ansible`ping`模块不使用 ICMP 来测试与被管理主机的远程连接。

接下来，我们将在使用 Ansible`user`模块时查看临时命令。

### 使用用户模块

下面是另一个临时命令的示例。 这是检查一个特定的用户(`packt`)是否存在于所有的主机上:

```sh
ansible -m user -a "name=packt state=present" all
```

一个成功的检查将提供以下输出(摘录):

![Figure 15.7 – Checking if a user account exists](image/B13196_15_07.jpg)

图 15.7 -检查用户帐户是否存在

前面的输出还表明，在检查用户帐户时，我们可以通过确保它们具有特定的用户和组 ID 来更加具体:

```sh
ansible -m user -a "name=packt state=present uid=1000 group=1000" all
```

我们可以针对库存中有限的一部分执行特别命令。 例如，以下命令将只 ping`web1`主机以实现 Ansible 连接:

```sh
ansible -m ping web1
```

主机模式还可以包含通配符或组名。 下面是一些例子:

```sh
ansible -m ping web*
ansible -m ping webservers
```

接下来让我们看看可用的 Ansible 模块。 在我们这样做之前，你可能想要在`./ansible.cfg`下面的`[defaults]`部分添加以下一行，以减少关于已弃用模块的噪音:

```sh
deprecation_warnings = False
```

要列出 Ansible 中所有的模块，运行以下命令:

```sh
ansible-doc --list
```

您可以搜索或`grep`特定模块的输出。 具体模块的详细信息(例如`user`)，可以执行如下命令:

```sh
ansible-doc user
```

确保您检查了特定模块的`ansible-doc`输出中的`EXAMPLES`部分。 您将看到使用特定命令和剧本任务的实际例子。

如果我们想在所有的 web 服务器上创建一个新用户(`webuser`)，我们可以使用以下临时命令执行 t相关操作:

```sh
ansible -bK -m user -a "name=webuser state=present" webservers
```

让我们来解释一下命令的参数:

*   `-b (--become)`:将执行上下文更改为`sudo`(`root`)。
*   `-K (--ask-become-pass)`:提示远程主机输入`sudo`密码; 所有被管理的主机使用相同的密码。
*   `-m`:Ansible 模块`user`。
*   `-a`:指定`user`模块参数为键值对; `name=webuser`表示用户名，而`state=present`在尝试创建用户帐户之前检查该用户帐户是否存在。
*   `Webservers`:操作的目标管理主机组。

创建用户帐户需要远程主机上的管理(`sudo`)特权。 使用`-b`(`--become`)选项调用相关的**特权升级**，让 Ansible 命令在远程系统上充当*sudoer*。

重要提示

默认情况下，Ansible 不启用*无人参与*权限升级。 对于需要`sudo`特权的任务，必须显式设置`-b``(--become`)标志。 您可以在 Ansible 配置文件中覆盖此行为。

要默认启用无人值守权限升级，请在`ansible.cfg`文件中添加以下行:

```sh
[privilege_escalation]
become = True
```

现在，您不再需要在您的临时命令中指定`--b`(`--become`)标志。

如果托管主机上的 sudoer 帐户启用了`sudo`登录密码，我们必须将其提供给我们的临时命令。 在这里，`-K`(`--ask-become-pass`)选项就派上用场了。 因此，我们被要求使用以下消息的密码:

```sh
BECOME password:
```

该密码用于命令所瞄准的所有托管主机。

您可能还记得，我们在托管主机上禁用了`sudo`登录密码。 (参见本章前面的*设置实验室环境章节*。) 因此，我们可以重写前面的临时命令，而不显式地要求特权升级和相关的密码:

```sh
ansible -m user -a "name=webuser state=present" webservers
```

有一些关于特权升级的安全问题，而 Ansible 拥有减轻相关风险的机制。 有关此主题的更多信息，请参考[https://docs.ansible.com/ansible/latest/user_guide/become.html](https://docs.ansible.com/ansible/latest/user_guide/become.html)。

上面的命令产生如下输出(摘录):

![Figure 15.8 – Creating a new user using an ad hoc command](image/B13196_15_08.jpg)

图 15.8 -使用临时命令创建新用户

您可能已经注意到，这里的输出文本是黄色的，而不是绿色的，与我们之前的临时命令不同。 Ansible 将输出标记为黄色，如果它对应于托管主机的*期望状态*中的*变化*。 如果您再次运行相同的命令，输出将是绿色的，这表明自从创建用户帐户以来没有发生任何更改。 在这里，我们可以看到 Ansible 的*幂等运算*在起作用。

使用前面的命令，我们创建了一个没有密码的用户，仅用于演示目的。 如果我们想添加或修改密码怎么办? 通过使用`ansible-doc user`遍历`user`模块的文档，我们可以在模块参数中使用密码字段，但是 Ansible 只接受*密码散列*作为输入。 对于散列密码，我们将使用一个名为`passlib`的 Python 辅助模块。 让我们用下面的命令把它安装到 Ansible 控制节点上:

```sh
pip install passlib
```

您需要 Python 包管理器(`pip`)来运行前面的命令。 如果您使用`pip`安装 Ansible，应该没问题。 否则，请按照*使用管道*安装 Ansible 章节中的说明下载并安装`pip`。

安装了`passlib`后，我们可以使用以下临时命令来创建或修改用户密码:

```sh
ansible webservers -m user \
    -e "password=changeit!" \
    -a "name=webuser \
        update_password=always \
        password={{ password | password_hash('sha512') }}"
```

以下是帮助设置用户密码的附加参数:

*   `-e`(`--extra-vars`):指定自定义变量为键值对; 我们将自定义变量的值设置为`password=changeit!`。
*   `update_password=always`:如果与前一个密码不同，更新密码。
*   `password={{...}}`:将密码设置为双花括号内的表达式的值。
*   `password | password_hash('sha512')`:将`password`变量(`changeit!`)的值导入`password_hash()`函数，从而生成 SHA-512 哈希值; `password_hash()`是前面安装的`passlib`模块的一部分。

该命令将`webuser`的密码设置为`changeit!`，这是在临时命令中使用变量(`password`)的示例。 下面是相关的输出(摘录):

![Figure 15.9 – Changing the user's password using an ad hoc command](image/B13196_15_09.jpg)

图 15.9 -使用临时命令更改用户的密码

出于明显的安全原因，Ansible 不会显示实际的密码。

现在，您可以尝试使用`webuser`帐户 SSH 到任何 web 服务器(`web1`或`web2`)，并且您应该能够使用`changeit!`密码成功进行身份验证。

要删除所有 web 服务器上的`webuser`帐户，我们可以运行以下临时命令:

```sh
ansible -m user -a "name=webuser state=absent remove=yes force=yes" webservers
```

模块参数`state=absent`调用`webuser`帐户的删除。 `remove`和`force`参数等同于`userdel -rf`命令，删除用户的主目录和其中的任何文件，即使这些文件不属于用户。

相关输出如下:

![Figure 15.10 – Deleting a user account using an ad hoc command](image/B13196_15_10.jpg)

图 15.10 -使用 ad hoc 命令删除用户帐户

您可以安全地忽略在输出中捕获的`stderr`和`stderr_lines`。 该消息是良性的，因为用户之前没有创建邮件假脱机。

接下来我们将研究`package`模块，并运行几个相关的特别命令。

### 使用包模块

下面的命令在`webserver`组中的所有主机上安装**Nginx**web 服务器:

```sh
ansible -m package -a "name=nginx state=present" webservers
```

下面是输出的摘录:

![Figure 15.11 – Installing the nginx package on the web servers](image/B13196_15_11.jpg)

图 15.11 -在 web 服务器上安装 nginx 包

我们使用一个类似的临时命令在`databases`组中的所有主机上安装**MySQL**数据库服务器:

```sh
ansible -m package -a "name=mysql-server state=present" databases
```

下面是命令输出中的片段:

![Figure 15.12 – Installing the mysql-server package on the database servers](image/B13196_15_12.jpg)

图 15.12 -在数据库服务器上安装 mysql-server 包

如果我们想要*删除*一个包，临时命令也会类似，但是会以`state=absent`代替。

尽管`package`模块提供了跨各种平台的良好操作系统级抽象，但某些包管理任务最好使用特定于平台的包管理器来处理。 接下来我们将向您展示如何使用`apt`和`yum`模块。

### 使用特定于平台的包管理器

下面的ad hoc 命令在我们管理环境中的所有 Ubuntu 机器上安装最新的更新。 这个命令的目标是库存中的`ubuntu`组:

```sh
ansible -m apt -a "upgrade=dist update_cache=yes" ubuntu
```

类似地，我们可以在 RHEL/CentOS 机器上安装最新的更新，通过使用下面的 ad hoc 命令瞄准`centos`组:

```sh
ansible -m yum -a "name=* state=latest update_cache=yes" centos
```

特定于平台的包管理模块(`apt`、`yum`等)与系统无关的`package`模块的所有功能相匹配，具有额外的操作系统专用功能。

接下来让我们看看`service`模块和几个相关的特别命令。

### 使用服务模块

重启`webservers`组中所有主机上的`nginx`服务。

```sh
ansible -m service -a "name=nginx state=restarted" webservers
```

以下是输出的相关摘录:

![Figure 15.13 – Restarting the nginx service on the web servers](image/B13196_15_13.jpg)

图 15.13 -在 web 服务器上重启 nginx 服务

以同样的方式，我们可以在所有数据库服务器上重新启动`mysql`服务，但是有一个技巧! 在 Ubuntu 上，MySQL 服务被命名为`mysql`，而在 RHEL 和 CentOS 系统上，它被称为`mysqld`。 当然，我们可以为每台主机指定一个合适的服务名称，但是如果你有很多数据库服务器，不管是 Ubuntu 还是 RHEL/CentOS，这将是一项艰巨的任务。 或者，当针对多个主机或组时，我们可以使用*排除模式*(`!`)。

下面的命令将重启`databases`组中的所有主机上的`mysql`服务，除了`centos`组中的主机:

```sh
ansible -m service -a "name=mysql state=restarted" 'databases:!centos'
```

类似地，我们可以在`databases`组中的所有主机上重启`mysqld`服务，除了那些属于`ubuntu`组的主机，使用以下临时命令:

```sh
ansible -m service -a "name=mysqld state=restarted" 'databases:!ubuntu'
```

当您针对多个主机或组使用排除模式时，总是使用单引号(`''`); 否则，`ansible`命令将失败。

让我们最后看看 Ansible 模块和相关的 ad hoc 命令，它经常用于升级场景。

### 使用重启模块

下面的 ad hoc命令重新启动`webservers`组中的所有主机:

```sh
ansible -m reboot -a "reboot_timeout=3600" webservers
```

较慢的主机可能需要更长的时间重新启动，特别是在重大升级期间，因此重新启动超时将增加`3600`秒。 (默认超时时间为`600`秒。)

在我们的例子中，重启只花了几秒钟。 输出如下:

![Figure 15.14 – Rebooting the webservers group](image/B13196_15_14.jpg)

图 15.14 -重新启动 webservers 组

在本节中，我们展示了几个使用不同模块的特别命令示例。 下一节将简要介绍一些最常见的 Ansible 模块，以及如何进一步探索。

### 探索 Ansible 模块

Ansible 拥有大量的模块库。 如前所述，您可以使用`ansible-doc --list`命令在命令行 Terminal 上浏览可用的 Ansible 模块。 您也可以在Ansible 模块索引页[https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html](https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html)在线访问相同的信息。

在线目录提供按类别划分的模块索引，以帮助您快速定位要查找的特定模块。 下面是 Ansible 在日常系统管理和配置管理任务中使用的一些最典型的模块*:*

 ***封装**模块:

*   `apt`:执行APT 包管理
*   `yum`:执行 YUM 包管理
*   `dnf`:执行 DNF 包管理

**系统**模块:

*   `users`:管理用户
*   `services`:控制服务
*   `reboot`:重启机器
*   `firewalld`:防火墙管理

**文件**模块

*   `copy`:将本地文件拷贝到被管理主机
*   `synchronize`:使用`rsync`同步文件和目录
*   `file`:控制文件权限和属性
*   `lineinfile`:操作文本文件中的行

**网络工具**模块

*   `nmcli`:控制网络设置
*   `get_url`:通过 HTTP、HTTPS、FTP 方式下载文件
*   `uri`:与 web 服务和 API 端点交互

**命令**模块(非幂等!):

*   `raw`:通过 SSH 简单地运行远程命令(不安全!) 不需要在远程主机上安装 Python
*   `command`:使用 Python 的远程执行上下文安全地运行命令
*   `shell`:在被管理主机上执行 shell 命令

我们应该注意，特别命令总是使用单个模块*执行单个操作。 这个特性是一个优势(对于快速更改)，但也是一个局限性。 对于更复杂的配置管理任务，我们使用 Ansible 剧本。 下面的部分将带领您完成编写和运行 Ansible 剧本的过程。*

 *## 使用 Ansible 剧本

Ansible 剧本本质上是一个自动执行的任务列表。 Ansible 配置管理工作流主要是由剧本驱动的。 更准确地说，**剧本**是一个 YAML 文件，包含一个或多个**剧本**，每个剧本都有一个**任务**的列表，按照列出的顺序执行。 play 是针对一组主机运行相关任务的执行单元，它们通过组标识符或模式进行选择。 每个任务使用单个模块，该模块执行针对远程主机的特定操作。 您可以将任务看作简单的 Ansible 临时命令。 由于大多数 Ansible 模块遵循幂等执行上下文，剧本也是幂等的。 多次运行剧本总是会产生相同的结果。

编写良好的剧本可以用相对简单和可维护的清单取代繁重的管理任务和复杂的脚本，运行容易重复和可预测的例程。

接下来我们将创建我们的第一个 Ansible 剧本。

### 创建一个简单的剧本

我们将基于用于创建用户(`webuser`)的临时命令构建我们的剧本。 快速回顾一下，命令如下:

```sh
ansible -m user -a "name=webuser state=present" webservers
```

当我们编写等效的剧本时，您可能会注意到一些与特别命令参数的相似之处。

在编辑脚本 YAML 文件时，请注意 YAML 格式规则:

*   缩进只使用空格字符(不使用制表符)。
*   保持缩进长度一致(例如，两个空格)。
*   层次结构中相同级别的项(例如，列表项)必须具有相同的缩进。
*   子项的缩进比父项多一个缩进。

现在，使用您选择的 Linux 编辑器，将以下几行添加到`create-user.yml`文件中。 确保你在`~/ansible`项目目录中创建剧本，这是我们拥有当前库存(`hosts`)和 Ansible 配置文件(`ansible.cfg`)的地方:

![Figure 15.15 – A simple playbook for creating a user](image/B13196_15_15.jpg)

图 15.15 -创建用户的简单剧本

让我们来看看我们的`create-user.yml`剧本中的每一行:

*   `---`:标记剧本文件的开始。
*   `- name:`:描述剧名; 我们可以在剧本里有一个或多个剧本。
*   `hosts: webservers`:针对`webservers`组中的主机。
*   `become: yes`:启用当前任务的权限升级; 如果您在 Ansible 配置文件中启用了无人参与权限升级(在`[privileged_escalation]`节中使用`become = True`)，则可以省略这一行。
*   `tasks:`:当前游戏中的任务列表。
*   `- name:`:当前任务名称; 我们可以在一个游戏中有多个任务。
*   `user:`:当前任务使用的模块。
*   `name: webuser`:要创建的用户帐户的名称。
*   `state: present`:创建用户时所需的状态-我们希望用户帐户为*当前*。

让我们运行我们的`create-user.yml`剧本:

```sh
ansible-playbook create-user.yml
```

下面是我们在成功运行剧本后得到的输出:

![Figure 15.16 – Running the create-user.yml playbook](image/B13196_15_16.jpg)

图 15.16 -运行 create-user yml 剧本

`ansible-playbook`命令行选项中的大多数与`ansible`命令中的选项类似。 让我们来看看这些参数:

*   `-i`(`--inventory`):指定目录文件路径。
*   `-b`(`--become`):启用权限升级到`sudo`(`root`)。
*   `-C``(--check`):在不做任何更改和预期最终结果的情况下生成一个演习——这是验证剧本的一个有用选项。
*   `-l`(`--limit`):将命令或剧本的操作限制在被管理主机的一个子集。
*   `--syntax-check`:验证剧本语法，不做任何更改; 此选项仅适用于`ansible-playbook`命令。

让我们试验第二个剧本，这一次是为了删除用户。 我们将剧本命名为`delete-user.yml`，并添加以下内容:

![Figure 15.17 – A simple playbook for deleting a user](image/B13196_15_17.jpg)

图 15.17 -删除用户的简单剧本

现在，让以选择性的方式运行这个剧本:我们想要限制它的操作只针对 Ubuntu`webservers`组。 换句话说，我们将**限制**剧本的目标为`ubuntu`主机组:

```sh
ansible-playbook delete-user.yml --limit ubuntu
```

命令回显信息如下:

![Figure 15.18 – Limiting the delete-user.yml playbook to the ubuntu host group](image/B13196_15_18.jpg)

图 15.18 -限制删除用户 Yml 剧本到 ubuntu 主机组

正如前面的输出所示，剧本只针对`webservers`组中的主机，这些主机是`ubuntu`组(`web1`)的成员。 虽然`delete-user.yml`剧本内部针对`webserver`组中的所有主机，但通过`--limit`标志，我们将此操作仅限制于`webserver`和`ubuntu`组中的主机。

让我们重新运行`delete-user.yml`剧本，这次不限制范围:

```sh
ansible-playbook delete-user.yml
```

注意在`web1`(Ubuntu web 服务器)上的幂等操作，其中用户(`webuser`)已经在我们之前的脚本运行中被删除。 您还可以看到输出中的颜色编码:绿色表示`web1`上的未改变状态，黄色表示`web2`上的改变:

![Figure 15.19 – Rerunning the delete-user.yml playbook (without a limited scope)](image/B13196_15_19.jpg)

图 15.19 -重新运行 delete-user Yml 剧本(没有限制的范围)

接下来，我们将研究进一步简化配置管理工作流的方法，从剧本中变量的使用开始。

### 在剧本中使用变量

Ansible提供了一个灵活且通用的模型，用于在剧本和临时命令中使用变量。 通过变量，我们本质上是将*参数化*剧本，使其可重用或动态。 以我们前面的剧本为例，创建一个用户。 我们在剧本中硬编码了用户名(`webuser`)。 我们不能真正重用剧本来创建另一个用户(例如，`webadmin`)，除非我们向它添加相关的任务。 但是，如果我们有很多用户，我们的剧本将按比例增长，使其更难维护。 如果我们还想为每个用户指定一个密码呢? 剧本的复杂性会变得更加复杂。

这里就是变量发挥作用的地方。 我们可以用变量替换硬编码的值，使剧本动态。 在伪代码方面，我们使用`Playbook`来创建带有特定`username`和`password`的`User`的示例如下:

```sh
User = Playbook(username, password)
```

Ansible 中的变量用双括号括起来; 例如`{{ username }}`。 让我们看看如何在我们的剧本中利用变量。 编辑我们在上一节中编写的`create-user.yml`剧本，并按如下方式进行调整:

![Figure 15.20 – Using the username variable in a playbook](image/B13196_15_20.jpg)

图 15.20 -在剧本中使用 username 变量

第 6 行和第 8 行用`{{ username }}`变量替换了之前硬编码的值(`webuser`)。 在第 8 行中，我们用双花括号括起引号，以避免 YAML 字典表示法的语法干扰。 Ansible 中的变量名必须以字母开头，并且只能包含字母数字字符和下划线。

接下来，我们将解释*如何*和*如何*为变量设置值。 Ansible 实现了一个给变量赋值的层次模型:

1.  **全局变量**:为所有主机设置值，可以通过`--extra-vars``ansible-playbook`命令行参数或`./group_vars/all`文件。
2.  **组变量**:这些值是为特定组中的主机设置的，可以在目录文件中，也可以在以每个组命名的文件中的本地`./group_vars`目录中。
3.  **主机变量**:这些值是为特定主机设置的，可以在目录文件中，也可以在以每个主机命名的文件中的本地`./host_vars`目录中。 主机特定的变量也可以通过`gather_facts`指令从 Ansible**facts**中获得。 您可以在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts)了解更多关于 Ansible 的事实。
4.  **游戏变量**:这些值是在当前游戏的上下文中为游戏目标主机设置的; 例如游戏中的`vars`指令或`include_vars`任务。

在前面的编号列表中，变量值的优先级随数字的增加而增加。 换句话说，在游戏中定义的变量值将覆盖在主机、组或全局级别上指定的相同变量值。

作为一个的例子，你可能会想起在 Ubuntu 和 RHEL/CentOS 平台上与 MySQL服务名相关的特性。 在 Ubuntu 上，该服务是`mysql`，而在 CentOS 上，该服务是`mysqld`。 假设我们想在`databases`组中的所有主机上重新启动 MySQL 服务。 我们在*Using Ansible ad hoc commands*一节中遇到了这个问题。 假设我们的大多数数据库服务器运行 CentOS，我们可以将组级`service`变量定义为`service: mysqld`。 我们在本地项目的`./group_vars/databases`文件中设置这个变量。 然后，在我们控制服务状态的游戏中，当远程主机的操作系统平台是 Ubuntu 时，我们可以用`mysql`覆盖`service`变量值。

让我们看几个例子来说明我们到目前为止学习的关于放置变量和设置它们的值的内容。 回到我们的`create-user.yml`剧本，我们可以用以下指令在游戏级别定义`username`变量:

```sh
  vars:
    username: webuser
```

以下是它在整体剧本中的样子(第 5-6 行):

![Figure 15.21 – Defining a variable at the play level](image/B13196_15_21.jpg)

图 15.21 -在游戏级别定义变量

让我们用以下命令运行我们的剧本:

```sh
ansible-playbook create-user.yml
```

以下是输出中的相关摘录:

![Figure 15.22 – Creating a user with a playbook using variables](image/B13196_15_22.jpg)

图 15.22 -使用变量创建带有剧本的用户

为了删除用户帐户，我们可以重新调整之前的`delete-user.yml`文件，使其看起来如下所示:

![Figure 15.23 – Deleting a user with a playbook using variables](image/B13196_15_23.jpg)

图 15.23 -使用变量删除带有剧本的用户

保存文件后，执行以下命令删除所有 web 服务器上的`webuser`帐号。

```sh
ansible-playbook delete-user.yml
```

上述命令运行的相关输出如下:

![Figure 15.24 – Deleting a user with a playbook using variables](image/B13196_15_24.jpg)

图 15.24 -使用变量删除带有剧本的用户

我们可以进一步完善`create-user`和`delete-user`剧本。 由于 play 只针对`webservers`组，我们可以在`./group_vars/webservers`文件中定义`username`变量。 这样，我们可以使剧本更紧凑。 让我们从两个文件中删除变量定义(第 5-6 行)。 `create-user.yml`文件看起来与*图 15.20*相同。

接下来，在本地目录(`~/ansible`)中创建`./group_wars`文件夹，并将以下几行添加到名为`webservers.yml`的文件中:

```sh
---
username: webuser
```

我们还可以将文件命名为`webservers`，以便它匹配我们的目标群体。 然而，我们更倾向于使用`.yml`扩展名，以便与文件的 YAML 格式保持一致。 Ansible 接受这两种命名约定。 下面是当前项目目录的树状结构:

![Figure 15.25 – The directory tree, including the group_vars folder](image/B13196_15_25.jpg)

图 15.25 -目录树，包括 group_vars 文件夹

如果我们运行我们的剧本，结果应该与我们之前运行的相同:

```sh
ansible-playbook create-user.yml
ansible-playbook delete-user.yml
```

现在，让我们在`create-user`剧本中再添加一个变量:用户的`password`。 您可能还记得我们为相同目的创建的临时命令。 有关更多信息，请参阅本章前面的*Using Ansible ad hoc commands*一节。

在`user`任务的`create-user.yml`文件中添加以下几行，与`name`处于同一级别:

```sh
password: "{{ password | password_hash('sha512') }}"
update_password: always
```

您可能会注意到这些更改与相关的临时命令非常相似。 更新后的剧本内容如下:

![Figure 15.26 – The playbook with username and password variables](image/B13196_15_26.jpg)

图 15.26 -用户名和密码变量的剧本

接下来，编辑`./group_vars/webservers.yml`文件并添加带有`changeit!`值的`password`变量。 你的更新文件应该有以下内容:

```sh
---
username: webuser
password: changeit!
```

让我们运行剧本:

```sh
ansible-playbook create-user.yml
```

该命令的输出与前面类似的命令相同。 您可以通过尝试 SSH 到其中一个 web 服务器(例如，`web1`)来测试新的用户名(`webuser`)和密码(`changeit!`):

```sh
ssh webuser@web1
```

SSH认证应该成功。 在继续下一步之前，请确保退出远程终端。 让我们用下面的命令删除 webservers 上的`webuser`帐户，以回到初始状态:

```sh
ansible-playbook delete-user.yml
```

假设我们希望重用`create-user`剧本来创建一个使用不同密码的不同用户。 我们将此用户命名为`webadmin`; 我们将设置密码为`changeme!`。 完成此任务的一种方法是在`ansible-playbook`中使用`-e``(--extra-vars`)选项参数:

```sh
ansible-playbook -e '{"username": "webadmin", "password": "changeme!"}' create-user.yml
```

前面的命令将使用相关密码创建一个新用户(`webadmin`)。 您可以使用以下命令测试凭据:

```sh
ssh webadmin@web1
```

SSH 认证应该成功。 在继续之前，请确保退出远程终端。

如您所见，`-e`(`--extra-vars`)选项参数接受一个 JSON 字符串，其中包含`username`和`password`字段，以及相应的值。 这些值将*覆盖`./group_vars/webservers.yml`文件中在组级别定义的相同变量的值*。

在进行下一步之前，先删除`webuser`和`webadmin`帐户。 让我们运行`delete-user`剧本，首先不带任何参数:

```sh
ansible-playbook delete-user.yml
```

上述命令将删除`webuser`帐户。 接下来，我们将使用`-e`(`--extra-vars`)选项参数删除`webadmin`用户:

```sh
ansible-playbook -e '{"username": "webadmin"}' delete-user.yml
```

将`--extra-vars`与`create-user`和`delete-user`剧本结合使用，我们可以通过手动运行剧本或在循环中运行剧本，并向 JSON blob 提供所需的变量来对多个用户帐户进行操作。 虽然这个方法可以很容易地编写脚本，但 Ansible 通过使用带有循环的任务迭代提供了更多的方法来改进我们的剧本。 我们将在本章后面讨论循环，但首先，让我们使用 Ansible 用于管理秘密的加密和解密工具更安全地处理我们的密码。

### 处理机密

Ansible 有一个专门用来管理秘密的模块，叫做**Ansible Vault**。 使用Ansible Vault，我们可以加密和存储敏感数据，如剧本中引用的变量和文件。 Ansible Vault 本质上是一个密码保护的安全键值数据存储。

为了管理我们的秘密，我们可以使用的**ansible-vault**命令行实用程序。 关于我们的剧本，我们创建一个用户与密码，我们希望避免存储明文密码。 它目前在`./group_vars/webservers.yml`文件中。 提醒一下，我们的`webservers.yml`文件有以下内容:

![Figure 15.27 – The sensitive data stored in the password variable](image/B13196_15_27.jpg)

图 15.27 -密码变量中存储的敏感数据

第 3 行包含敏感数据:密码以明文显示。 我们有几个选择来保护我们的数据:

*   加密`webservers.yml`文件。
*   只加密`password`变量。
*   将密码存储在一个单独的受保护文件中。

让我们简要讨论这些选项。 如果选择加密`webservers.yml`文件，可能会产生加密非敏感数据(如`username`或其他通用信息)的开销。 如果我们有很多用户，对非敏感数据进行加密和解密将是高度冗余的。

第二个选项——只对密码变量进行加密——对于单个用户来说就可以了。 但是随着用户数量的增加，我们将有多个密码变量需要处理，每个变量都有自己的加密和解密。 如果我们有大量的用户，性能将再次成为一个问题。

理想情况下，我们应该有一个单独的文件来存储所有敏感数据。 在剧本运行期间，这个文件只会被解密一次，即使存储了多个密码。 因此，让我们遵循这个选项并创建一个单独的文件来保存用户密码。 我们将文件命名为`passwords.yml`，并添加以下内容:

![Figure 15.28 – The passwords.yml file storing sensitive data](image/B13196_15_28.jpg)

图 15.28 -密码 存储敏感数据的 Yml 文件

我们添加了与与密码相关的`webuser`用户名匹配的 YAML 字典(或散列)项。 该项包含另一个字典作为键值对:`password: changeit!`。 等效的 YAML 表示如下:

```sh
webuser: { password: changeit! }
```

这种方法将允许我们添加对应于不同用户的密码，像这样:

```sh
webuser: { password: changeit! }
webadmin: { password: changeme! }
```

我们将在本节的后面解释这个数据结构背后的概念，以及在使用`password`变量时的用法。

现在，由于我们将密码保存在不同的文件中，我们将从`webusers.yml`中删除相应的条目。 让我们使用`comment`变量添加一些其他与用户相关的信息。 下面是我们的`webusers.yml`文件的样子:

![Figure 15.29 – The webusers.yml file storing non-sensitive user data](image/B13196_15_29.jpg)

图 15.29 -网络用户 存储非敏感用户数据的 Yml 文件

接下来，让我们通过使用 Ansible Vault 加密`passwords.yml`文件来保护我们的秘密:

```sh
ansible-vault encrypt passwords.yml
```

您将被提示创建一个保险库密码来保护文件。 记住密码，因为我们将在本节中使用它。 完成之后，使用以下命令检查`passwords.yml`文件:

```sh
cat passwords.yml
```

输出显示我们的文件是加密的:

![Figure 15.30 – The encrypted passwords.yml file](image/B13196_15_30.jpg)

图 15.30 -加密的密码 yml 文件

我们可以使用以下命令查看`passwords.yml`文件的内容:

```sh
ansible-vault view passwords.yml
```

系统将提示您输入我们之前创建的保险库密码。 输出显示了与我们的受保护文件相对应的精简 YAML 内容:

![Figure 15.31 – Viewing the content of the protected file](image/B13196_15_31.jpg)

图 15.31 -查看受保护文件的内容

如果需要修改，可以使用下面的命令编辑加密文件:

```sh
ansible-vault edit passwords.yml
```

在使用保险库密码进行身份验证之后，该命令将打开一个本地编辑器(`vi`)来编辑您的更改。 如果您想用不同的密码重新加密您的受保护文件，您可以运行以下命令:

```sh
ansible-vault rekey passwords.yml
```

系统将提示您输入当前的保险库密码，然后输入新密码。

现在，让我们学习如何在我们的剧本中引用秘密。 首先，让我们确保可以从保险库中读取密码。 对`create-user.yml`文件进行以下更改:

![Figure 15.32 – Debugging vault access](image/B13196_15_32.jpg)

图 15.32 -调试仓库访问

我们添加了两个任务:

*   `include_vars`(第 6-8 行):从`passwords.yml`文件中读取变量
*   `debug`(第 10-12 行):调试剧本并记录从 vault 中读取的密码

这些任务中没有一个*知道*`passwords.yml`文件受到保护。 第 12 行是*神奇*发生的地方:

```sh
msg: "{{ vars[username]['password'] }}"
```

我们使用`vars[]`字典查询剧本中的特定变量。 `vars[]`是一个*保留的*数据结构，用于存储 Ansible 剧本中通过`vars`和`include_vars`创建的所有变量。 我们可以根据`username`指定的键查询字典:

```sh
{{ vars[username] }}
```

我们的剧本从`./group_vars/webservers.yml`文件获取`username`，其值为`webuser`。 因此，`vars[webuser]`字典项从`passwords.yml`文件中读取相应的条目:

```sh
webuser: { password: changeit! }
```

为了从对应的键值对中获取密码值，我们在`vars[username]`字典中指定`'password'`键:

```sh
{{ vars[username]['password'] }}
```

让我们用下面的命令来运行这个剧本:

```sh
ansible-playbook --ask-vault-pass create-user.yml
```

我们调用`--ask-vault-pass`选项来让 Ansible 知道我们的剧本需要密室访问。 如果没有这个选项，在运行剧本时会出现错误。 下面是调试任务的相关输出:

![Figure 15.33 – The playbook successfully reading secrets from the vault](image/B13196_15_33.jpg)

图 15.33 -剧本成功地从 vault 中读取秘密

在这里，我们可以看到剧本成功地从保险库中检索了密码。 让我们通过添加以下代码来结束我们的`create-user.yml`剧本:

![Figure 15.34 – The playbook creating a user with a password retrieved from the vault](image/B13196_15_34.jpg)

图 15.34 -使用从保险库中取回的密码创建用户

以下是关于当前实现的一些亮点:

*   我们添加了`vars`块(第 5-6 行)来定义一个局部`password`变量(在播放范围内)，用于从金库读取密码; 我们在多个任务中重用了`password`变量。
*   `include_vars`任务(第 8-10 行)为受保护的`passwords.yml`文件中定义的变量添加了一个外部引用。
*   `debug`任务(第 12-15 行)帮助进行了初始调试工作，以确保我们可以从保险库中读取密码。 您可以选择删除该任务或将其保留以备将来使用。 如果保留该任务，请确保启用了`no_log: true`(第 15 行)，以避免在输出中记录敏感信息。 调试时可以临时设置`no_log: false`。
*   `user`任务读取`password`变量并散列相应的值。 出于安全原因，Ansible`user`模块需要这种散列。 我们还添加了带有额外用户信息的`comment`字段。 该字段映射到用户的 Linux GECOS 记录。 相关信息请参见[*第四章*](04.html#_idTextAnchor073)、*管理用户和组*中的*管理用户*部分。

让我们用以下命令运行剧本:

```sh
ansible-playbook --ask-vault-pass create-user.yml
```

在命令成功完成后，您可以通过以下两种方式验证新用户帐户:

*   使用 SSH 连接到任何 web 服务器使用相关的用户名和密码，像这样:
*   Look for the `webuser` record in `/etc/passwd`:

    ```sh
    tail -n 10 /etc/passwd
    ```

    你应该在输出中看到以下一行(你也会注意到 GECOS 字段):

    ```sh
    webuser:x:1001:1001:Regular web user:/home/webuser:/bin/sh
    ```

您可能希望运行`ansible-playbook`命令而不提供保险库密码，如`--ask-vault-pass`所要求的。 当使用 Ansible Vault 时，这种功能在脚本化或自动化工作流中是必不可少的。 当你运行使用敏感数据的剧本时，要让你的金库密码自动可用，首先创建一个常规文本文件，最好在你的主目录中; 例如`~/vault.pass`。 将保险库密码添加到该文件中，只需一行。 然后，您可以选择*中的*来使用保险库密码文件:

*   创建以下环境变量:

    ```sh
    export ANSIBLE_VAULT_PASSWORD_FILE=~/vault.pass
    ```

*   将以下一行添加到`ansible.cfg`文件的`[defaults]`部分:

现在，您可以在没有`--ask-vault-pass`选项的情况下运行`create-user`剧本:

```sh
ansible-playbook create-user.yml
```

有时，用一个保险库密码保护多个秘密会引起安全问题。 Ansible 通过保险库 id 支持多个保险库密码。

#### 使用库 id

**保险库 ID**是与一个或多个保险库秘密相关联的标识符或标签。 每个保险库 ID 都有一个唯一的密码来解锁加密和解密对应的秘密。 为了说明保险库 id 的使用，让我们看一下我们的`passwords.yml`文件。 假设我们希望使用保险库 ID 保护该文件。 下面的命令创建了一个标记为`passwords`的保险库 ID，并提示我们创建密码:

```sh
ansible-vault create --vault-id passwords@prompt passwords.yml
```

`passwords`保险库 ID 保护`passwords.yml`文件。 现在，让我们假设还希望保护与用户关联的一些 API 密钥。 如果我们将这些秘密存储在`apikeys.yml`文件中，下面的命令将创建一个相应的名为`apikeys`的保险库 ID:

```sh
ansible-vault create --vault-id apikeys@prompt apikeys.yml
```

在这里，我们创建了两个保险库 id，每个都有自己的密码并保护不同的资源。 在管理秘密时，Vault id 提供了改进的安全性上下文。 如果其中一个保险库 ID 密码泄露，由其他保险库 ID 保护的资源仍然受到保护。 有了保险库 id，我们还可以利用不同的访问级别来获取保险库的秘密。 例如，我们可以为相关的用户组定义`admin`、`dev`和`test`保险库 id。 或者，我们可以有多个配置管理项目，每个项目都有自己专用的保险库 id 和秘密; 例如:`user-config`、`web-config`、`db-config`。

您可以将一个保险库 ID 与多个秘密关联。 例如，下面的命令创建了一个保护`passwords.yml`和`api-keys.yml`文件的`user-config`保险库 ID:

```sh
ansible-vault create --vault-id user-config@prompt passwords.yml apikeys.yml
```

在使用仓库 id 时，我们还可以指定一个密码文件来提供相关的仓库密码。 下面的命令对`apikeys.yml`文件进行加密，该文件正在从`apikeys.pass`文件中读取相应的保险库 ID 密码:

```sh
ansible-vault encrypt --vault-id apikeys@apikeys.pass apikeys.yml
```

您可以为您的保险库密码文件命名任何您想要的名称，但是保持一致的命名约定，可能是一个匹配相关保险库 ID 的命名约定，将使您在管理多个保险库机密时更容易。

类似地，您可以通过以下命令将保险库 ID(`passwords`)传递给剧本(`create-users.yml`):

```sh
ansible-playbook --vault-id passwords@passwords.pass create-users.yml
```

有关Ansible Vault 的更多信息，您可以参考相关的在线文档[https://docs.ansible.com/ansible/latest/user_guide/vault.html](https://docs.ansible.com/ansible/latest/user_guide/vault.html)。

到目前为止，我们已经创建了一个带有密码的单一用户帐户。 如果我们要加载多个用户，每个用户都有自己的密码，该怎么办? 如前所述，我们可以调用`create-user`剧本，并使用`--extra-vars`选项参数覆盖`username`和`password`变量。 但是这种方法不是很有效，更不用说维护它的困难了。 在下一节中，我们将向您展示如何在 Ansible 剧本中使用任务迭代。

### 使用循环

**循环**提供了在 Ansible 剧本中重复运行一个任务的有效方法。 在 Ansible 中有几种循环实现，我们可以根据它们的关键字或语法将它们分为以下几类:

*   `loop`:推荐的遍历集合的方法。
*   `with_<lookup>`:特定于集合的循环实现; 例如:`with_list`、`with_items`和`with_dict`。

在本节中，我们将聚焦于`loop`迭代(相当于`with_list`)，它最适合于简单的循环。 让我们扩展前面的用例，使其适应于创建多个用户。 首先，我们将对使用运行重复任务*和不使用*循环运行的*进行快速比较。*

作为准备步骤，确保`~/ansible`是当前的工作目录。 此外，您还可以删除`./group_vars`文件夹，因为我们不再使用它了。 现在，让我们创建两个剧本，`create-users1.yml`和`create-users2.yml`，如下图所示:

![Figure 15.35 – Playbooks with multiple versus iterative tasks](image/B13196_15_35.jpg)

图 15.35 -多任务和迭代任务的剧本

两个剧本都创建了三个用户:`webuser`、`webadmin`和`webdev`。 `create-users1`剧本有三个不同的任务，一个用于创建每个用户。 另一方面，`create-users2`使用`loop`指令实现单个任务迭代(第 15 行):

```sh
loop: "{{ users }}"
```

该循环遍历`users`列表中的项，该列表在第 6-9 行中定义为 play 变量。 `user`任务使用`{{ item }}`变量，在遍历列表时引用每个用户。

在运行这些剧本之前，我们还要创建一个用于删除用户的剧本。 我们将此剧本命名为`delete-users2.yml`，它将具有类似于`create-users2.yml`的实现:

![Figure 15.36 – A playbook using a loop for deleting users](image/B13196_15_36.jpg)

图 15.36 -使用循环删除用户的剧本

现在，让我们运行`create-user1`剧本，同时只针对`web1`web 服务器:

```sh
ansible-playbook create-users1.yml --limit web1
```

在输出中，我们可以看到已经执行了三个任务，每个用户一个:

![Figure 15.37 – The output of the create-user1 playbook, with multiple tasks](image/B13196_15_37.jpg)

图 15.37 - create-user1 剧本的输出，包含多个任务

让我们通过运行`delete-users2.yml`剧本来删除用户:

```sh
ansible-playbook delete-users2.yml --limit web1
```

现在，让我们运行`create-user2`剧本，同样只针对`web1`web 服务器:

```sh
ansible-playbook create-users2.yml --limit web1
```

这一次，输出显示了一个遍历所有用户的单一任务:

![Figure 15.38 – The output of the create-user2 playbook, with a single task iteration](image/B13196_15_38.jpg)

图 15.38 - create-user2 剧本的输出，带有单个任务迭代

这两个剧本运行之间的差异是显著的。 第一个剧本为每个用户执行一个任务。 虽然 fork 一个任务不是一个昂贵的操作，但是您可以想象创建数百个用户会给 Ansible 运行时带来很大的负载。 另一方面，第二个剧本运行单个任务，加载`user`模块三次，以创建每个用户。 加载模块比运行任务占用的资源要少得多。

既然我们知道了如何实现一个简单的循环，我们将使我们的剧本更加紧凑和可维护。 我们还将以可重用和安全的方式存储用户及其相关密码，从而更接近真实场景。 我们将把用户的信息保存在`users.yml`文件中。 相关密码在`passwords.yml`文件中。 下面是这两个文件，以及一些示例用户数据:

![Figure 15.39 – The users.yml and passwords.yml files](image/B13196_15_39.jpg)

图 15.39 -用户 yml 和密码。 yml 文件

`users.yml`文件包含一个只有一个键值对的字典:

*   *键*:`webusers`
*   *值*:包含`username`和`comment`元组的列表

`passwords.yml`文件包含一个包含多个键值对的嵌套字典，如下所示:

*   *键*:`<username>`(如`webuser`、`webadmin`等)
*   *Value*:带有`password``: <value>`键值对的嵌套字典

您可以使用`ansible-vault edit`命令更新`passwords.yml`文件。 或者，您可以从头创建文件，然后按照前面在*Working with secrets*一节中描述的步骤对其进行加密。

`create-users.yml`剧本文件有以下实现:

![Figure 15.40 – The create-users.yml playbook](image/B13196_15_40.jpg)

图 15.40 - create-users。 yml 剧本

这些文件也可以在本书的 GitHub 存储库的相关章节文件夹中找到。 让我们快速浏览一下剧本的实现。 我们有三个任务:

*   **加载 web 用户**(第 6-9 行):从`users.yml`文件中读取 web 用户信息，并将相关值存储在`users`字典中。
*   **加载密码**(第 10-13 行):从加密的`passwords.yml`文件中读取密码，并将相应的值存储在`passwords`字典中。
*   **创建用户帐户**(第 14-21 行):遍历`users.webusers`列表，并为每个`item`创建一个具有相关参数的用户帐户; 该任务基于`item.username`在`passwords`字典中执行密码查找。

使用以下命令运行剧本:

```sh
ansible-playbook create-users.yml
```

输出:

![Figure 15.41 – Running the create-users.yml playbook](image/B13196_15_41.jpg)

图 15.41 -运行 create-users yml 剧本

我们可以看到以下工作中的剧本任务:

*   **收集事实**:发现被管理主机及相关系统变量(事实); 我们将在本章后面介绍安斯贝尔事实。
*   **加载用户**:从`users.yml`文件中读取用户。
*   **加载密码**:从加密的`passwords.yml`文件中读取密码。
*   **创建用户账号**:创建用户的任务迭代循环。

您可以使用前面在*Working with secrets*一节中介绍的方法来验证新用户帐户。 作为练习，使用与`create-users`剧本相似的实现创建`delete-users.yml`剧本。

有关循环的更多信息，您可以参考相关的在线文档[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)。

现在，让我们看看如何改进我们的剧本，并重用它来无缝地在库存中的所有主机、web 服务器和数据库中创建用户。 我们将使用条件任务来完成此功能。

### 运行条件的任务

Ansible 剧本中的条件**条件**根据条件(或状态)决定什么时候运行任务。 此条件可以是一个**变量**、**事实**或前一个任务的**结果**的值。 Ansible 使用`when`任务级指令来定义一个条件。

我们学习了变量以及如何在剧本中使用它们。 事实和结果本质上是特定类型和用途的变量。 我们将在条件任务的背景下研究每一个变量。 让我们先从事实开始吧。

#### 使用 Ansible 事实

**事实**是变量，它们提供关于*远程*被管理主机的特定信息。 事实变量名以`ansible_`前缀开头。

以下是一些可证实的事实:

*   `ansible_distribution`:OS 分布(例如`CentOS`或`Ubuntu`)
*   `ansible_all_ipv4_addresses`:IPv4 地址
*   `ansible_architecture`:平台架构(例如`x86_64`或`i386`)
*   `ansible_processor_cores`:CPU 核数
*   `ansible_memfree_mb`:可用内存(MB)

您可能还记得我们在*使用特定平台的包管理器*一节中使用的临时命令，用于在我们的目录中的 Ubuntu 和 RHEL/CentOS 机器上安装最新的更新。 让我们来看看这些临时命令。

你可以用下面的命令更新 Ubuntu 主机:

```sh
ansible -m apt -a "upgrade=dist update_cache=yes" ubuntu
```

使用如下命令更新 RHEL/CentOS 主机:

```sh
ansible -m yum -a "name=* state=latest update_cache=yes" centos
```

在这两个命令中，我们针对相关的主机组`ubuntu`和`centos`。 现在，如果我们没有为在 Ubuntu 和 CentOS 系统中对主机进行分类而明确创建的组呢? 在本例中，我们可以*收集*有关托管主机的事实，检测它们的 OS 类型，并根据底层平台执行条件更新任务。 让我们使用 Ansible 事实在剧本中实现这个功能。

我们将剧本命名为`install-updates.yml`，并添加以下内容:

![Figure 15.42 – The install-updates.yml playbook](image/B13196_15_42.jpg)

图 15.42 -安装更新 yml 剧本

该剧本针对所有主机，并基于`ansible_distribution`事实有两个条件任务:

*   **安装 CentOS 系统更新**(第 7-9 行):仅在 CentOS 主机上基于`ansible_distribution == "CentOS"`条件运行(第 9 行)
*   **Install Ubuntu system updates**(第 11-13 行):只在 Ubuntu 主机上运行`ansible_distribution == "Ubuntu"`条件(第 13 行)

让我们运行我们的剧本:

```sh
ansible-playbook install-updates.yml
```

下面是相应的输出:

![Figure 15.43 – Running conditional tasks](image/B13196_15_43.jpg)

图 15.43 -运行条件任务

上面的输出说明了三个任务:

*   **收集事实**:剧本执行的默认发现任务，用于收集关于远程主机的事实
*   **Install CentOS system updates**:跳过所有 Ubuntu 主机(`web1`，`db1`)，在 CentOS 主机(`web2`，`db2`)上运行的条件任务
*   **Install Ubuntu system updates**:跳过所有 CentOS 主机(`web2`，`db2`)，在 Ubuntu 主机(`web1`，`db1`)上运行

接下来，我们将看看如何在条件任务中使用 Ansible 的特定于环境的变量。

### 使用魔法的变量

**Magic 变量**描述本地 Ansible 环境及其相关配置数据。 以下是一些神奇变量的例子:

*   `ansible_playhosts`:当前播放的活动主机列表
*   `group_names`:当前主机所属的所有组的列表
*   `vars`:包含当前游戏中所有变量的字典
*   `ansible_version`:Ansible 版本

为了了解在使用条件任务时神奇变量的作用，我们将进一步改进`create-users`剧本，并在不同的主机组上创建特定的用户组。 到目前为止，剧本只在属于`webservers`组(`web1`，`web2`)的主机上创建用户。 剧本在所有 web 服务器上创建了`webuser`、`webadmin`和`webdev`用户帐户。 如果我们想在所有数据库服务器上创建一个类似的用户组(`dbuser`、`dbadmin`和`dbdev`，该怎么办?

首先，将新用户帐户和密码分别添加到`users.yml`和`passwords.yml`文件中。 下面是添加数据库用户帐户和密码后的结果:

![Figure 15.44 – The users.yml and passwords.yml files](image/B13196_15_44.jpg)

图 15.44 -用户 yml 和密码。 yml 文件

注意，您可以使用`ansible-vault edit`命令编辑`passwords.yml`文件。 或者，您可以解密、编辑文件并重新加密它。 现在，让我们用必要的条件任务更新`create-user`剧本，选择性地处理`webusers`和`databases`两组。 更新`create-users.yml`文件，内容如下:

![Figure 15.45 – The create-users.yml playbook with conditional tasks](image/B13196_15_45.jpg)

图 15.45 - create-users。 有条件任务的 Yml 剧本

以下是与之前版本相比我们所做的基本的改变:

*   修改第 3 行，`hosts: all`:针对所有主机
*   添加第 22 行，`when: "'webservers' in group_names"`:有条件地运行 web 用户任务，但只针对属于`webservers`组的主机
*   将 web 用户任务(第 14-22 行)复制/粘贴到相应的数据库用户任务(第 23-31 行)
*   调整第 30-31 行中的`loop`和`when`子句以使用特定于数据库的变量

让我们运行剧本:

```sh
ansible-playbook create-users.yml
```

输出显示web 用户任务跳过数据库服务器，数据库用户任务跳过 web 服务器，说明 web 用户和数据库用户创建成功:

![Figure 15.46 – The web and database user tasks running selectively](image/B13196_15_46.jpg)

图 15.46 - web 和数据库用户任务有选择地运行

关于Ansible 特殊变量(包括magic 变量)的完整列表，请访问[https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)。 有关事实和神奇变量的更多信息，请查看在线文档[https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html)。

接下来，我们将查看用于跟踪任务结果的变量，也称为寄存器变量。

#### 使用寄存器变量

Ansible 将捕获任务的输出记录在一个称为**的变量**中。 Ansible 使用`register`指令在一个变量中捕获任务的输出。 使用寄存器变量的一个典型示例是收集任务的结果以进行调试。 在更复杂的工作流中，特定的任务可能运行，也可能不运行，这取决于前一个任务的结果。

让我们考虑一个假设的用例。 当我们在所有服务器上加载新用户并创建不同的帐户时，我们希望确保用户数量不超过允许的最大数量。 如果达到了限制，我们可以选择启动一个新的服务器，重新分配用户，等等。 让我们先创建一个名为`count-users.yml`的剧本，内容如下:

![Figure 15.47 – The count-users.yml playbook](image/B13196_15_47.jpg)

图 15.47 -计数用户 yml 剧本

我们在剧本中创建了以下任务:

*   **Count all users**(第 8-10 行):一个使用`shell`模块计数所有用户的任务; 我们通过捕获任务输出来注册`count`变量(第 10 行)。
*   **调试用户数量**(第 11-13 行):一个简单的调试任务，记录用户数量和允许的最大限制(第 13 行)。
*   **Detect limit**(第 14-17 行):当达到限制时运行的条件任务; 任务检查`count`寄存器变量的值，并将其与`max_allowed`变量进行比较(第 17 行)。

我们的剧本中的第 17 行需要进一步解释。 这里，我们取寄存器变量的实际标准输出; 即`count.stdout`。 按原样，该值将是一个字符串，我们需要将其转换为整数; 即`count.stdout | int`。 然后，将结果数与`max_allowed`进行比较。 让我们只针对`web1`主机运行剧本:

```sh
ansible-playbook count-users.yml --limit web1
```

输出如下:

![Figure 15.48 – The conditional task (Detect limit) is executed](image/B13196_15_48.jpg)

图 15.48 -执行条件任务(Detect limit

在这里，我们可以看到用户数量为 36，因此超过了最大限制 30。 换句话说，*Detect limit task*按预期运行。

现在，让我们编辑`count-users.yml`剧本，将第 6 行更改为以下内容:

```sh
max_allowed: 50
```

保存并重新运行剧本。 这一次，输出显示跳过了**Detect limit**任务:

![Figure 15.49 – The conditional task (Detect limit) is skipped](image/B13196_15_49.jpg)

图 15.49 -跳过条件任务(Detect limit

欲了解更多关于 Ansible 剧本中的条件任务，请访问[https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html)。 通过将条件任务与 Ansible 的全面事实和特殊变量相结合，我们可以编写非常强大的剧本，并使广泛的系统管理操作自动化。

在接下来的章节中，我们将探索其他方法，使我们的剧本更加可重用和通用。 接下来我们将研究动态配置模板。

## 使用 Jinja2 使用模板

最常见的配置管理任务之一是将文件复制到被管理的主机。 Ansible 提供了用于服务此类任务的`copy`模块。 在 Ansible 剧本中，一个典型的文件复制操作有以下语法:

```sh
- copy:
    src: motd
    dest: /etc/motd
```

复制任务获取源文件(`motd`)并将其复制到远程主机上的目标文件(`/etc/motd`)。 虽然该模型可以将静态文件复制到多个主机，但它不能在这些文件*中实时*处理主机特定的自定义。 例如，一个网络配置文件显示主机的 IP 地址。 试图在所有主机上复制此文件以配置相关网络设置可能导致除一台主机外的所有主机无法访问。 理想情况下，网络配置文件应该有一个用于动态内容(例如，IP 地址)的*占位符*，并根据目标主机相应地调整文件。

为了解决这个功能，Ansible 提供了带有**Jinja2**模板引擎的**模板**模块。 Jinja2 在模板中为变量和表达式使用类似 python 的语言构造。 `template`的语法与`copy`非常相似:

```sh
- template:
    src: motd.j2
    dest: /etc/motd
```

在本例中，源文件为，一个 Jinja2 模板文件(`motd.j2`)，具有特定于主机的自定义。 在将文件复制到远程主机之前，Ansible 读取 Jinja2 模板，并用主机特定的数据替换动态内容。 这个过程在 Ansible 控制节点上进行。

为了说明 Ansible 模板的一些优点和内部工作方式，我们将使用两个用例，并为每个用例创建一个 Jinja2 模板。 然后，我们将创建并运行相关的剧本，以显示模板的实际效果。

下面是我们将在本节中创建的两个模板:

*   *message-of- day*模板:用于向用户显示预定的系统维护消息
*   *hosts 文件*模板:用于在每个系统上生成一个自定义的`/etc/hosts`文件，其中包含其他托管主机的主机名记录

让我们从每日消息模板开始。

### 创建每日消息模板

在我们的导言注释中，我们使用`/etc/motd`(当日消息)文件作为示例。 在 Linux 系统中，当用户登录终端时，会显示该文件的内容。 假设您计划在周四晚上升级您的 web 服务器，并且希望给您的用户一个关于即将到来的停机的友好提醒。 您的`motd`信息可能是这样的:

```sh
This server will be down for maintenance on Thursday night.
```

这条消息没有什么特别之处，并且可以使用简单的`copy`任务轻松部署`motd`文件。 在大多数情况下，这样的消息可能很好，除了偶尔用户可能会混淆这个服务器到底是*。 你也可以考虑美国的周四晚上可能是世界另一边的周五下午，如果公告更具体就好了。*

也许更好的消息应该在`web1`web 服务器上声明如下:

```sh
web1 (172.16.191.12) will be down for maintenance on Thursday, April 8, 2021, between 2 - 3 AM (UTC-08:00).
```

在`web2`web 服务器上，消息将反映相应的主机名和 IP 地址。 理想情况下，模板应该可以跨多个时区重用，剧本运行在全球分布的 Ansible 控制节点上。 让我们看看如何实现这样一个模板。 我们将假设您当前的工作目录是`~/ansible`。

首先，在本地 Ansible 项目目录中创建一个`templates`文件夹:

```sh
mkdir -p ~/ansible/templates
```

Ansible 将在本地目录(我们将在此目录中创建剧本)或`./templates`文件夹中寻找模板文件。 使用您选择的 Linux 编辑器，在`./templates`中创建一个包含以下内容的`motd.j2`文件:

![Figure 15.50 – The motd.j2 template file](image/B13196_15_50.jpg)

图 15.50 - motd j2 模板文件

注意 Jinja2 语法的一些特殊性:

*   注释包含在`{# ... #}`中(第 1 行和第 10 行)。
*   表达式被`{% ... %}`包围(例如，第 2、3、4 行，等等)。
*   外部变量由`{{ ... }}`引用(例如，第 11 行)。

下面是脚本的作用:

*   第 1-3 行定义用于存储中断时间边界的初始局部变量集:中断的日期(`date`)、开始时间(`start_time`)和结束时间(`end_time`)。
*   第 6 行定义了起始和结束时间变量的输入日期-时间格式(`fmt`)。
*   第 7-8 行构建了对应于`start_time`和`end_time`的`datetime`对象。 这些 Python`datetime`对象根据我们的需要在自定义消息中进行了格式化。
*   第 11 行打印自定义消息，其中包含用户友好的时间输出和两个 Ansible 事实，即显示消息的主机的 FQDN(`ansible_facts.fqdn`)和 IPv4 地址(`ansible_facts.default_ipv4.address`)。

现在，让我们创建运行模板的剧本。 我们将剧本命名为`update-motd.yml`，并添加以下内容:

![Figure 15.51 – The update-motd.yml playbook](image/B13196_15_51.jpg)

图 15.51 - update-motd。 yml 剧本

`template`模块读取并处理`motd.j2`文件(第 8 行)，生成相关的动态内容，然后在`/etc/motd`(第 9 行)中以所需的权限(第 10-12 行)将该文件复制到远程主机。

现在，我们准备运行我们的剧本:

```sh
ansible-playbook update-motd.yml
```

命令应该成功完成。 您可以立即使用以下命令在任意主机(例如`web1`)上验证`motd`消息:

```sh
ansible web1 -a "cat /etc/motd"
```

上面的命令在`web1`主机上远程运行，显示`/etc/motd`文件的内容:

![Figure 15.52 – The content of the remote /etc/motd file](image/B13196_15_52.jpg)

图 15.52 -远程/etc/motd 文件的内容

我们也可以通过 SSH 进入任何主机来验证`motd`提示符:

```sh
ssh packt@web1
```

终端显示如下输出:

![Figure 15.53 – The motd prompt on the remote host](image/B13196_15_53.jpg)

图 15.53 -远程主机上的 motd 提示符

现在我们知道了如何编写和处理 Ansible 模板，让我们改进`motd.j2`，使其更具可重用性。 我们将*参数化*模板，方法是用从剧本传递的输入变量替换 date 和 time 的硬编码局部变量。 通过这种方式，我们将使我们的模板可以跨多个剧本和不同的输入时间进行重用，以进行维护。 以下是更新后的模板文件(`motd.j2`):

![Figure 15.54 – The modified motd.j2 template with input variables](image/B13196_15_54.jpg)

图 15.54 -修改后的 motd 带有输入变量的 J2 模板

相关的更改在第 1-2 行中，其中我们使用`date`、`start_time`、`end_time`和`utc`输入变量构建`datetime`对象。 注意*局部*变量-`start_time_`，`end_time_`(后缀为`_`)-与相应的*输入变量*之间的差异; 即`start_time`，`end_time`。 您可以为变量选择任何命名约定，假设它们是兼容 ansible 的。

现在，让我们看看修改后的剧本(`update-motd.yml`):

![Figure 15.55 – The modified update-motd.yml playbook with variables](image/B13196_15_55.jpg)

图 15.55 -修改后的 update-motd 使用变量的 Yml 剧本

相关的更改在第 5-9 行中，我们在其中添加了为`motd.j2`模板提供输入的变量。 运行修改后的剧本应该会产生与前一个实现相同的结果。 我们把相关的练习留给你们。

接下来，我们将看看另一个以基于模板的部署为特色的用例:使用组中所有其他服务器的主机记录更新托管主机上的`/etc/hosts`文件。

### 创建 hosts 文件模板

让我们首先在`./templates`文件夹中创建一个名为`hosts.j2`的新模板文件。 增加以下内容:

![Figure 15.56 – The hosts.j2 template file](image/B13196_15_56.jpg)

图 15.56 -主机 j2 模板文件

下面是模板脚本的工作方式:

*   第 3 行添加了一个与`inventory_hostname`Ansible 特殊变量引用的当前主机相对应的`localhost`记录。
*   第 5-9 行执行一个循环，遍历`groups['all']`列表(特殊变量)引用的库存中的所有主机。
*   第 6 行检查循环中的当前主机是否与目标主机匹配，如果主机是*不同*，则只执行第 7 行。
*   第 7 行通过从相关的 Ansible 事实(`hostvars[host].ansible_facts`)中读取当前主机的默认 IPv4 地址(`default_ipv4.address`)来添加一个新的主机记录。

现在，让我们创建引用`hosts.j2`模板的`update-hosts.yml`剧本文件。 增加以下内容:

![Figure 15.57 – The update-hosts.yml playbook file](image/B13196_15_57.jpg)

图 15.57 -更新主机。 yml 剧本文件

这个剧本与`update-motd.yml`非常相似。 第 9 行目标是`/etc/hosts`文件。 准备好剧本和模板文件后，让我们运行以下命令:

```sh
ansible-playbook update-hosts.yml
```

在命令完成后，我们可以使用以下命令在任意主机(例如`web1`)上检查`/etc/hosts`文件:

```sh
ansible web1 -a "cat /etc/hosts"
```

输出显示了预期的主机记录:

![Figure 15.58 – The auto-generated /etc/hosts file on web1](image/B13196_15_58.jpg)

图 15.58 - web1 上自动生成的/etc/hosts 文件

您还可以 SSH 到其中一个主机(例如，`web1`)，并通过名称 ping 任何其他主机(例如，`db2`):

```sh
ssh packt@web1
ping db2
```

您应该得到一个成功的 ping 响应:

![Figure 15.59 – Successful ping by hostname from one host to another](image/B13196_15_59.jpg)

图 15.59 -通过主机名从一台主机 ping 到另一台主机成功

这就是我们对 Ansible 模板的研究。 本节所讨论的主题仅仅触及了 Jinja2 模板的强大特性和多功能性的皮毛。 我们强烈建议您探索相关的在线帮助资源[https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html),以及标题中提到的*未来阅读*本章结尾部分。

现在，我们将把注意力转向现代配置管理平台的另一个基本特性:为各种系统管理任务共享可重用和灵活的模块。 Ansible 提供了一个高度可访问和可扩展的框架来适应这个功能——Ansible Galaxy 及其角色。 在下一节中，我们将讨论用于自动化重用的角色。

## 使用 Ansible Galaxy 的角色

通过Ansible 角色，您可以将您的自动化工作流捆绑到可重用的单元中。 角色本质上是一个包，包含剧本和其他使用变量适应特定配置的资源。 任意剧本将通过提供所需的参数来调用角色，并像运行任何其他任务一样运行它。 从功能上讲，角色封装了一个通用的配置管理行为，使得它可以跨多个项目重用，甚至可以与其他项目共享。

以下是使用角色的主要好处:

*   封装功能提供了独立的封装，可以很容易地与他人共享。
*   封装还支持关注点的分离:多个 DevOps 和系统管理员可以并行地开发角色。
*   角色可以使更大的自动化项目更易于管理。

让我们描述创建角色的过程，以及如何在示例剧本中使用它。

### 创建角色

在创建角色时，我们通常遵循以下步骤和实践:

*   创建或初始化角色目录的结构。 该目录以良好组织的方式包含该角色所需的所有资源。
*   实现角色的内容。 创建相关的剧本、文件、模板等等。
*   总是从简单的功能开始到更高级的功能。 在添加更多内容时测试剧本。
*   使您的实现尽可能一般化。 使用变量公开相关的自定义。
*   不要在你的剧本或相关文件中储存秘密。 为它们提供输入参数。
*   创建一个虚拟剧本，用一个简单的剧本运行你的角色。 用这个模拟剧本来测试你的角色。
*   在设计角色时要考虑用户体验。 如果你认为它会给社区带来价值，那就让它易于使用并与他人分享。

一般来说，创建角色包括以下步骤:

1.  初始化角色目录结构
2.  编写角色的内容
3.  测试的作用

我们将使用前面在*Using Ansible playbooks 部分*中创建的`create-users.yml`剧本作为创建角色的示例。 在继续下一步之前，让我们在`[defaults]`部分的`ansible.cfg`文件中添加以下一行:

```sh
roles_path = ~/ansible
```

这个配置参数为我们的角色设置默认位置。

现在，让我们从初始化角色目录开始。

#### 初始化角色目录结构

关于角色目录的文件夹结构，Ansible 有一个严格的要求。 目录必须与角色同名; 例如`create-users`。 我们可以手动创建这个目录，也可以使用专门的命令行实用工具来管理角色，称为`ansible-galaxy`。

要创建角色目录的框架，运行以下命令:

```sh
ansible-galaxy init create-users
```

该命令以以下消息结束:

```sh
- Role create-users was created successfully
```

可以使用`tree`命令显示目录结构:

```sh
tree
```

您必须使用本地包管理器(`apt`、`yum`等等)手动安装`tree`命令行实用程序。 输出显示了我们的角色的`create-users`目录结构:

![Figure 15.60 – The create-users role directory](image/B13196_15_60.jpg)

图 15.60 - create-users 角色目录

下面是对每个文件夹和角色目录中对应的 YAML 文件的简要解释:

*   `defaults/main.yml`:角色的默认变量。 它们在所有可用变量中具有最低的优先级，并且可以被任何其他变量覆盖。
*   `files`:角色任务中引用的静态文件。
*   `handlers/main.yml`:角色使用的处理程序。 处理程序是由其他任务触发的任务。 您可以在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html)阅读更多关于处理器的信息。
*   :解释角色的预期目的以及如何使用它。
*   `meta/main.yml`:关于角色的其他信息，例如作者、许可模型、平台以及对其他角色的依赖关系。
*   `tasks/main.yml`:角色扮演的任务。
*   `Templates`:角色引用的模板文件。
*   `tests/test.yml`:测试角色的剧本。 `tests`文件夹还可以包含一个示例`inventory`文件。
*   `vars/main.yml`:角色内部使用的变量。 这些变量具有较高的优先级，不能被更改或覆盖。

现在我们已经熟悉了角色目录和相关的资源文件，让我们创建第一个角色。

#### 编写角色的内容

从先前创建的剧本开始并将其发展成角色是一个常见的实践。 我们将使用在*使用循环*部分中编写的`create-users.yml`剧本作为我们未来角色的样板代码。 我们可以在图 15.40 中看到相关的实现。 该剧本还引用了图 15.39 中*所示的`users.yml`和`passwords.yml`文件。 让我们重构这些文件，使它们更通用。*

以下是修改后的`users.yml`和`passwords.yml`文件:

![Figure 15.61 – The modified users.yml and passwords.yml files](image/B13196_15_61.jpg)

图 15.61 -修改后的用户 yml 和密码。 yml 文件

您可能已经注意到，我们重新命名了示例用户帐户，并赋予它们更通用的名称。 我们还将`users.yml`文件中的用户字典键名从`webusers`更改为`list`。 请记住，Ansible 在提供变量的 YAML 文件中需要根级字典条目(键-值对)。

让我们看看更新的`create-users.yml`剧本:

![Figure 15.62 – The modified create-users.yml file](image/B13196_15_62.jpg)

图 15.62 -修改后的 create-users yml 文件

我们对做了以下修改:

*   我们重新调整了`loop`指令(第 24 行)以读取`users.list`而不是`users.webusers`，因为`users.yml`文件中相关字典键的名称发生了变化。
*   我们重构了`include_vars`文件引用，在第 11 行和第 15 行中使用变量代替硬编码的文件名。
*   我们添加了`vars`部分，其中`users_file`和`passwords_file`变量指向相应的 YAML 文件。

在剧本中进行了这些更改之后，我们现在已经准备好实现我们的角色了。 查看`create-users`角色目录，如图*图 15.60*所示，我们将执行以下操作:

*   将`create-users.yml`(第 6-7 行)中的`vars`部分中的变量复制/粘贴到`defaults/main.yml`中。
*   将`create-users.yml`(第 9-24 行)中的任务复制/粘贴到`tasks/main.yml`中。 确保你保持相对的缩进。
*   使用角色创建一个简单的剧本。 为您的测试剧本使用`tests/test.yml`文件。 将`users.yml`和`passwords.yml`复制/移动到`tests/`文件夹中。

下面的截图捕捉了所有这些变化:

![Figure 15.63 – The files that we changed in the create-users role directory](image/B13196_15_63.jpg)

图 15.63 -我们在 create-users 角色目录中更改的文件

我们还建议更新`create-users`目录中的`README.md`文件，并说明角色的用途和用法。 您还应该提到拥有具有相关数据结构的`users.yml`和`passwords.yml`文件的需求。 这些文件的名称可以通过`defaults/main.yml`中的`users_file`和`passwords_file`变量来更改。 您还可以提供一些如何使用角色的示例。 我们还创建了一个额外的`test2.yml`剧本，使用一个任务来运行角色:

![Figure 15.64 – Running a role using a task](image/B13196_15_64.jpg)

图 15.64 -使用任务运行角色

此时，我们已经完成了实现角色所需的更改。 您可以选择删除`create-users`角色目录中的所有空文件夹或未使用的文件夹。

现在，让我们来测试一下我们的角色。

#### 测试的作用

为了测试我们的角色，我们将使用`tests/`文件夹中的剧本，并使用以下命令运行它们:

```sh
ansible-playbook create-users/tests/test.yml
ansible-playbook create-users/tests/test2.yml
```

两个命令都应该成功完成。 您还可以使用第三个剧本(`test3.yml`)进行测试，其中您不需要在运行角色的任务中指定`users_file`和`passwords_file`:

![Figure 15.65 – Running the role with default variables](image/B13196_15_65.jpg)

图 15.65 -使用默认变量运行角色

下面的命令也应该成功完成:

```sh
ansible-playbook create-users/tests/test3.yml
```

现在，让我们用不同的文件名进行测试。 将`tests/`文件夹中的`users.yml`和`passwords.yml`文件分别复制到`myusers.yml`和`mypasswords.yml`:

```sh
cp create-users/tests/users.yml create-users/tests/myusers.yml
cp create-users/tests/passwords.yml create-users/tests/mypasswords.yml
```

更改`defaults/main.yml`中相应的变量以反映新的文件名:

```sh
users_file: myusers.yml
passwords_file: mypasswords.yml
```

运行`test3.yml`剧本应该成功完成:

```sh
 ansible-playbook create-users/tests/test3.yml
```

如果您仍然计划使用`test.yml`和`test2.yml`进行测试，请确保恢复以前的更改。 这些剧本覆盖了剧中的角色变量。

现在我们知道了如何创建和使用角色，接下来我们来看看 Ansible Galaxy，这是一个用于管理和共享角色的在线社区。 考虑任何配置管理操作，很有可能您会在 Ansible Galaxy 中找到它的一个角色。 所以，让我们看看如何从 Ansible Galaxy 中选择和检索角色，并在我们的剧本中使用它们。

### 引入 Ansible 星系

Ansible Galaxy本质上是一个由专业人士社区编写的关于 Ansible 角色的公共图书馆。 您可以通过[https://galaxy.ansible.com/](https://galaxy.ansible.com/)访问安 sible Galaxy 门户网站。 主页提供了一些有用的链接，比如通用文档、流行主题、社区页面和搜索按钮:

![Figure 15.66 – The Ansible Galaxy web portal](image/B13196_15_66.jpg)

图 15.66 - Ansible Galaxy 门户网站

让我们点击**Search**按钮并查找特定的角色。 我们将尝试找到一个安装和配置 NGINX 的角色。 搜索非常灵活，支持各种过滤和排序选项。

#### 使用 NGINX 角色

在搜索的角色标准中输入`nginx`会得到以下最顶端的结果:

![Figure 15.67 – Searching for NGINX](image/B13196_15_67.jpg)

图 15.67 -搜索 NGINX

请注意每个角色的得分和下载次数。 我们将为 NGINX 选择**Official Ansible role**。 相关的**详细信息**页面如下截图:

![Figure 15.68 – The official Ansible role for NGINX](image/B13196_15_68.jpg)

图 15.68 - NGINX 的官方 Ansible 角色

也许这个页面上最相关的信息是**安装**命令和**GitHub Repo**按钮。 让我们复制安装命令并在我们的终端中运行它。 我们将使用`~/ansible`作为工作目录:

```sh
ansible-galaxy install nginxinc.nginx
```

成功下载角色后，可以立即使用以下命令进行验证:

```sh
ansible-galaxy list
```

在这里，我们可以看到角色(`/home/packt/ansible`)的默认目录，以及在 Ansible 环境中安装的当前角色:

```sh
# /home/packt/ansible
- create-users, (unknown version)
- nginxinc.nginx, 0.19.1
```

注意我们的*自制*角色，`create-users`，以及我们刚刚下载的 NGINX 角色。

我们之前提到GitHub repo 包含了关于角色的相关信息。 NGINX 角色的相关 GitHub 链接为[https://github.com/nginxinc/ansible-role-nginx](https://github.com/nginxinc/ansible-role-nginx)。 一般来说，你可以通过访问角色的 GitHub 页面找到有价值的信息。 您应该查找角色的变量和使用示例。 我们还可以通过简单地浏览 Ansible 环境中的相关角色目录(例如`~/ansible/nginxinc.nginx`)来推断这些信息，并查看角色的实现细节。

通过对角色的 GitHub 页面和实现进行少量研究，我们精心制作了以下`nginx.yml`剧本，在我们的 web 服务器主机上安装 NGINX 服务器:

![Figure 15.69 – The nginx.yml playbook using the official NGINX role](image/B13196_15_69.jpg)

图 15.69 - nginx。 使用官方 NGINX 角色的 yml 剧本

注意任务使用相关的配置变量运行`nginxinc.nginx`角色。 下面的命令将在我们目录中的所有 web 服务器上安装和配置 NGINX 服务器:

```sh
ansible-playbook nginx.yml
```

我们已经安装并运行了 NGINX web 服务器，但由于限制性的防火墙规则，我们可能还没有在服务器上启用 HTTP 访问。 让我们再次转向 Ansible Galaxy 来寻找一些合适的防火墙角色。

#### 使用防火墙角色

我们有 Ubuntu 和RHEL/CentOS 的 web 服务器，所以我们需要这两种口味的防火墙管理器; 即`ufw`和`firewalld`。 这次让我们使用`ansible-galaxy`命令行实用工具来寻找`ufw`角色。 下面的命令在 Ansible Galaxy 存储库中搜索名称中包含`ufw`、描述中包含`configures ufw`的角色:

```sh
ansible-galaxy search ufw | grep 'configures ufw'
```

输出显示了一些结果。 让我们选择其中一个(`weareinteractive.ufw`)，并获得一些相关信息:

```sh
ansible-galaxy info weareinteractive.ufw
```

在其他信息中，我们还应该查找`download_count`属性:

```sh
download_count: 51546
```

事实证明，`weareactive.ufw`角色在我们的发现中拥有最多的下载量。 在 Galaxy web 门户中快速查找该角色也显示了良好的评价，所以我们将使用以下命令安装它:

```sh
ansible-galaxy install weareinteractive.ufw
```

该角色的 GitHub 存储库是[https://github.com/weareinteractive/ansible-ufw](https://github.com/weareinteractive/ansible-ufw)，包含如何使用它的信息。

使用相同的方法，我们将寻找一个`firewalld`角色。 在搜索时使用 Ansible Galaxy 门户网站可能会让你感觉更舒服。 我们对`firewalld`角色的选择是`flatkey.firewalld`:

```sh
ansible-galaxy install flatkey.firewalld
```

对应的 GitHub 库是[https://github.com/FlatKey/ansible-firewalld-role](https://github.com/FlatKey/ansible-firewalld-role)。

有了这些防火墙角色和相关资源，我们为我们的`firewall.yml`剧本提出了以下实现:

![Figure 15.70 – The firewall.yml playbook with the ufw and firewalld roles](image/B13196_15_70.jpg)

图 15.70 -防火墙 Yml 剧本与 ufw 和防火墙的角色

剧本包含两个任务——一个使用`weareactive.ufw`角色(第 6-15 行)，另一个使用`flatkey.firewalld`角色(第 17-28 行)。 这两个任务在第 15 行和第 28 行分别有条件语句，只在它们支持的平台上运行。 防火墙在端口`80`上启用 HTTP 访问。

让我们用以下命令运行剧本:

```sh
ansible-playbook firewall.yml
```

现在，我们可以通过 HTTP 访问所有的 web 服务器。 下面是使用`curl`命令对`web1`web 服务器进行的快速测试:

```sh
curl http://web1
```

至此，我们已经提供了关于 Ansible 角色和 Galaxy 的探索性观点。 角色是 Ansible 的一个强大功能，而 Galaxy 也为其带来了社区支持。 它们使现代系统管理员和 DevOps 能够快速地从概念过渡到实现，加速日常配置管理工作流的部署。

# 总结

在本章中，我们讨论了关于 Ansible 的重要内容。 由于本章的范围有限，我们无法捕捉到 Ansible 的大量特性。 然而，我们试图提供该平台的总体视图，从 Ansible 的架构原则到配置和使用特定命令和剧本。 您了解了如何使用几个托管主机和一个控制节点设置 Ansible 环境，从而在较高的级别上模拟真实的部署。 您还熟悉了为典型的配置管理任务编写 Ansible 命令和脚本。 本章中呈现的大部分命令和剧本与日常管理操作非常相似。

无论您是系统管理员还是 DevOps，是经验丰富的专业人员，还是即将成为专业人员，我们希望本章为您的日常 Linux 管理任务和自动化工作流带来新的见解。 您在这里学到的工具和技术将为您编写脚本和自动化日常管理程序的大部分工作提供一个良好的开端。

同样的结束语也适用于这本书。 在学习和掌握本地环境和云环境中一些最典型的 Linux 管理任务方面，您已经取得了长足的进步。

希望你能享受我们一起的旅程。

# 问题

让我们通过完成下面的小测验来总结我们在本章中学到的一些基本概念:

1.  在 Ansible 中什么是幂等运算或命令?
2.  您希望对托管主机设置无密码身份验证。 你应该遵循哪些步骤?
3.  检查与所有托管主机的通信的临时命令是什么?
4.  列举几个 Ansible 模块。 尝试设想一个可以使用每个模块的配置管理场景。
5.  在远程主机上运行任意 shell 操作或进程的临时命令是什么，比如`cat /etc/passwd`?
6.  使用`ping`模块用单个任务编写一个简单的剧本。
7.  编写剧本，将当前目录复制到远程主机。
8.  您必须将秘密 API 密钥部署到每个主机的一个定义良好的位置，每个主机都有自己的 API 密钥。 您将如何设计和实现这个功能?
9.  设想一个简单的剧本，它监视主机上可用的内存，如果内存超过给定的阈值，它将通知您。
10.  找到用于在 Linux 系统上创建用户的 Ansible Galaxy 角色。 在一个简单的剧本中使用这个角色来创建一些任意的用户。

# 进一步阅读

以下是一些我们发现有助于了解更多关于 Ansible 内部结构的资源:

*   Ansible 文档:[https://docs.ansible.com/](https://docs.ansible.com/)
*   *Ansible Use Cases*，by Red Hat:[https://www.ansible.com/use-cases](https://www.ansible.com/use-cases)
*   *深入 Ansible——从新手到专家 Ansible[视频]*,*詹姆斯 Spurin*,*Packt 出版*(【https://www.packtpub.com/product/dive-into-ansible-from-beginner-to-expert-in-ansible-video/9781801076937 T6】)
*   *实用 Ansible 2*,在*丹尼尔哦*,*詹姆斯•弗里曼**法比奥亚历桑德罗·Locati*、【显示】Packt 出版([https://www.packtpub.com/product/practical-ansible-2/9781789807462](https://www.packtpub.com/product/practical-ansible-2/9781789807462))***